{"posts":[{"title":"2022计算机保研经历（南大软院、浙大软院、武大计算机、中科大先研院、西交软院）","text":"Prelude上岸躺平了好长时间了，还是决定写点东西记录一下。 虽然路途坎坷，最终拿下了南大软院、浙大软院、西交软院和武大计算机的Offer，写一些心得，供各位学习学妹们参考。 个人情况学术背景学校：真末流985 专业：软件工程 排名：5% 外语：CET4 600多 CET6 550多 项目：全是课设，其中有一个老师给了很大的发挥空间，做了点有用的东西出来 竞赛：蓝桥杯国三+省一、建模国赛省一，还有一些其他的 院校偏向 就业导向 不直博 是不是0812无所谓，倒不如说更希望读专硕 主要看重院校的 Title 以及 是否放实习 交叉院校不怎么考虑 梦校 南软 or 浙软 夏令营申请情况 学校 院系 入营 结果 备注 西安交通大学 软件学院 ✅ 优营 计院夏令营不发offer所以没报 中国科学技术大学 先研院 ✅ 无 面试大暴死 复旦大学 工研院 ❌ 同济大学 软件学院 ❌ 其实没报，但有和我排名相近的同学报了入营了 哈尔滨工业大学(深圳) 计算机学院 ❌ 武汉大学 计算机学院 ❌ 保底用，没让入营，是我高攀不起了 南京大学 软件学院 ❌ 夏令营的唯一目标，一直做准备，没想到机会都不给 参营记录1. 西安交通大学 软件学院本来想用西交计院来保底用，但是室友告知才发现计院这次夏令营不发offer，于是就报了软院。 我们院基本上报的都入营了，没啥悬念。 6.28 面试 5-10min吧 自我介绍 可用ppt 可以英文 有没有科研经历 喜欢科研还是工程 有没有考虑过留学（一个老师看我口语还行） 你的表达太口语化了，学术场景下不合适，希望你用英语多读读论文（另一个老师委婉地怼了我，于是事后我把自我介绍的措辞改了些） 你的父母是不是住在西安（自我介绍里提到了） 基本就是聊天，没拷打专业课，没啥压力。然后不出所料地拿到优营了，好像985的都是优营。 2. 中科大 先研院本来也是用来保底的，听说是有手就行，但一年校内两年校外企业的模式不是很喜欢，感觉像卖身。而且当时一直在准备学院的实习答辩，就没准备，直接参加面试了。 7.22 面试 30min 先是让用英文做自我介绍，根据自我介绍问了两个英文问题。然后就是根据简历问问题，但是问得非常深，我九成的问题都回答不出来，对面的麦也非常糊，听不清声音，只能不停道歉。感觉是压力面，也可能是我太菜了。最后也不出所料地没有优营，虽然优营率超过90%。 暴死的原因很简单，就是没有好好准备简历，写得天花乱坠，实际上每一行我都讲不出什么东西。简历面可以是向老师疯狂输出的大好机会，但是准备不好的话就会像我一样给自己挖了一堆坑。 不过先研院的优营!=offer，还需要找到愿意收自己的导师才行，发的优营数量远超过实际offer数量，要留个心眼。 对了先研院入营之后给每个人都邮递了大礼包，还挺感动的，虽然我不去hhhh 3. 南京大学 软件学院虽然营都没入，但拿出来说说。 因为我本身是工作导向，以后整个后端就差不多了，科研什么的完全不想搞。 结合往年类似排名的学长去向，南软就是我唯一的理想去处，离家还近，梦校！ 所以夏令营期间的计划就是直接拿下南软，然后开始躺平到928。 但是现实狠狠地砸烂了我的如意算盘。南软直接没让我入营。明明南计都放了排名比我低的同学入营了。我为了防止南计先让我入营，还特地没报南计。看来是我会错意了。 虽然我当时没联系南软的导师，但是绿群里好多陶瓷了导师的也没入营（关于南软需不需要联系导师其实很有文章，后面会说） 而且后来研究了下才发现，那些我以为和我排名相同去了南软的学长，实际上人家前五学期的排名高多了，夏令营直接上岸了南软，然后前六学期的排名才掉到和我一样的（流汗黄豆 4. 南京大学 计算机学院没报，但也拿出来说说。 南大的计院和软院的招生政策可以说是完全不同。 总结一下就是：南计入营容易拿offer难，南软入营难拿offer容易。 南计在夏令营的时候会用海王营放一大堆人进来，给每个人机会。然后通过一个超难的机考来筛人。如果想去南计的话，请确保自己在夏令营的时候就把所有的基础知识复习完毕。排名低但是基础功扎实去了南计的例子是存在的。 我在夏令营的时候一直在整课设，完全没复习，所以不敢挑战。 虽然但是，从最后的去向图来看，排名高的去南大的，基本都是计院；排名低的去南大的，基本都是软院。 夏令营总结夏令营期间高估了自己，眼高手低，以为自己能直接上岸南软所以就没有海投。 但是最后只拿到了一个西交软offer。一些本可以在夏令营期间拿到的不错的中九offer，也因为完全没报，所以没拿到。比如华科和中山那些。 接下来就是两个月的专业课复习time了，然后全力冲刺预推免 预推免申请情况 学校 院系 入营 结果 备注 浙江大学 软件学院 ✅ 优营 南京大学 软件学院 ✅ 优营 武汉大学 计算机学院 ✅ 候补 bar比夏令营时候低了，不过大家都是候补 华中科技大学 计算机学院 ❌ 可能预推免期间不怎么招人了 哈尔滨工业大学(深圳) 计算机学院 ❌ 招的人太少了，感觉bar已经到top2级别了 参营记录1. 浙江大学 软件学院自从被南软背刺，浙软就是我的新欢。 整个预推免期间都是按照浙软来准备的。 入营倒是很容易，我们院的保研边缘人都入营了。不过分为软件工程和人工智能两个专业，人工智能招的人很少，软工180，AI30。但是发现大家竟然都去梭哈人工智能了，导致人工智能的报录比比软件工程高不少。我报的就是软件工程，那没事了。 浙软的考核包括机试+面试，说是 机考*0.85+面试*0.15，但是只要机考不拉跨，基本就稳了 机试 9.19 用的平台是PTA，四道题，中文题目，三个小时，时间还算够用。 总共参加726人，我考了88，rk 104，不算高，但也够用了。 我当时是准备的方法是刷了很多PAT真题，但PAT是陈越姥姥出的，题目英文。浙软机考现在换了出题人，题目变成了中文，出题风格也变了。 这次的题目考察重点不是纯数据结构知识，都和数学沾点边，一堆处理分数和素数之类的。我数学也不咋地，没想出啥高效解法，就用暴力做了。只能说我刷了那么多PAT，虽然用处不是很大，但也打了点底子吧。 面试 9.23 好像是20min-30min，不过这次准备得很充分，所以感觉时间过得很快。 首先是个人陈述5-8min，其中包含1min的英文内容。可以用PPT。 没有英文提问。 自我介绍完后问了我点项目的问题。 专业课方面问了数据结构的哈夫曼编码和操作系统的内存管理方式。 数学方面问了下面的问题 拉格朗日中值定理是什么 特征值为0，和矩阵的秩有什么关系 我第一个直接说不会，然后换成了第二个，第二个我想都没想直接说不会hhh 其实我知道浙软的面试一定会问点数学问题，线性代数我也复习了点，其实第二道题面试结束我就想到答案了。但是出于对数学的恐惧我直接说了不会hhhh。然后老师也就没再问我数学问题了。 剩下的时间又问了我点项目上的东西就结束了。 结果 9.26 录取名单出了，我排69/180，算是通过两个月的努力凭本事拿到的offer。 替补也给了180个，928的时候差点就穿了，不过还没穿。 浙软可以说只要用心准备都能拿到offer，很给面子。效率也很高，各种名单出的很快，很透明。 2. 南京大学 软件学院南软我又来辣 夏令营发现自己没入营之后我就开始去陶瓷导师了。当时其实非常讨厌陶瓷，一是陶瓷了也可能不去，不好意思鸽老师；二是我没啥科研经历，自己都不认为会有老师愿意收我。 于是就只陶瓷了南软的一个导师，但没想到上来拐弯抹角了会后就问我能不能直博，我直接拒绝了，然后我就以为黄了。之后也没管过了，伤透了心，一心研究浙软。 没想到两个月后南软的导师问我报名了没，我就说报了，其实我当时能不能入南软营都无所谓了，心想你难道还能把我捞进去不成？ 然后导师就真的一声不吭地把我捞入营了，排名比我高的都没入。我tm直接黑人问号，不是说南软导师没法捞人吗。 之前有的学长说需要陶瓷，有的说不用陶瓷。现在我才懂了，南软是半强com，导师有推荐名额，能保入营，但拿offer看自己本事。所以陶瓷了也没入营的可能是导师不乐意捞。 考核 南软的考核也分笔试和面试，但没公布分数组成。 笔试 9.20 每年可能都不一样，我说的仅仅是当年情况 预推免时考的都是选择题，和夏令营时考的内容不一样。 这次的内容全是程序基础题，看代码选运行结果，需要对语法和特性很熟悉，一半C++，一半Java，最后还有一些软件工程题。 半个小时30题吧，时间够了。 考完看不到分数，不知道考得咋样。 面试 9.21 笔试通过的会发邮件让参加面试，面试里要求不准说出字记得姓名和学校。 我的情况比较奇葩，遇到的老师比较水。 上来让我自我介绍，不需要PPT。可能我讲的时间有点长，讲完之后，就告诉我可以了结束了，总耗时差不多5min。 我愣了下，问 “这就结束了吗？可以退出会议了？”，答复是 yes。然后就懵逼地退出了会议。 事后问了其他人，有的组是被狠狠拷打了。所以当时我很忐忑，不知道自己到底是稳了还是寄了。 结果 9.23 收到了预推免结果为优秀的短信，但当时非常怀疑，害怕这个优秀也得排在夏令营优秀后面的wl里。因为wl非常麻烦，不公布名单，要不停联系教务处问排名才能知道自己能不能被录取。 9.26 南软发了预录取的邮件，这下心里的石头终于落下了。 自我感觉能拿下南软的offer纯属运气，之前准备的那么多东西在面南软的时候也没用上。而且南软的考核真的纯纯黑盒，连个群都没拉，只通过短信和邮件通知，跟搞黑幕一样。不过我是既得利益者，不好说啥( 3. 武汉大学 计算机学院武大计算机夏令营的时候bar挺高，没让我进。不过预推免倒让我进了。 武大我其实不太感冒，因为不是太面向就业。我当时想的是要不浙软南软，要不就去西交找个羊导，破釜沉舟了属于是。 反正也是保底，就当作给浙软南软的面试当排练了。 武大的考核只有面试 9.22面的，15min，1-2min的自我介绍。 然后就是一些比较抽象的问题： 为什么想来武汉大学（英文问题） 介绍自己的项目 研究生阶段和本科阶段学习的区别 落地和不落地项目的区别 自己的性格 没怎么问专业课，都是这种开放问题，这种问题我也不太会编，回答得不咋地。 结果 9.23 出了预推免的名单，我排前一半，不咋地，不过超过了不少武大本校✌是没想到的。 后来听说大家都是候补，而且因为名额缩减，夏令营的优营都不知道能不能录完。 反正我也不去武大，就直接放弃了。 最终去向主要就是纠结去浙软还是去南软了。 其实也没啥好纠结的。 我本来就是江苏人，南大离得近，放假能回家 南软两年，浙软两年半，南软能更早出去赚钱 南软放实习，浙软平时不放，最后的半年可以自由实习 南软在南京市区，浙软在宁波，没啥浙大归属感 南软有个不嫌弃我还捞我的导师 就我个人而言，南软除了title比浙软小一点，其他所有方面我都很满意。 虽然大一的时候我墙上贴的是浙大，但最后还是去南软辣。","link":"/2022/12/02/2022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86%EF%BC%88%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%B5%99%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%AD%A6%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%85%88%E7%A0%94%E9%99%A2%E3%80%81%E8%A5%BF%E4%BA%A4%E8%BD%AF%E9%99%A2%EF%BC%89/"},{"title":"《Linux从入门到精通》笔记 第10章 进程管理","text":"快速上手：结束一个失控的程序 ./badpro &amp; 后台执行当前目录的badpro可执行文件 ps aux | grep badpro 在所有后台进程中寻找badpro kill 12974 杀死端口号为12974的进程 什么是进程 简介 进程是运行着的程序 进程的重要信息 内存地址 进程当前的状态 进程正在使用的资源 进程的优先级 进程的属主 进程的常用属性 PID：进程的ID号 在对进程进行操作时，使用的都是PID，而不是进程名 PPID 父进程的PID Linux中所有的进程都由另一个进程创建 实际上子进程由父进程克隆而来 UID和EUID 真是和有效的用户ID UID为进程属主 EUID为有效用户ID，一般情况下和用户ID相同 GID和EGID 真实和有效的组ID 谦让度和优先级 优先级越高越容易被执行 谦让度和优先级是相反的概念 用户只能够设置谦让度 监视进程：ps命令 ps 显示前台所有的进程信息 ps aux 显示当前系统上所有的进程信息 ps lax 可以在ps aux的基础上提供父进程PPID和谦让度NI 不会显示进程属主的用户名 即时跟踪进程信息：top命令 ps可以给出当前系统中所有进程信息的快照，但是缺乏时效性 top 可以实时跟踪当前系统中进程的情况 显示的信息会占满一页，每10s更新一次 可以显示cpu使用率、内存占用率等信息 按q退出监视程序 查看占用文件的进程 lsof 文件名 给出给出使用当前文件的进程的信息 向进程发送信号：kill 简介 kill命令可以杀死进程 kill标准语法 kill [-signal] pid kill命令的常用signal 使用kill -l可以显示所有的signal kill 12974 终止某个进程 Ctrl+C 等同于信号INT sudo kill -KILL pid -TERM只是向进程发送终止信号，进程可能忽略该信号 -KILL可以从内核级别杀死一个进程 调整进程的谦让度：nice和renice nice 简介 nice可以在程序启动的时候设置谦让度 谦让度越低优先级越高 使用例子 nice -n 2 bc 以谦让度2启动bc sudo nice -n -3 bc 以谦让度-3启动bc nice bc 不加-n的话，无法指定谦让度，默认为10 renice 简介 可以在程序运行时设置其谦让度 renice +12 -p 8567 通过-p指定进程的pid 将pid为8567的进程的谦让度设置为12 现在设置谦让度没什么意义了，cpu会自动调度 /PROC文件系统 简介 proc文件夹存放了和内核有关系统状态的信息 ps和top读取的就是/proc文件夹中的信息 小结","link":"/2023/11/26/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC10%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"《Linux从入门到精通》笔记 第15章 远程登录","text":"15.1 快速上手，搭建实验环境 VPS还是虚拟机 VPS可以进行真正的远程登录。 虚拟机需要考虑宿主机的网络问题，如桥接等。 安装OpenSSH OpenSSH是Linux下常用的SSH服务器/客户端软件。 可启动SSH服务器，等待连接，通常随系统启动。 安装vnc4server VNC用于图形化远程登录，Linux一般自带服务器端。 VNC包括： vnc4-coooon vnc4server 防火墙设置 Ubuntu Desktop 默认关闭防火墙，不用考虑。 openSUSE 需要设置防火墙规则。 15.2 登录另一台 Linux 服务器 远程登录有多种方式，也可以从 Windows 或 Linux 登录到另一台 Linux。 Secure Shell：SSH SSH 是 Secure Shell 的缩写。 rlogin、rcp、telnet 是古老的远程登录软件，但由于安全问题已不再使用。 SSH 是协议，SSH2、OpenSSH 是具体实现。 从一个 Linux 登录另一个 Linux： ssh -l login_name hostname login_name 是用户名。 hostname 是主机名或主机的 IP 地址。 登录成功后，Shell 中的主机名会发生变化，注意区分。 使用 exit 退出 SSH 连接。 注意： 不建议在远程机上进入 root 模式。 推荐使用 su 或 sudo 临时获得 root 权限。 端口问题： SSH 服务端默认监听 22 端口。 如果服务端没有使用 22 端口，可通过 -p 指定端口： ssh -l liu -p 202 192.168.150.139 运行带 GUI 的 X 程序： 连接服务器时使用 -X 关键字开启 X 转发功能： ssh -X -l liu 192.168.150.139 前提是服务器开启了 X 窗口系统，这样可转发整个界面。 登录 X 窗口系统：图形化的 VNC 普通的 SSH 只能转发 SSH 应用。 VNC 可通过 X 窗口直接登录服务器。 VNC 全称 Virtual Network Computing。 从 Windows 登录 Linux Windows 有许多 SSH 客户端，比如 PuTTY。 从 Linux 登录 Windows 此部分暂未查看。 15.5 使用 SSH 密钥 普通的 SSH 登录方法是提供账号和口令（用户名和密码）。 为什么使用密钥？ 密钥只需输入一次，更加方便。 密钥的特点： 密钥分为一对：公钥和私钥。 服务器存放公钥，客户端存放私钥的副本。 连接时，服务器检查公钥和私钥是否匹配。 生成密钥对： SSH 提供 ssh-keygen 来生成密钥对。 使用 -t 指定密钥类型，通常使用 rsa： ssh-keygen -t rsa 运行该命令后，会在用户目录的 .ssh 目录下生成两个文件： id_rsa 为私钥，id_rsa.pub 为公钥。 复制公钥到远程主机： 复制公钥到要登录的用户目录下的 .ssh 文件夹，并命名为 authorized_keys。 登录： 使用 ssh 192.168.150.139 即可登录。 我的理解： SSH 密钥可以在客户端或服务器端生成。 最终需要保证客户端持有私钥，服务器持有公钥。 指定用户的两种方式： ssh -l username destination ssh user@destination 指定私钥的方式： 使用 -i 指定私钥地址。 省略私钥地址的方法： 把私钥放在 ~/.ssh/ 下，并命名为 id_rsa，即可自动使用该私钥： 直接 ssh destination 登录。 或者使用 ssh-add 添加公钥地址。 权限太开放（too open）问题： 使用 chmod 400 设置公钥权限。 需要限制公钥权限，否则可能无法通过验证。","link":"/2023/11/28/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC15%E7%AB%A0%20%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"},{"title":"《Linux从入门到精通》笔记 第5章 Shell基本命令","text":"Shell 简介 命令行是输入命令的界面 Shell是命令解释器，是程序 Linux默认的Shell是 Bash Shell 输入输出约定 提示符 输入行开头的 $ 或 # 表示提示符 $表示普通身份 #表示root身份 命令格式 提示符+命令+注释 注释 由”##”开头 简单文件指令 进入目录： cd+地址 cd / ：进入根目录 cd ：单独一个cd不带参数，进入home下的用户目录 cd /地址：地址以斜杠开头，表示进入从根目录开始的完整地址 列出当前地址下的文件和目录： ls **/etc目录下存放了linux的配置文件 提高效率：使用命令行补全和通配符 补全 单击 tap 可以补全命令或者文件名 双击 tap 可以显示当前输入开头的所有内容 通配符 “*” 表示一个或多个字符 “?” 匹配单个字符 “[abc]” 匹配 a或b或c，单个字符 “[1-3]” “[a-z]” 表示字符范围中的某个字符 ls 字符串表达式 这样就可以列出符合条件的关键字 完整的查看目录和文件命令 显示当前路径: pwd 改变目录: cd cd /：进入根目录 cd ..：返回上一层目录 .. 表示上一层目录 . 表示当前目录 cd 或 cd ~：回到用户主目录 列出目录内容： ls ls的语法格式： ls [optional] [file] ls：不带参数 列出所有的目录和文件 颜色，不同平台上颜色不一样 目录 蓝色 普通文件 白色 链接文件（快捷方式） 青色 可执行文件 草绿色 ls -F 通过后缀标明 文件类型 / 文件夹 @ 链接文件 可执行文件 -a 显示所有的“.”开头的隐藏文件 -aF 指定多个选项只需要一个横杠 -l 显示文件的属性 ls + 路径名 可以查看指定路径中的文件 列出目录内容： dir和vdir dir 等同于 ls，不过不显示颜色 vdir 等同于 ls -l，显示详细信息 查看文本文件： cat和more cat cat 文件名：查看文本文件 cat -n 文件名：查看的时候显示行号 more more 文件名：一页一页查看文件 按空格翻动一页，按Enter翻动一行，按Q退出 查看文件的开头和结尾： head和tail head head 文件名：简单查看文件开头 head -n 行数 文件名：指定查看文件的行数 tail 用法和head相同 更好的文本阅读工具： less 基础用法：less 文件名 移动方式 可以通过方向键控制文档移动 空格 下一页，B 上一页，Q 退出 字符串搜索 按下/，输入key，按回车 搜到的关键字会被高亮 less -M 文件名 可以在最后一行显示文件名，行数，百分比 查找文件内容： grep 基本用法 grep [options] PATTERN [FILE…] grep 可选项 ‘模式串’ 文件名 例子 grep un day 在day文件中 查找包含 un 的那行 当模式串中包含空格时，需要用单引号括起来 模式串还可以使用正则表达式 find命令 基本语法 find [option] [path…] [expression] 例子 find /usr/bin/ -name zip -print /usr/bin/： 指定路径范围 如果搜索全路径，可以用 “/” -name zip： 指定名称 -print：将结果打印到屏幕，这个不加实际上也没事 find /etc/ -name init.d -type d -print -type d：指定文件类型为d，也就是目录文件 -atime +n 最后一次使用在n天之前的文件 -mtime +n 最后一次修改在n天之前的文件 更快速地定位文件 locate命令 基本用法 locate [pattern] 例子 locate *.doc 直接找到所有类型为doc的文件 支持正则表达式 优点 比起find方便多了，不需要太多的参数 并且更快，因为locate查询的是文件名数据库，不是文件目录 可以通过 updatedb手动更新数据库 依赖 sudo apt install mlocate 缺点 如果查的是新文件，那么每次查询前需手动 updatedb 从终端运行程序 使用方式 直接输入应用的名字 比如 $ firefox 如果运行当前目录中的文件，则需要 “./可执行文件名” $ firefox：前台打开firefox，并且关闭之后才能从控制台输入新的指令 $ firefox &amp;：后台打开firefox，此时可以正常输入指令 $ kill 12876：关闭端口号为12806的进程 查找特定程序 whereis whereis find 查找find程序的可执行文件位置 和 手册页存放位置 whereis -b find 查找find程序的二进制可执行文件 用户及版本信息查看 who 当前系统有哪些人登录 whoami 察看自己的身份 uname -a 给出操作系统所有信息 uname -r 给出内核版本信息 寻求帮助 man命令 man 命令名称 给出命令的详细帮助信息 实际上用的是less指令 j向上，k向下，或者用方向键也行 空格下一页，b上一页 获取命令简介，whatis和apropos whatis find 给出find命令的简介，一句话 apropos search 给出与search相关的所有命令 属于用功能反推出命令 小结 pwd 显示当前目录 cd 切换目录 ls 查看目录 find和locate可以查找文件和目录 grep可以查找文件内的内容 less 查看文件直接用这个就行 whereis 可以查找程序文件的位置 man 查看程序的详细帮助 whatis 查看程序的简要说明 apropos 通过功能查找指定的程序","link":"/2023/11/12/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC5%E7%AB%A0%20Shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"title":"《Linux从入门到精通》笔记 第6章 文件目录管理","text":"6.1 Linux文件系统的架构 Linux没有盘符，也就是C盘D盘。 Linux先有根目录，再有分区，可以将不同的分区挂载到不同的子目录上。 对于没有挂载目录的分区，统一放在根分区中。 6.3 建立文件和目录 建立目录：mkdir 例子： mkdir document picture 在当前目录下创建 document和picture两个文件夹。 mkdir ~/picture/temp 在指定目录下创建指定文件夹。 注意路径中的每一个父目录都必须存在。 mkdir -p ~/tempx/job 加上了 -p 选项，可以新建一个完整的路径。 建立一个空文件：touch touch 文件名。 可以覆盖文件。 6.4 移动、复制和删除 移动和重命名：mv 例子： mv hello bin/ hello 文件移动到 bin/ 下。 注意文件夹后面一定要加斜杠 /，不然就是文件。 mv Photos/ 桌面/ Photos/ 文件夹移动到 桌面/ 下。 文件重复问题： mv 默认会覆盖重复文件。 mv -i 会在覆盖前提示，y 覆盖，n 跳过。 mv -b 发现重复时，在重复的文件的名字后面自动加上 ~。 重命名： mv fileA fileB 将 fileA 重命名为 fileB。 重命名实际上就是移动文件的同时重命名。 复制文件和目录：cp 例子： cp test.php test/ 将 test.php 复制到 test/ 目录下。 默认覆盖同名文件。 cp -i 发现重名文件时进行提示。 cp -r 普通的 cp 在复制的时候只复制文件，会跳过文件夹，cp -r 会复制所有文件和文件夹，以及文件夹里的所有子目录。 删除目录和文件：rmdir 和 rm rmdir： 用于删除文件夹，但只能删除空的文件夹，基本没用。 rm： rm 文件名 只能删除文件。 删除被保护文件时会提示。 rm -i 文件名 删除所有文件时都会提示。 rm -f 文件名 和 rm -i 相反，删除被保护文件时不提示。 rm -r 目录 递归删除所有文件和目录。 rm -rf 无提示地删除当前目录下的所有目录和文件，慎重使用。 6.5 文件和目录的权限 Linux是多用户操作系统，可以给不同用户设置权限。 权限设置针对的用户： Linux中的三种用户： 文件所有者（属主） 通常是文件创建者，也可以通过root转让给别人。 文件属组用户 文件的属组是一组用户的集合。 其他人 权限最低。 超级管理员root单独算。 需要设置哪些权限： 三种权限： 读取 r 写入 w 执行 x 文件的三种权限： 读取：打开查看文件的内容。 写入：修改文件内容。 执行：执行可执行文件。 目录的三种权限： 读取：用户能否列出目录中的内容。 写入：在目录中创建、删除和重命名文件。 执行：用户能否进入目录。 查看文件和目录的属性： 使用 ls -l /bin/login 可以查看文件的属性。 使用 ls -ld /etc/ 显示 etc 文件夹的属性。-d 表示显示选择的当前文件夹。 改变文件所有权：chown 和 chgrp chown [OPTION] … [OWNER][:[GROUP]] FILE… 将 FILE 的属主改为 OWNER，属组改为 GROUP。 sudo chown -R lewis iso/ 将 iso/ 和其中的所有子目录全部给 lewis，-R 表示递归操作。 chgrp 可以单独更改文件的属组。 更改文件权限：chmod chmod u+x days 给属主增加 days 的执行权限。 chmod a-x days 给所有角色删除 days 的执行权限，a 代表所有角色（即 ugo）。 chmod ug=rx, o=r days 给属组和属主读和执行权限，给其他人读权限。 chmod o=u days 将属主的权限赋予给其他人。 6.6 文件类型 Linux中的所有内容都表示为文件，共有七种文件类型。 使用 ls -l 可以查看文件类型，第一列的第一个字符表示文件类型： d 表示目录文件，- 表示普通文件。 建立链接（符号链接）：ln ln -s TARGET LINK_NAME 为文件 TARGET 创建软链接 LINK_NAME。 加上 -s 选项创建软链接。 6.7 输入输出重定向和管道 输出重定向： 程序的默认输出地方叫做 stdout（标准输出），标准输出指向显示器。 输出重定向可以把程序的输出转移到另一个地方： 例子：ls &gt; ~/ls_out 将 ls 指令的输出放到 ~/ls_out 文件中。 如果文件已存在，会直接覆盖。用 &gt;&gt; 追加内容。 输入重定向： 程序默认接收输入的地方叫 stdin（标准输入）。 例子：cat &lt; days 从 days 文件中接收输入并打印出来。 Here Document：cat &lt;&lt; EOF 表示只从键盘获取输入，EOF 为用户指定的终止符。 管道： 管道将一条命令的输出连接到另一条命令的输入，使用 | 关键字： 例子：ls | grep ay 先由 ls 列出当前目录下的全部文件名，然后将结果发给 grep，找出包含 “ay” 的文件。 6.8 小结 Linux将文件系统挂载到目录下，根目录 / 是最初建立的文件系统。 mkdir 创建新目录。 touch 创建空文件。 mv 移动并重命名文件和目录。 cp 复制文件和目录。 Linux文件角色分为属主、属组、其他人。 Linux文件权限分为 rwx。 ls -l 可以显示文件的所有属性，ls -ld 显示当前目录的属性。 chown 更改文件的属主和属组。 chmod 更改文件权限。 Linux有七种文件类型。 ln -s 建立软链接。 输入重定向。 输出重定向。 管道。","link":"/2023/11/18/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC6%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"title":"《Linux从入门到精通》笔记 第7章 软件包管理","text":"7.2 软件包管理系统简述 软件包管理系统可以自动安装软件包，以及它们所需的依赖。 软件包格式有两种： RPM，由Red Hat开发。 .deb，由Debian和Ubuntu使用。 软件包管理工具有 APT 和 yum（只能用于RPM格式）。 还有 dpkg 和 rpm 两个低级软件包管理工具。 7.3 管理.deb软件包：dpkg 简介：dpkg 主要用于Debian和Ubuntu的软件包管理。 安装软件包： dpkg -i 软件名 或 dpkg --install 软件名。 查看已安装的软件包： dpkg -l： 查看所有安装的软件包。 dpkg -l | grep firefox： 在 dpkg 的输出中搜索含有 firefox 关键字的行。 显示当前安装的 firefox 软件包信息。 使用了管道 |。 卸载软件包： sudo dpkg -r 软件名。 sudo dpkg --remove 软件名。 7.4 管理RPM软件包：rpm 简介：rpm 主要用于 .rpm 格式的软件包，适用于 OpenSUSE 和 Red Hat，不适用于 Debian 和 Ubuntu。 7.5 高级软件包工具：APT 简介：rpm 和 dpkg 是低级软件包管理器，无法自动解决依赖问题，APT 和 yum 是高级软件包工具。 APT简介： APT 全称 Advanced Package Tool。 能自动检测和解决软件依赖。 支持 .deb 和 .rpm 两种软件包格式。 APT 常用的两个命令： apt-get：安装软件包。 apt-cache：查找软件包的相关信息。 APT 也有图形化工具。 下载和安装软件包： 使用 apt-get install 之前，先执行 sudo apt-get update 更新 apt-get 缓存中的软件包信息，确保将要下载的软件是最新版本。 之前用 apt-get 下载 node 不是最新版，可能是因为没有执行 apt-get update。 apt-get 的常用命令： 使用 apt-get -h 可以列出 apt-get 的完整用法。 也可以使用 man apt-get 查看详细信息。 查询软件包信息： apt-cache search flight： 搜索带有 flight 字样的软件包，根据名字下载。 apt-cache depends flightgear： 显示 flightgear 软件包的依赖关系。 配置 apt-get： apt-get 的安装源在 /etc/apt/sources.list 文件中。 文件格式： deb 表示 .deb 软件包的源地址。 deb-src 表示源代码的源地址。 使用图形化的 APT： 没有看到详细内容。 7.7 小结 软件包是对应用程序的打包，使用软件包管理系统可以方便地安装和卸载软件。 Linux 的软件格式分为 .deb 和 .rpm。 普通软件包管理工具有 dpkg 和 rpm。 高级软件包管理工具有 APT 和 yum。 apt-get 和 apt-cache 是常用命令。 /etc/apt/sources.list 可以修改 apt 的安装源。 apt-get update 用于更新软件包信息。","link":"/2023/11/24/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC7%E7%AB%A0%20%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"},{"title":"《MySQL是怎样运行的》笔记 第一章","text":"重新认识MySQL1 MySQL的客户端/服务器架构 a. 服务器处理存储的数据，客户端发出增删改查的请求 b. 服务器进程的名称为mysqld c. 客户端进程的名称为mysql 2. MySQL的安装 a. bin目录下的可执行文件 i. MySQL的安装目录下有一个bin文件夹，有很多可执行文件 b. 运行bin目录下的mysqld就可以开启mysql服务器 i. 环境变量PATH 1) 环境变量是一系列地址的集合，通过冒号隔开 2) 指定了环境变量之后，输入命令的时候就会从环境变量的地址中找有没有这个命令 3) 就不需要每次都到MySQL的目录下去执行命令了 3. 启动MySQL服务器程序 a. UNIX i. mysqld ii. mysqld_safe iii. mysql.server iv. mysql_multi v. 自己看详细区别，启动的时候查手册就行 b. Windows i. mysqld 1) 直接双击就能启动了 2) 或者把mysqld注册为windows服务 a) 需要长时间使用的程序都可以注册为服务 b) 注册为服务的指令 i) &quot;文件的完整路径&quot; --install [-manual] [服务名] 3) 然后通过net start MySQL来启动服务 4) 用stop来停止服务 4. 启动MySQL客户端程序 a. 连接方法 i. 执行mysql文件就行 ii. mysql -h主机名 -u用户名 -p密码 1) mysql -hlocalhost -uroot -p123456 2) -P 大写的P参数可以用来指定端口号 iii. 小注意： 3) 对于-h -u -p这种只有一个字母的参数，前面加一个dash 4) 对于--password这种长参数，前面就需要加两个dash b. 断开连接并且关闭mysql客户端的方法 i. 三种 5) quit 6) exit 7) \\q ii. 输出Bye时，就说明关闭成功了 iii. 但是只是关闭了客户端程序，服务端程序并没有关闭 c. 注意点 i. 可以-p后面不加密码，然后会单独要求输入密码，更安全 ii. 如果想在-p后面加密码，就注意和密码之间不能有空格 iii. 如果客户端和服务端在同一台机器上，就可以省略 -h参数 iv. 如果使用linux，可以省略-u参数，会自动使用linux的用户名 5. 客户端与服务器连接的过程 本质就是进程的通信 a. TCP/IP i. 一般服务器和客户端之间使用TCP连接 ii. 服务器默认申请3306端口号 iii. mysqld -P3307 1) 可以在启动的时候指定申请的端口号 b. 命名管道和共享内存 i. 这两种都是windows提供的进程间通信方式 ii. mysql可以用这种方式连接同一主机的进程 c. Unix域套接字文件 i. 也就是socket文件，linux里万物皆文件 ii. 使用linux的话，如果客户端和服务端在同一台主机上 2) 那么就可以使用linux套接字文件进行连接 6. 服务端处理请求的流程 a. 简介 i. b. 连接管理 i. 会给每个客户端都分配一个线程 1) 因此会用到线程池，复用线程 ii. 还能使用SSL来增强连接的安全性 c. 解析和优化 i. 简介 2) mysql服务器获得文本形式的请求后，会进行 查询缓存、语法解析和查询优化 ii. 查询缓存 3) 只有查询语句一模一样时，才会命中缓存 a) 只要有一点改变都不会命中 4) 调用系统函数或者查询系统的表时，不会缓存请求 a) 因为每次调用返回的值都有可能不同 5) 当表被更新时，涉及到该表的缓存会立刻失效 6) 因为维护缓存比较麻烦，所以MySQL8.0的时候就把查询缓存给删了 iii. 语法解析 7) 缓存未命中之后，就进行语法解析 8) 判断sql语句语法是否正确 9) 然后进行编译 iv. 查询优化 10) 服务器会对我们写SQL语句进行优化，提高执行效率 11) 使用Explain就可以查看语句的执行计划 d. 存储引擎 i. mysql把对于数据的存储和读取都封装到了存储引擎中 12) 前面的连接管理 解析和优化其实并不涉及到数据 ii. 存储引擎负责数据的存储和读取 iii. MySQL server完成了查询优化之后，只需要调用存储引擎提供的API就行了 7. 常用存储引擎 a. 有很多不同的存储引擎 b. 其实最常用的就是InnoDB和MyISAM i. 一个支持事务和外键，一个不支持 ii. 后面有详细讲解 8. 关于存储引擎的操作 a. 查看当前支持的存储引擎 i. SHOW ENGINES; b. 设置表的存储引擎 i. 可以给不同的表设置不同的存储引擎 ii. 默认使用InnoDB iii. 创建表时指定存储引擎 iv. 修改表的存储引擎","link":"/2023/03/16/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/"},{"title":"《MySQL是怎样运行的》笔记 第七章 B+树索引的使用注意点","text":"7.1 索引的代价 索引虽然快，但在时间和空间上都有代价： 空间代价： B+树的每个节点都是一个数据页，一个页默认占用16KB，因此会有不少开销。 时间代价： 对数据进行增删改操作后，需要对每个索引进行维护。 建立的索引越多，维护的开销也越大。 7.2 B+树适用的条件（什么样的查询能够走索引） 简介： B+树并非万能，并不是所有的查询都可以走索引。 仅适用于几种特定的查询情况。 全值匹配： 介绍： 如果搜索条件中使用的字段与索引用到的字段完全一致，就是全值匹配。 对于联合索引，搜索时需要用到所有联合索引的字段。 问题： 字段的顺序对查询是否有影响？ 无影响，查询优化器会自动优化，调整为联合索引的顺序。 匹配左边的列： 当使用联合索引进行查询时，可以使用索引左边连续的几个字段，仍能走索引。 如果跳过左边的字段，只用右边字段查询，则无法走索引。 匹配列前缀： 对于字符串类型的字段，可以用前缀进行查询。 例如：SELECT * FROM person_info WHERE name LIKE 'As%';，因为字符串是按字典序排序的，所以可以走索引。 中缀和后缀匹配无法走索引，只能全表扫描。例如：SELECT * FROM person_info WHERE name LIKE '%As%';。 后缀匹配想用索引的话，可以将所有数据逆序存储，使后缀变为前缀。 匹配范围值： B+树索引的记录是按索引字段排序的，可以轻松实现范围查询。 联合索引范围查询时，只能使用最左边的字段走索引，其他字段需要逐个过滤。 精确匹配某一列并范围匹配另一列： 对联合索引使用范围查询时，如果左边字段相同，右边字段可以走索引。 用于排序： 介绍： 查询时如果使用 ORDER BY 子句，需要对指定字段排序。 如果 ORDER BY 使用的是索引字段，则可以省去排序过程。 联合索引排序注意事项： ORDER BY 字段顺序必须与联合索引的字段顺序一致，否则无法走索引。 如果 ORDER BY 中混用了 ASC 和 DESC，则无法使用索引。 WHERE 子句中的字段必须包含在索引字段中，否则也无法走索引。 无法使用索引进行排序的情况： ORDER BY 中的字段属于不同索引。 ORDER BY 中的字段使用了复杂表达式，例如：SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;。 用于分组： 如果 GROUP BY 使用的字段与索引字段一致，分组查询时相当于已经分好组。例如：SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number;。 7.3 回表的代价 二级索引范围查找： 二级索引查找后得到一系列主键，需要通过主键到聚集索引查找完整用户记录。 顺序IO：二级索引查找时使用，速度较快。 随机IO：聚集索引查找时使用，速度较慢。 回表记录越多，二级索引效率越低： 当回表记录多时，二级索引效率不如直接全表扫描。 查询优化器的选择： 查询的记录较少时，使用二级索引+回表。 记录较多时，直接全表扫描。 覆盖索引： 在 SELECT 子句中只使用索引字段，可以避免回表操作。 7.4 如何挑选索引 只为用于搜索、排序、分组的字段建立索引。 WHERE 子句、ORDER BY 子句和 GROUP BY 子句中的字段需要建立索引，SELECT 子句中的字段不需要建立索引。 考虑列的基数： 列的基数指的是不重复数据的数量。 基数大的字段适合建立索引，因为基数小的字段重复值较多，建立索引意义不大。 索引字段的类型尽量小： 能用 INT 就不要用 BIGINT，因为： 数据类型小，比较操作更快。 数据类型小，索引占用空间更少，读取的记录更多。 索引字符串的前缀： 针对字符串类型的字段，可以只使用前缀建立索引。 前缀索引的缺点：字段不完全有序，ORDER BY 只能使用文件排序。 索引字段必须单独出现在比较表达式中： 例如： WHERE my_col * 2 &lt; 4 无法走索引。 WHERE my_col &lt; 4 / 2 可以走索引。 结论：索引字段必须单独出现在表达式中，不能使用嵌套表达式或函数调用。 主键插入顺序： 新插入的记录如果主键不是最大的，会导致页面分裂和记录移位，从而影响性能。 解决办法：使用自增主键，在字段后加 AUTO_INCREMENT。 避免冗余和重复索引： 不要给同一个字段建立多个索引，例如 UNIQUE 关键字会自动建立索引。","link":"/2023/03/20/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%83%E7%AB%A0%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"title":"《MySQL是怎样运行的》笔记 第三章 字符集和比较规则","text":"字符集和比较规则简介 字符集简介 字符集负责处理字符与二进制数据的存储关系 比较规则 字典序也就是比较他们二进制的大小 除了字典序外也有其他的比较规则 重要的字符集 ASCII 128个字符，包括数字、大小写字母、空格等等 每个字符一个字节 GB2132 包括中文和其他国家的字符 存在于ASCII中的字符用1个字节存储 其余的字符用2个字节存储 也就是变长存储方式 GBK 对于GB2132的字符收集范围做了补充，其余一样 Unicode系列 对地球上所有的字符进行了收录，同样是变长编码 utf-8 1-4个字节存储字符 utf-16 2或4个字节存储字符 utf-32 全用4字节存 MySQL支持的字符集 utf8和utf-8mb4 utf8 utf8mb3的别名，依旧用1-3个字节存储字符 utf8mb3 是阉割版，用1-3个字节存储字符 utf8mb4 完整版，用1-4个字节存储字符 如果要存储更完整的数据的话就用这个，比如emoji表情 字符集的查看 使用SHOW CHARACTER SET命令，可以指定匹配的模式 比较规则的查看 使用SHOW COLLATION命令，可以指定匹配的模式 每种语言都有多个比较规则 还会有个默认的比较规则 比如utf8的默认比较规则就是utf8_general_ci ci是case insensitive 字符集和比较规则的应用 各级别的字符集和比较规则 字符集的级别分为 服务器级别 数据库级别 表级别 列级别 客户端和服务器通信中的字符集 客户端和服务器通信时需要进行字符集的转换 因为转换来转换去容易出错，所以一般通知设置为一样的字符集 比较规则的应用 如果发现按列排序后不是自己想要的顺序 就可以考虑下更改比较规则","link":"/2023/03/16/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"},{"title":"《MySQL是怎样运行的》笔记 第九章 InnoDB表空间详解","text":"简介表空间是一个抽象的概念，对应文件系统中一个或多个实际文件。每个独立表空间都对应一个 .ibd 文件。表空间由页组成，插入记录时是从表空间中拿出一个页来写入。本章会讲解表空间的细节。 9.1 回忆一些旧知识 页面类型： InnoDB 以页为单位管理存储空间。 数据页的类型名为 FIL_PAGE_INDEX。 页面通用部分： 所有页面都有两个通用部分：File Header 和 File Trailer。 File Header 记录页面相关信息，如页号、页类型、上一页、下一页、校验和等。 File Trailer 主要用于校验页面的完整性，防止断电导致页面更新不完整。 File Header的部分信息： FIL_PAGE_OFFSET：即页号，有4个字节，最多支持2^32个页，意味着表空间最多可支持64TB的数据。 FIL_PAGE_PREV 和 FIL_PAGE_NEXT：存储前后页号，形成双向链表，主要用于 INDEX 类型的页面。 FIL_PAGE_TYPE：页面类型。 9.2 独立表空间结构本节主要讲解系统表空间和独立表空间的结构。系统表空间较为复杂，因此先从系统表空间开始。 区 (Extent) 的概念： 简介： 为了更好地管理页，引入了区的概念。 每连续64个页组成一个区，一个区大小为1MB。 每256个区组成一组。 组的结构： 第一组的前三个页面是固定类型： FSP_HDR：记录该表空间的属性。 IBUF_BITMAP：存储 INSERT BUFFER 的信息。 INODE：记录段信息。 其余组的头结构： XDES：记录该组中所有区的属性。 IBUF_BITMAP：与前述相同。 段 (Segment) 的概念： 为什么引入区的概念： 如果只使用页进行分配，逻辑上相邻的两个页在物理存储上可能相隔较远，影响数据的顺序读取。 以区为单位分配空间，能将相邻的数据限制在一定范围内，提高读取效率。 叶子节点与非叶节点的区别对待： 叶子节点通常需要进行顺序读取，因此最好存放在不同的区内，避免影响读取性能。 一个索引生成两个段：一个用于叶子节点，一个用于非叶节点。 **碎片区 (Fragment)**： 对于数据较少的表，分配整个区会浪费空间，因此引入碎片区的概念。 碎片区的页面可以分配给不同的段。 段的空间分配步骤： 先以碎片区的页面为单位分配空间。 当已经使用了32个碎片区页面后，开始以整个区为单位分配。 区的分类： 表空间由若干个区组成，区分为四种类型： 空闲区。 有剩余空间的碎片区。 无剩余空间的碎片区。 附属于某个段的区。 XDES Entry：用于管理区的结构，每个区都有一个 XDES Entry，记录了区的属性。 包含 Segment ID（区所属段的编号）、链表节点、区状态（FREE, FREE_FRAG, FULL_FRAG, FSEG）、页面状态位图等。 XDES Entry链表： 插入数据时，InnoDB会维护三个链表： FREE链表：记录所有状态为FREE的XDES Entry。 FREE_FRAG链表：记录状态为FREE_FRAG的XDES Entry。 FULL_FRAG链表：记录状态为FULL_FRAG的XDES Entry。 段的结构： 段由零散的页面和多个区组成。 每个段对应一个 INODE Entry 结构，记录段的属性。 INODE Entry的结构： Segment ID：段的ID。 NOT_FULL_N_USED：记录 NOT_FULL 链表中已使用的页面数量。 List Base Node：三个链表的基节点。 Magic Number：标记INODE Entry是否已初始化。 Fragment Array Entry：记录碎片区使用的页面号。 各类型页面的详细情况： FSP_HDR 页面： 记录表空间的整体属性和区的 XDES Entry。 包含 List Base Node，用于存储 FREE、FREE_FRAG、FULL_FRAG 链表的基节点。 XDES 页面：记录该组中所有区的 XDES Entry。 INODE 页面：记录 INODE Entry，负责段的管理。 Segment Header的运用： 在 B+树索引的根节点 Page Header 中存有两个 Segment Header，分别指向叶子节点段和非叶子节点段的 INODE Entry。 真实表空间对应文件大小： 独立表空间对应数据库子目录下的 .ibd 文件，文件大小会随页面增多自动扩展。","link":"/2023/03/22/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B9%9D%E7%AB%A0%20InnoDB%E8%A1%A8%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3/"},{"title":"《MySQL是怎样运行的》笔记 第二十五章 锁","text":"解决并发事务带来问题的两种基本方式 并发事务带来的问题 大致分为三种： 读读 多个并发事务读取相同的数据，这种情况不会产生问题。 写写 简介： 多个并发事务对相同记录进行修改，会产生脏写问题，这是很严重的。 脏写在所有隔离级别下都不允许发生。 脏写的解决办法： 加锁，使多个事务对于同一记录的写操作排队执行。 加锁解锁的过程： 加锁： 创建一个锁结构，trx_id设置为当前事务的ID。 如果该记录已有其他锁，is_waiting设置为true，表示正在等待获取锁；否则is_waiting设置为false，表示成功获取锁。 解锁： 事务提交后，释放当前锁结构，并选择下一个等待该锁的锁结构，将is_waiting设置为false，唤醒对应事务的线程。 读写和写读 简介： 多个并发事务，一个读，一个写，会产生脏读、不可重复读、幻读的问题。 解决读写问题的两种方案： 方案一：使用MVCC MVCC可以解决幻读问题，因为写操作针对的是最新版本，而读操作读取的是旧版本，因此不会产生读写冲突。 方案二：读写操作都使用加锁 对于时效性要求高的场景，比如读取账户余额，希望每次读取到的都是最新版本的记录，这时需要对读、写操作都加锁。 加锁可以解决脏读和不可重复读问题，但对于幻读问题比较麻烦，因为没法对不存在的记录加锁。 解决脏读：对写操作加锁，事务提交后释放锁。 解决不可重复读：对读操作加锁，防止其他事务修改该记录。 一致性读（Consistent Reads/快照读） 使用MVCC进行读操作被称为一致性读或快照读。 在读提交和可重复读隔离级别下，执行普通SELECT语句时，系统进行快照读。 快照读不需要加锁，其他事务可以正常执行写操作。 锁定读（Locking Reads） 使用锁解决事务并发时，需要确保读-写、写-写操作互斥，而读-读操作不受影响。 两种锁： 共享锁（Shared Locks，简称S锁）：执行读操作之前，需要获取该记录的S锁。 独占锁（Exclusive Locks，简称X锁）：执行写操作之前，需要获取该记录的X锁。 共享锁和独占锁的兼容性： 如果先获得一条记录的S锁，可以继续获得该记录的S锁，但无法获得X锁。 如果先获得一条记录的X锁，则该记录的S锁和X锁都无法再获得。 总结：S锁与S锁兼容，S锁与X锁不兼容，X锁与X锁不兼容。 锁定读的语法： 读操作加S锁： SELECT ... LOCK IN SHARE MODE; 读操作加X锁： SELECT ... FOR UPDATE; 写操作 讲述了DELETE、UPDATE、INSERT操作如何加锁。 DELETE操作相当于获取X锁的锁定读。 UPDATE操作涉及到DELETE和INSERT。 INSERT操作不用显式加锁，但涉及到隐式锁。 多粒度锁 锁的粒度可以细至单条记录（行锁），也可以粗至整个表（表锁）。 意向锁（Intentional Lock） 表级锁除了S锁和X锁外，还包括意向锁。 意向S锁（IS锁）：表内存在行级S锁时，表级添加意向S锁。 意向X锁（IX锁）：表内存在行级X锁时，表级添加意向X锁。 使用意向锁可以快速判断表内是否有行级锁，避免遍历整表。 表级锁与行级锁的兼容性 表级锁与意向锁的兼容性其实就是行级锁与表级锁的兼容性。 MySQL中的行锁和表锁 不同存储引擎对于锁的支持有所不同，主要讨论InnoDB。 其他存储引擎中的锁 MyISAM、Memory、Merge等存储引擎不支持事务，但支持表级锁（S锁和X锁）。 加锁是为了防止不同会话之间产生影响，因此同一表通常只有一个会话能够进行写操作。 InnoDB中的锁 InnoDB支持表锁和行锁： 表级锁 表级S锁和X锁： DQL和DML操作不会加表级锁，只有DDL操作才会加表级锁，通常用的是元数据锁（Metadata Locks）。 意向锁（IS锁、IX锁）： 在给表中的记录加行锁时，InnoDB会自动给表添加意向锁。 AUTO-INC锁： 用于获取自增变量的锁。当多个事务同时往同一表插入数据时，为了避免生成相同的自增ID，系统会加锁获取自增值。 行级锁 行级锁也称为记录锁，InnoDB中的行级锁有多种类型： Record Locks： 最普通的行锁，锁住一行记录，分为S锁和X锁。 Gap Locks： 防止插入幻影记录，常用于可重复读隔离级别解决幻读问题。 如果对一条记录使用了Gap锁，不允许在该记录前的间隙插入数据，但该记录本身不被锁住。 可以对最大记录后的supremum施加Gap锁，防止插入。 Next-key Locks： 结合Record锁和Gap锁，既锁住一条记录，也防止在该记录前的间隙插入数据。 Insert Intention Locks： 表示有事务想在一个间隙插入记录，但该间隙已被Gap锁锁住。事务会先创建一个插入意向锁，并阻塞自己，等待Gap锁释放。 插入意向锁之间不会相互阻塞。 隐式锁： 当事务插入一条记录时，该记录不会立即被显式锁定，但如果其他事务访问这条未提交的记录，系统会自动创建隐式锁。 这种锁需要与事务ID（trx_id）配合使用，系统会通过trx_id来判断记录的创建事务状态。 InnoDB锁的内存结构 MySQL不会为每一条需要加锁的记录单独创建锁结构，而是将同一事务中多个记录的锁放在同一个锁结构中。 锁合并的条件： 锁属于同一个事务。 加锁的记录在同一个页面中。 加锁的类型相同。 等待状态相同。 具体的锁结构 锁结构包括事务信息、索引信息、表锁或行锁的信息以及锁的模式和类型等。 锁结构的最后有一堆比特位，用于映射页面中的不同用户记录，表示这些记录是否加了行锁。","link":"/2023/04/07/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%94%81/"},{"title":"《MySQL是怎样运行的》笔记 第二十四章 隔离级别与MVCC","text":"事前准备 创建一个表并插入数据，准备测试事务的隔离级别与MVCC机制。 事务隔离级别 数据库支持并发执行事务，但会产生一些问题，需要通过隔离性来解决。隔离性越高，并发性就越差。 事务并发执行遇到的问题 脏写 Dirty Write 一个事务修改了另一个未提交事务修改过的数据。如果第一个事务回滚了，就会导致第二个事务的数据更新失败。 脏读 Dirty Read 一个事务读取了另一个未提交事务修改过的数据。如果第二个事务回滚了，第一个事务读取到的就是不存在的数据。 不可重复读 Non Repeatable Read 在同一事务中，多次读取同一数据，读取结果不一致。 幻读 Phantom 在一个事务中，两次以同一查询条件查询数据，第二次查询时读取到了之前没有见过的记录，通常是有新记录插入。 SQL标准中的四种隔离级别 脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读（问题严重性递减） 四种隔离级别： 读未提交 读提交 可重复读 串行化 脏写问题在每一种隔离级别中都被解决。 MySQL支持的四种隔离级别 MySQL支持四种隔离级别，默认隔离级别为可重复读（MySQL的可重复读能够解决幻读）。 设置事务隔离级别的语法： SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level; 作用域： global：全局有效。 session：当前会话有效。 省略作用域：仅对下一条事务有效。 也可以通过启动参数更改默认隔离级别： --transaction-isolation=SERIALIZABLE MVCC原理 MVCC（Multi-Version Concurrency Control，多版本并发控制）用于处理并发访问，解决读写冲突问题。 版本链 版本链由undo日志组成的链表，每条undo日志都是该用户记录的一个旧版本，头节点是最新版本。 聚集索引中有两个隐藏字段： trx_id：每当事务修改记录时，会将事务的trx_id赋值给该记录。 roll_pointer：每当记录被修改，旧版本写入undo日志，通过roll_pointer找到旧版本。 undo日志也有trx_id和roll_pointer，组成链表，称为版本链。 ReadView ReadView用于判断版本链中哪个版本对当前事务可见。 主要包括四个内容： m_ids：系统中活跃的读写事务的id列表。 min_trx_id：m_ids中的最小值。 max_trx_id：系统将要分配给下一个事务的id。 creator_trx_id：创建该ReadView的事务的id。 ReadView判断版本可见性的步骤： 如果版本的trx_id与creator_trx_id相同，表示该事务在访问自己修改的记录，因此可见。 如果trx_id小于min_trx_id，表示生成该版本的事务已提交，因此可见。 如果trx_id大于max_trx_id，表示该版本由生成ReadView之后的事务创建，因此不可见。 如果trx_id在min_trx_id和max_trx_id之间，检查是否在m_ids列表中： 在m_ids中表示活跃事务，不可见。 不在m_ids中表示已提交事务，因此可见。 如果当前版本不可见，继续在版本链中找下一个版本。 读提交和可重复读生成ReadView的时机不同： 读提交：每次读取数据前生成ReadView。 可重复读：第一次读取数据时生成ReadView。 MVCC小结 MVCC在读提交和可重复读隔离级别下，通过生成ReadView来判断记录版本链中的版本是否可见。 删除用户记录时使用delete_mask，保留版本链支持MVCC。 关于Purge insert undo在事务提交后可以释放，但update undo由于支持MVCC不能立即删除。 delete mark操作仅是打标记而未实际删除，保留版本链支持MVCC。 当系统判断delete_mask标记的记录或update undo日志不会被访问后，使用purge线程删除它们。","link":"/2023/04/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/"},{"title":"《MySQL是怎样运行的》笔记 第五章 InnoDB数据页结构","text":"不同类型的页简介 页是InnoDB管理空间的基本单位 一个页的大小一般是16KB InnoDB中有多种页 存放Insert Buffer信息的页 存放INODE信息的页 存放undo信息的页 索引页INDEX 这个就是用来存放记录的页 也称为数据页 数据页结构的快速浏览 数据页被划分为多个部分 如图 总共分7个部分，简介如下： User Records 记录在页中的存储 简介 纪录会以我们指定的行格式存储在User Records中 一开始只有Free Space，没有User Records部分 每插入一条记录时，将Free Space中的一部分划入到User Records中 当FreeSpace用完时，就得申请新的page了 记录头信息详解 Compact行格式记录头信息如下 delete_mask 标记当前记录是否被删除 之所以不直接删除是删除完重排序开销大 被删除的记录会组成一个垃圾链表，链表中的记录 都是可重用空间 有新的记录的来的话，可以把被删除记录的空间覆盖掉 垃圾链表也通过next_record属性连接 min_rec_mask B+树每层非叶节点中 最小的记录，该标记为1 n_owned 表示该记录在槽中拥有多少条记录 heap_no 表示当前记录在该页面中的序号 但是是从2开始的 因为每个页里面有两个伪记录 infimum和supremum 分别作为最小记录和最大记录，heap_no为0和1 不存放在User Records里 record_type 表示记录类型，分别有四种 0 普通记录 1 B+树非叶节点记录 2 最小记录 3 最大记录 最小记录和最大记录的 record_type就为2和3 next_record 到下一条记录的真实数据的偏移地址 可以理解为指向下一条记录的指针 之所以指向的是记录头和真实数据之间的地址 是因为这样往左读就是记录头，往右读就是真实数据 这也是为什么变成字段长度列表和NULL值列表要逆序存储 整个就是一个链表结构 所以对记录做增删改操作就是对链表做增删改操作 该链表的顺序并不是插入顺序，而是按照主键排序的 最小记录指向最小的用户记录 最大的用户记录指向最大记录 为0时表示没有下一条记录 Page Directory 页目录 简介 页目录是用来加快对于记录的查询速度的 如果不用页目录的话，只能进行顺序查找，效率很低 用页目录的话 就可以把记录分为多个组 正常情况下，每个组中有4-8个记录 页目录 中存放每个组中最大记录的地址，每个地址都是一个槽 查找的时候就可以对槽进行二分查找，然后对槽内进行顺序查找 页目录的详细运作方式 将所有记录划分为几个组，包括最大记录和最小记录 最小记录单独为一组，包含最大记录的组含有1-8条记录，其余的组含有4-8条记录 插入或删除记录后，可能需要对分组进行合并或分裂，以满足条件 每个组的最大记录中有个n_owned字段，记录该组中有多少条记录 页目录中存放每个每组中最大元素的地址，也称为槽 查询流程 对页目录进行二分查找，找到目标记录所在的槽 通过上一个槽找到该槽中最小的记录 通过记录的 next_record 属性遍历找到目标记录 Page Header 页面头部 简介 Page Header 用于存储和记录相关的状态信息 比如当前存放了多少记录，有多少个槽等等 详细信息 File Header 文件头部 简介 负责存储和和页面相关的状态信息 比如页号，上一个页号、下一个页号、页面类型 图解 常用字段 FIL_PAGE_SPACE_CHKSUM 用于检测页面是否完整 FIL_PAGE_OFFSET 页号 可以用来定位一个页 FIL_PAGE_TYPE 页面类型 比如索引页就是FIL_PAGE_INDEX FIL_PAGE_PREV 上一个页面的页号 FIL_PAGE_NEXT 下一个页面的页号 页面本质上是通过双向链表连接起来的 索引页是有两个指针的，其他页就不一定了 File Trailer 文件结尾 作用 用于检测一个页是否完整 分为两部分 校验和 这个校验和应该与Page Header中的校验和相同 如果不相同就说明当前页面数据出错了 LSN 日志序列位置 也是用来校验页面完整性的","link":"/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"},{"title":"《MySQL是怎样运行的》笔记 第八章 数据目录","text":"8.1 数据库和文件系统的关系存储引擎是通过文件系统将数据存储在磁盘上的，数据写回时也依赖文件系统。 8.2 MySQL数据目录数据目录是数据库在文件系统中存储和加载数据的位置。 数据目录和安装目录的区别： 安装目录是数据库的安装路径。 数据目录用于存储数据库在运行过程中产生的数据。 如何确定MySQL中的数据目录： 数据目录对应一个系统变量 datadir。 执行查询语句即可获取数据目录位置。 8.3 数据目录的结构 简介： 数据目录包含用户创建的数据库、表、视图和触发器等用户数据，也包含一些额外数据。 数据库在文件系统中的表示： 每个数据库对应数据目录下的一个子目录。 新建数据库时，MySQL会在数据目录下创建与数据库同名的子目录，并生成一个 db.opt 文件，包含数据库的属性信息。 表在文件系统中的表示： 每个表的信息分为两部分： 表结构的定义。 表中的数据。 表结构的存储： 表结构包括字段数量、字段类型、约束条件、索引信息等。 每创建一个表，数据库子目录下会生成一个 .frm 文件，用于存储表结构信息。 InnoDB的存储方式： 表空间（Table Space）： 表空间对应文件系统上的一个或多个文件，被划分为多个页，用户记录存放在表空间下的某个页里。 系统表空间（System Table Space）： 可以对应多个文件，并可自增。 默认是数据目录下的 ibdata1 文件。 在 MySQL 5.5.7 到 MySQL 5.6.6 版本之间，所有表的数据都存储在系统表空间中。 独立表空间（File-Per-Table Tablespace）： 从 MySQL 5.5.6 开始，表的数据不再默认存储在系统表空间中，而是每个表拥有独立的表空间。 独立表空间下，每个表会在数据库子目录下生成一个 .ibd 文件，存储表数据和索引。 其他表空间类型： 通用表空间（General Tablespace）。 Undo 表空间（Undo Tablespace）。 临时表空间（Temporary Tablespace）。 MyISAM的存储方式： MyISAM 不使用表空间概念，所有表数据存储在数据库子目录下。 每个表在数据库子目录下生成三个文件： .frm：存储表结构。 .MYD：存储用户记录。 .MYI：存储索引。 视图在文件系统中的表示： 视图是虚拟表，存储时不保存实际数据，只存储视图的结构，即 .frm 文件。 其他文件： 数据目录下还包含一些额外文件： 服务器进程文件：MySQL 服务器会将自身进程ID写入该文件。 服务器日志文件：包括查询日志、错误日志、redo日志等。 证书和密钥：用于服务器和客户端的通信。 8.4 文件系统对数据库的影响MySQL 依赖文件系统存储数据，因此文件系统的限制会影响数据库的命名、表大小和性能。 数据库和表名长度：不允许超过文件系统的最大长度。 特殊字符问题：为避免字符冲突，所有非拉丁字母和数字的字符都会被替换为 @+编码。 文件大小限制：表大小受文件系统最大长度的限制。 8.5 MySQL系统数据库简介除了用户数据库外，MySQL 还包括几个系统数据库： mysql： 核心系统数据库，存储用户账户和权限信息、存储过程、事件信息和日志信息等。 information_schema： 存储所有其他数据库的元信息，如表、视图、触发器等。 performance_schema： 监控 MySQL 服务器性能，存储服务器状态信息。 sys： sys 结合了 information_schema 和 performance_schema，提供更便捷的视图来查看数据库信息。","link":"/2023/03/21/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"},{"title":"《MySQL是怎样运行的》笔记 第六章 B+树索引","text":"没有索引的查找 在没有索引的情况下，查找记录的操作如下： 在一个页中查找 假设记录数量较少，全部存储在一个数据页中。 有两种情况： 以主键为搜索条件： 先对页目录使用二分法找到对应的槽，然后遍历得到目标记录。 以其他字段为搜索条件： 只能遍历所有记录进行查找。 在多个页中查找 如果表中的记录存储在多个数据页中，查找分为两个步骤： 使用双向链表遍历每个数据页，因为页之间不是有序的。 在每个数据页中对记录进行查找。 问题： 没有索引时，需要遍历所有数据页才能找到目标记录。 使用索引的情况 一个简单的索引方案 通过以下步骤优化查找效率： 让所有数据页按主键有序排列。 为每个数据页建立目录，目录项存储数据页中最小记录的主键和页号。 通过二分法在目录中查找目标记录所在页，然后在该页中查找具体记录。 该目录即为索引。 InnoDB中的索引方案 InnoDB索引相比简单方案的改进： 不使用连续空间存储索引项，避免空间不足的问题。 目录项记录使用数据页存储，避免因增删数据而频繁移动索引项。 目录项记录： 目录项记录存储页号和该页中最小的主键值，record_type为1。 用户记录的record_type为0。 B+树的结构： InnoDB索引结构是一个B+树，每个节点是一个数据页。 非叶子节点存储目录项记录，叶子节点存储用户记录。 每层节点通过指针构成双向链表。 聚簇索引（聚集索引）： 特点： 聚簇索引也是B+树，基于主键排序。 聚簇索引叶子节点存放实际用户记录。 聚簇索引是自动创建的，反映了数据的存储方式。 二级索引（非聚集索引/辅助索引）： 特点： 需要额外创建，基于非主键字段进行排序。 叶子节点存储指定字段和记录的主键，查到结果后需通过主键查找聚簇索引获取完整记录。 联合索引： 特点： 基于多个字段进行排序。 本质上是二级索引，拿到主键后仍需查询聚簇索引。 InnoDB的B+树索引注意事项 根页面万年不动 索引创建时，先创建一个根页面。 根节点满后会分裂成两个页，原根节点从存储用户记录变为存储目录项记录，根节点始终不变。 非叶节点中目录项记录的唯一性 非聚集索引可能出现索引字段相同的情况，因此目录项记录增加主键字段确保唯一性。 一个数据页至少存储两条记录 B+树中的每个数据页至少存储两条记录。 MyISAM中的索引方案简单介绍 InnoDB：数据直接存储在聚簇索引的叶子节点中，数据即索引。 MyISAM：数据和索引分开存储，索引的叶子节点只存储记录的地址。 回表： InnoDB通过主键查询聚簇索引找到记录。 MyISAM通过地址直接定位到记录的位置。 MySQL中创建和删除索引的语句 注意点 InnoDB和MyISAM会自动为主键或声明为unique的字段创建B+树索引。 并非每个字段都创建索引，因为增加记录时需要调整所有索引，开销较大。 创建索引的语法 创建表时指定索引：INDEX和KEY是同义词。 修改表时可以创建或删除索引。 还可以添加联合索引。","link":"/2023/03/19/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20B+%E6%A0%91%E7%B4%A2%E5%BC%95/"},{"title":"《MySQL是怎样运行的》笔记 第十一章 连接的原理","text":"简介 MySQL中的连接 join，如果使用不好可能会导致慢查询，所以最好弄懂原理再去用。 连接简介 连接的本质 连接本质还是查询 就是把驱动表的记录，拿到被驱动表里找匹配的记录 所以加快查询的方法也可以用来加快连接，比如建立索引 连接过程中的过滤 简介 因为直接对多个表进行笛卡尔积的话，产生的结果非常多 因此需要在Where子句里添加过滤条件进行过滤 过滤条件分为两种 单表过滤条件 只涉及到一个表的字段 比如 t1.a &gt; 10 双表过滤条件 涉及到两个表的字段 比如 t1.a &gt; t2.a 带有过滤条件的连接过程 例子： SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; 'd'; 包含了3个过滤条件 大致执行过程： 先选择一个表作为驱动表，比如t1 然后使用单表过滤条件对其进行查询 得到符合条件的记录 对于我们得到的每一条记录 到第二个表（被驱动表）中通过双表过滤条件找到匹配的记录 并且使用被驱动表的单表过滤条件进行过滤 最后我们将所有得到的记录合在一起就得到了连接的结果 内连接和外连接 简介 内连接： 在一个表里有，但是在另一个表里匹配不到的记录，就不加入结果集 只写一个join就默认是内连接 外连接： 在一个表里有，但在另一个匹配不到的记录，也加入结果集 只不过没匹配到的字段用空值代替 外连接还可以细分为： 左外连接： SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件]; outer可以直接省略 左边作为驱动表|内表，右边作为被驱动表|外表 右外连接： SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件]; 左边作为被驱动表|外表，右边作为驱动表|内表 全外连接： 注意MySQL不提供全外连接 所以只能使用Union把左外连接和右外连接的结果取并集作为全外连接 Where子句 和 On子句： 共同点： where子句和on子句都可以用来指定连接时的过滤条件 不同点： 在内连接时，on子句和where子句是完全等价的 在外连接时，on子句会保留没有匹配到的记录，而where子句会过滤掉所有不匹配的记录 注意： 一般，只涉及到单表的过滤条件，放到where子句里，双表过滤条件放on子句里 放在on子句里的条件也叫连接条件 连接的原理 有的连接非常快，有的连接非常慢，下面讲讲原因 嵌套循环连接 Nested-Loop Join 简介： 这个就是我们之前讲的最普通的连接方法 先对驱动表进行过滤，得到结果 对于得到的每一条记录，到被驱动表中找到匹配的记录，并且执行响应的过滤条件 如果有第三个表，那就对前两个表的连接结果中每一条记录，到第三个表里找到匹配的记录 就像嵌套循环连接一样 特点： 驱动表只需要访问一次，被驱动表需要访问多次，具体次数取决于驱动表过滤后的记录数量 这是最简单，但是代价最大的表连接方式 使用索引加快连接 前面说到，驱动表会被访问一次，而被驱动表会被访问多次 因此我们可以给被驱动表的连接条件和过滤条件中涉及到的字段建立索引，能加快连接的速度 如果有多个可用索引，查询优化器也会自动选择代价最低的方案进行使用 注意别用select *，可能会导致index访问方法失效，也就是覆盖索引失效 基于块的嵌套循环连接 Block Nested-Loop Join 问题： 真实的生产环境中，一个表可能非常大，内存里没法一次全部放下，会一边加载一边释放 而在表连接时，被驱动表会被访问很多次。所以可能会导致被驱动表重复地加载到内存里来 解决办法： 所以需要想办法降低被驱动表访问的次数 本来驱动表里的每条记录都需要和被驱动表匹配一次，每匹配一次就需要加载一次被驱动表 解决办法就是让被驱动表一次和驱动表中的多条记录进行匹配 具体实现方法： 引入一个join buffer，join buffer里存储多条驱动表的记录 对被驱动表进行扫描时，我们让其跟join buffer里的每一条记录都进行匹配 以此降低被驱动表的访问次数 注意点： 最好的情况就是join buffer一次能容纳所有的驱动表记录 join buffer的大小可以自己设置 join buffer里只会放查询字段和过滤条件中的字段 所以没事别用*作为查询列表，也就是别用select * 不过最好的方法还是给被驱动表加上索引，其次再考虑join buffer","link":"/2023/04/04/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/"},{"title":"《MySQL是怎样运行的》笔记 第十九章 事务简介","text":"事务的起源 事务就是一组对于数据存储操作的集合。比如转账就包括给一个账户扣钱，再给另一个账户增加钱。 事务的四大特性： 原子性 事务中的操作，要么全部执行，要么全部不执行，也就是回滚。 隔离性 多个事务同时执行时，不能相互产生影响。 一致性 数据库中的数据需要满足一致性。 例如转账操作，转账前后所有账户的总金额应保持不变。 一致性可以通过触发器实现。 持久性 事务的执行结果应该被永久保留。 例如InnoDB通过redo log实现持久性。 事务的概念 定义 事务就是一组数据库操作。 事务的5个状态 active 正在执行。 partially committed 完成了所有操作，但是更改还没有刷回外存。 failed 如果在active或partially committed状态时遇到错误，就会进入failed状态。 aborted 当事务处于failed状态时，需要进行回滚，回滚后为aborted状态。 committed 事务成功执行，且更改同步到外存。 MySQL中事务的语法 事务的操作不是存储过程，而是将接下来进行的所有操作纳入一个事务中。 开启事务 使用BEGIN;或START TRANSACTION;开启事务，表示后续操作都属于该事务。 START TRANSACTION;可以带有修饰符： READ ONLY：表示该事务为只读。 READ WRITE：表示该事务为读写事务（默认）。 WITH CONSISTENT SNAPSHOT：启动一致性读。 提交事务 使用COMMIT;提交事务。 手动回滚事务 如果发现已提交的语句有误，可以调用ROLLBACK;手动回滚。事务出错时也会自动回滚。 支持事务的存储引擎 只有InnoDB和NDB支持事务。 如果对不支持事务的表进行了修改，回滚操作无效。 自动提交 系统变量autocommit默认值为ON，表示每条语句都作为一个独立事务执行。 关闭自动提交的两种方式： 显式执行BEGIN;或START TRANSACTION;。 设置autocommit为OFF。 关闭autocommit后，只有调用COMMIT;才能提交事务。 隐式提交 某些语句会导致隐式提交当前事务，包括： 数据定义语言（DDL）操作。 修改mysql系统数据库中的表。 事务控制或锁定语句。 数据导入语句。 MySQL主从复制操作。 保存点 ROLLBACK;会回滚所有内容，而有时我们只想回滚部分内容，因此可以使用保存点。 创建保存点：SAVEPOINT 保存点名称; 回滚到保存点：ROLLBACK TO 保存点名称; 删除保存点：RELEASE SAVEPOINT 保存点名称;","link":"/2023/04/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/"},{"title":"《MySQL是怎样运行的》笔记 第十二章 MySQL基于成本的优化","text":"什么是成本 同一查询会有多个执行方案，MySQL会自动选择成本最低的方案去进行查询。 成本主要由两个方面组成： IO成本 当我们想查询数据时，需要先把数据从磁盘里加载到内存里之后才可以查询。 从外存加载到内存的时间损耗就可以称为IO成本。 CPU成本 检测记录是否满足查询条件、对结果集进行排序等等，就称为CPU成本。 读取一个页面的成本是1.0，读取和检测一条记录是否满足查询条件的成本是0.2，这些数字叫成本常数。 对一条记录光读取不匹配的成本也是0.2。 单表查询成本 准备工作 创建一个表。 基于成本的优化步骤 简介 流程简介： 在执行一条单表查询条件时，查询优化器会找出可行的执行方案。 然后比对所有执行方案的代价。 选择代价最低的执行方案进行执行。 更具体的流程： 根据搜索条件，找出所有可用的索引。 然后计算全表扫描的代价。 计算使用不同索引执行查询的代价。 选择代价最低的执行计划进行查询。 查询语句如下： 先分析可用的索引 possible keys： 发现possible keys 只有 idx_key1 和 idx_key2。 计算全表扫描的代价： 查询成本=IO成本+CPU成本，所以计算全表扫描的代价主要看两个部分： 聚集索引占用的页面数量。 表中的记录总数。 这些信息可以通过表的统计数据获取： 使用 SHOW TABLE STATUS LIKE 'single_table'。 这些信息由MySQL负责收集。 我们主要看Rows和Data_Length： Rows： 本选项表示表中的记录条数。对于使用 MyISAM 存储引擎的表来说，该值是准确的，对于使用 InnoDB 存储引擎的表来说，该值是一个估计值。 Data_length： 表示表占用的存储空间字节数。使用 MyISAM 存储引擎的表来说，该值就是数据文件的大小，对于使用 InnoDB 存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小。 所以聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97。 最后的成本： IO成本： 97 x 1.0 + 1.1 = 98.1。 CPU成本： 9693 x 0.2 + 1.0 = 1939.6。 计算使用不同索引的代价： 需要计算每个索引单独查询的代价，如果满足条件的话，还需要计算索引合并的代价。 idx_key2索引的成本分析： 查询条件为 key2 &gt; 10 AND key2 &lt; 1000。 计算范围区间数量： 查询优化器认为一个范围区间算作一个页面。 这里就只有一个范围区间，所以算作一个页面。 计算需要回表的记录数量： 先在索引里定位的区间的两个端点。 然后估算这两条记录中间夹了多少条记录。 估算方式是找它们父节点中的目录项记录。 读取二级索引记录算入CPU成本。 进行回表： 每次回表都认为访问了一个页面，算入IO成本。 每次回表时，对聚集索引记录的读取和匹配也会计入CPU成本。 总代价： IO成本： 范围区间数量+符合条件的二级索引记录数量。 CPU成本： 读取二级索引的成本+回表读取聚集索引的成本。 idx_key1的成本分析： 搜索条件： key1 IN (‘a’, ‘b’, ‘c’)。 认为是产生了三个单点区间。 计算范围区间数量： 这里有三个范围区间。 认为访问了三个页面。 计算回表记录数量： 对每个单点区间进行匹配，找到总记录数就行。 判断是否可以进行索引合并： 这里用到了非主键范围匹配，所以不满足索引合并的条件。 况且索引合并的成本计算比较麻烦，这里就不讲了。 找到成本最小的执行方案： 所以这里选择 idx_key2 进行查询。 基于索引统计数据的成本计算 Show Index index dive： 指的是通过访问索引来计算一个范围区间内有多少条记录。 带来的问题： 正常情况下是可以通过index dive来计算记录条数的。 但是如果IN子句里参数非常多，导致出现了很多的单点范围区间，比如几百个： 会有一个叫index_dive_limit的系统变量，就是看有没有超过这个值。 这时候就不会再通过index dive的方式计算单点区间中记录的数量。 通过索引统计数据估计记录数量： show index from 索引名： 可以展示一个索引的统计情况。 我们主要看cardinality字段，也就是基数。 基数表示该索引字段中不重复的值的数量。 通过 show table status 命令获取 rows 字段： rows表示总共有多少条记录。 rows/cardinality就可以得到平均一个值重复多少次。 所以 符合条件的记录数量 = 单点区间数量 * 平均重复次数。 比index dive方便多了，但是不精确。 连接查询的成本 准备工作： 假设有两个表，和上面的一样，一个叫s1，一个叫s2。 Condition Filtering 介绍： 因为MySQL中连接查询采用的是嵌套循环连接算法，所以查询成本分为两个部分： 单次查询驱动表的成本。 多次查询被驱动表的成本(具体查询次数取决于驱动表查询的结果集中有多少条记录)。 fanout 扇出值： 扇出值指的是对驱动表使用单表过滤条件进行过滤后得到记录的数量。 fanout越小，查询被驱动表的次数越少。 fanout有时候可以通过索引计算出来准确的值。 如果有的过滤条件没法使用索引，那么就只能猜fanout的值，因为查询优化器不会去真正执行查询。 对fanout进行猜的过程就叫做Condition Filtering。 两表连接的成本分析： 连接查询的成本组成如下： 连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数(fanout) x 单次访问被驱动表的成本。 注意： 对于左连接或右连接： 驱动表是固定的。 所以只需要找到驱动表和被驱动表成本最低的查询方案就行了。 对于内连接： 驱动表和被驱动表是可以互换的。 需要考虑不同连接顺序的查询成本。 选择成本最低的连接顺序。 例子： 这是内连接，有两种连接方式，s1为驱动表或s2为驱动表。 我们主要以s2为驱动表举例，并且定性分析，而不是定量分析。 s2为驱动表的情况： 计算驱动表的查询成本 s2： 过滤条件为 s2.key2 &gt;1000 and s2.key2 &lt;2000。 可以看到驱动表可选的执行方案有全表扫描和使用key2的索引。 这里范围匹配走索引肯定更快，满足range访问方法。 计算被驱动表的查询成本 s1： 过滤条件为： s1.key1 = 常数。 s1.key2 &gt; 1000 AND s1.key2 &lt; 2000。 因为对于key1的等值匹配，我们不知道具体的值，所以没法用index dive确定记录数量。 因此可以用索引统计数据 cardinality 进行估算，也就是平均重复次数。 可用的执行方法： 全表扫描 all访问方法。 idx_key1 ref访问方法。 idx_key2 range访问方法。 一般情况下，ref优于range方法，所以这里选idx_key1。 最后的总成本为： 使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本。 不过还需要和另一个连接顺序的成本作比较。 两表连接如何优化： 可以看到两表连接的成本主要在驱动表的fanout和被驱动表的访问成本上。 一个是降低驱动表的fanout。 一个是降低被驱动表的单次访问成本： 可以给连接字段建立索引，能达到 ref访问方法。 如果使用主键或唯一二级索引，能达到 const访问方法。 多表连接成本分析 前面说计算连接查询的成本时，会把每种连接顺序的成本都计算一次。 但如果有n个表，那就有n的阶乘个连接顺序。 因此有下面几种优化方法： 提前结束一个顺序的成本计算： 会维护一个当前最小连接查询成本。 如果计算某个顺序时，发现成本已经超过了，就不继续往下计算了。 **设置阈值 系统变量 optimizer_search_depth**： 如果连接表的个数没超过阈值，就穷举所有连接顺序。 如果超过阈值，就只对和阈值相同数量的表进行穷举。 使用特定规则进行过滤： 当表的连接顺序满足某种规则时，直接不考虑。 这些规则通过经验得到。 调节成本常数 我们之前提到，读取一个页面的成本常数是1.0，读取并匹配一条记录的成本常数是0.2。 其实还有很多其他的成本常数。 并且分为两层：server层，存储引擎层。 server 负责连接管理、查询缓存、语法解析和连接优化。 engine 负责对于数据的存储和访问。 和这两层相关的存储常数分别放在 mysql.server_cost 和 mysql.engine_cost 里。 还可以自己手动更改，但我这里不细讲了。","link":"/2023/04/05/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/"},{"title":"《MySQL是怎样运行的》笔记 第十五章 Explain详解","text":"简介 MySQL在进行基于规则的优化和基于成本的优化之后，会生成最终的执行计划。 执行计划记录了最终执行查询的步骤，比如多表连接的顺序，每个表采用什么访问方法等。 使用EXPLAIN关键字可以查看一个查询语句的具体执行计划。 执行计划中的各列详解 table 不管查询语句多么复杂，最后都是单表访问。 所以执行计划中的每一条记录都对应一个单表，记录了对于该单表怎么执行（如访问方法const、ref、range等）。 这些记录的顺序就是表的连接顺序。 table指的是该条记录对应的表名。 id id是SELECT关键字的id。 每使用一个SELECT关键字，就会分配一个id。 进行连接查询的表拥有同一个id。 子查询则会使用另一个id。 如果子查询被转换为连接查询，也会拥有相同的id。 id为NULL表示这是一个临时表。 select_type 每个SELECT语句代表一个小查询，会被分配一个id。 select_type表示这个SELECT关键字对应的小查询的类型。 常见的select_type： simple：表示查询不包括子查询或UNION操作，常见于单表查询和连接查询。 primary：表示该查询是一个大查询，由几个小查询组成。使用了UNION或子查询的查询就是primary。 union：用于UNION查询，第一个小查询的类型是primary，其余的小查询类型是union。 union result：表示该表是一个用于UNION的临时表，并且这表没有id。 subquery：表示该查询是未转换为半连接的不相关子查询，并使用物化方式执行。 dependent subquery：表示这是未转换为半连接的相关子查询，会执行多遍。 dependent union：子查询中的UNION查询，依赖于外层查询。 drived：表示用物化表的方式执行派生表查询。 materialized：子查询物化后与外层查询进行连接查询。 partitions 跟分区相关，通常为NULL。 type 表示查询该表时使用的访问方法，如system、const、eq_ref、ref、index_merge、range、index、all等。 访问方法按效率从高到低排列：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。 详细解释： system：表中只有一条记录，用MyISAM或Memory存储引擎，表的统计信息是精确的。 const：单表查询时，对主键或唯一二级索引字段进行常数等值匹配。 eq_ref：连接查询时，对被驱动表的主键或唯一二级索引字段进行常数等值匹配。 ref：对普通二级索引字段进行常量等值匹配。 index_merge：索引合并，多个索引同时使用。 range：单表查询时使用范围查询。 index：使用覆盖索引，对二级索引进行扫描，不回表。 all：对聚集索引进行全表扫描。 possible_keys和key possible_keys表示可以使用的索引，key表示实际使用的索引。 注意：possible_keys并不是越多越好，可用索引越多，查询优化器就需要为更多的执行方案计算成本。 key_len 表示使用的索引字段的最大长度，主要功能是让我们知道使用联合索引时用到了几个字段。 ref ref表示对索引列进行等值匹配时，匹配的是什么类型。 rows 表示预计扫描的行数。 filtered 与condition filtering相关，用于计算fanout。 filtered是一个百分比，用于估计扫描到的记录中有多少记录符合条件。 执行计划中剩下的字段 Extra 提供一些额外的提示信息，如： no tables used：FROM子句为空。 impossible where：WHERE子句为永假式。 JSON格式的执行计划 使用FORMAT=JSON，可以将执行计划通过JSON格式输出。 show warnings 执行完EXPLAIN后，再调用SHOW WARNINGS，就可以看到查询优化器重写后的查询语句。","link":"/2023/04/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20Explain%E8%AF%A6%E8%A7%A3/"},{"title":"《MySQL是怎样运行的》笔记 第十四章 MySQL基于规则的优化","text":"简介 查询优化器除了会根据查询成本进行优化之外，还会使用特定规则查询语句进行重写，优化查询性能。 条件化简 条件化简会对查询语句进行简化： 移除不必要的括号。 常量传递 当查询条件使用AND连接时，可以将 a = 5 AND b &gt; a 替换为 a = 5 AND b &gt; 5。 等值传递 a = b AND b = c AND c = 5 替换为 a = 5 AND b = 5 AND c = 5。 移除没用的条件 移除永真或者永假的表达式。 表达式计算 对只包含常量的表达式进行提前计算，a = 5 + 1 替换为 a = 6。 注意不会对涉及字段的表达式进行化简，所以不要对索引字段使用表达式或函数。 HAVING子句和WHERE子句合并 如果查询语句里没有聚集函数以及GROUP BY子句，就把HAVING子句和WHERE子句合并起来。 常量表检测 满足常量表查询有两种条件： 查询的表中没有记录，或者只有一条记录。 使用const访问方法进行查询（对主键或者唯一二级索引进行等值匹配）。 当查询优化器发现可以执行常量表查询时，就会跳过查询成本分析，直接查询。 然后把涉及到该表的查询条件全部替换为常数。 最后再分析剩下的表的查询成本。 外连接消除 因为内连接可以交换连接顺序，有更多执行方案，所以比起外连接有更多优化空间。 可以在进行外连接时，在WHERE子句里指定被驱动表的字段不为NULL，这种方法叫做空值拒绝。 相当于把外连接转换为内连接，查询优化器也可以交换连接顺序了。 子查询优化 子查询语法 子查询可以出现在所有子句里，一般出现在FROM和WHERE子句里。 子查询的类型 按照结果集分： 标量子查询：子查询只返回一个单一的值。 行子查询：一行多列。 列子查询：一列多行，可以用于IN子句的参数。 表子查询：多列多行。 按照与外层查询的关系来分： 不相关子查询：子查询不依赖于外层查询的值。 相关子查询：子查询依赖于外层查询的值。 子查询在表达式中的使用 对子查询使用逻辑运算符，如[NOT] IN子查询、ANY/SOME/ALL子查询、[NOT] EXISTS子查询。 子查询语法注意事项 子查询必须用小括号括起来。 SELECT子句中的子查询必须是标量子查询。 可以用LIMIT 1限制记录数量，来得到标量子查询或行子查询。 对于[NOT] IN/ANY/SOME/ALL子查询来说，子查询中不允许有LIMIT语句。 不允许在增删改的同时进行子查询。 子查询在MySQL中的优化 标量子查询、行子查询的执行过程 对于不相关的标量子查询、行子查询，MySQL会分别执行子查询和外层查询，相当于两个单表查询。 对于相关的标量子查询、行子查询，MySQL会从外层查询中获取记录，放到子查询中执行，然后再判断外层查询的WHERE子句是否成立。 IN子查询优化 物化表的引入： 对于结果集少的不相关IN子查询，直接把IN子句中的参数一个个拿到表里精确查找或范围查找。 对于结果集特别大的IN子查询，引入物化表，将子查询的结果集存入临时表里，并且进行去重。 使用物化表后，MySQL会把IN子查询转换为内连接，查询优化器会计算两种连接方式的成本，然后选择成本最低的方式执行。 IN子查询转半连接： 半连接不和内连接等价。 半连接的实现方式有Table pullout、DuplicateWeedout、LooseScan、Materialization和FirstMatch等。 ANY/ALL子查询优化 需要搭配布尔表达式然后才能转换。 比如：&lt; ANY子查询就是小于子查询的MAX值。 [NOT] EXISTS子查询的执行 对于不相关的EXISTS子查询，先执行子查询，然后外层查询。 对于相关的EXISTS子查询，可以用索引加速，但优化空间有限。 派生表的物化 放在FROM子句里的子查询可以当作一个派生表。 派生表有两种执行策略：物化派生表和消除派生表，优先消除派生表，因为可以省去物化表的成本。","link":"/2023/04/05/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96/"},{"title":"《MySQL是怎样运行的》笔记 第四章 InnoDB记录结构","text":"准备工作 不同存储引擎对于数据的存储格式都是不同的 这本书主要讲的是InnoDB的格式 InnoDB页简介 InnoDB会把数据划分为多个页 以页作为磁盘和内存之间交互的基本单位 页的大小一般为16KB 一次至少读取16KB内容的数据到内存 同样的，一次最少刷新16KB的数据到磁盘 InnoDB行格式 简介 我们以记录为单位往表中存储数据 每一条记录在磁盘上的存储方式就被称为 行格式 或者 记录格式 InnoDB有四种不同的行格式 Compact Redundant Dynamic Compressed 指定行格式的语法 CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称 ALTER TABLE 表名 ROW_FORMAT=行格式名称 Compact行格式 结构 记录的额外的信息 也就是为了描述记录不得不添加的记录 变长字段长度列表 因为有些字段是变长的，所以我们除了记录实际的数据之外，还需要记录每个变长数据占用的字节数 所以在Compact行格式中，会把每个变长字段数据的字节数按照逆序存放 每个变成字段数据占用的字节数用一个字节或两个字节存，取决于字符集和变长字段的最长长度 注意 当变长字段数据为null时，不存储它的长度 NULL值列表 用来标记哪些字段的值为null 每个字段用一个bit来标记，也是逆序，为1时表示该值为null 如果每个字段都不允许为null，那就不记录数据 记录头信息 记录一些额外信息，比如 删除标记 记录类型 下一条记录的相对位置 之后会详细讲 记录的真实数据 除了实际的字段值之外，还会存储一些隐藏字段，比如 行ID 在没有主键，没有unique键的情况下 才会自动生成row id 事务ID 回滚指针 Redundant行格式 示意图 简介 这个过时了，看看就行 字段长度偏移表记录每个字段的结束地址 需要用相邻的偏移量相减才能知道该字段的长度 记录头信息和Compact差不多，有些许的不同 偏移量会有一个null比特位，标记该字段是否为null 行溢出数据的情况 varchar(M)最多能存储的数据 mysql中对于varchar类型，最多可以占用65535个字节 对于BLOB和TEXT类型倒没要求 其中M表示最多可以存储的字符数量 因为总体字节数有限制，所以M的大小取决于用的字符集占用几个字节 其实是因为mysql对于一条记录的大小限制为65535个字节 包括了除了真实数据之外的额外记录数据，比如变长字段长度列表和NULL列表 记录中的数据太多产生的行溢出 因为数据库中的数据是以页为单位存储的，16KB，而varchar最多能存64KB的数据 所以当一个字段数据太多时，会只存一部分，以及一个指向其它页的指针，指针指向的页存放剩余的部分，也叫溢出页(这是Compact和Redundant行格式处理溢出的方法) 行溢出的临界点 一条记录中的所有数据以及额外记录信息 超过16KB时就会发生行溢出 不需要知道具体的临界点，只需要知道当存储数据很大时就可能发生溢出就行了 Dynamic和Compressed行格式 MySQL5.7默认使用的行格式就是Dynamic 这两种行格式和Compact的区别只在于对于行溢出的处理 Dynamic和Compressed都会把产生行溢出的字段的全部真实数据放在其他页上，只在记录中存放指针 Compressed会在Dynamic基础上对页面进行压缩，节省空间","link":"/2023/03/17/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/"},{"title":"《人月神话 The Mythical Man-Month》笔记","text":"一、书名和作者 书名： 人月神话 The Mythical Man-Month 作者： Fred Brooks 二、书籍概览 主要论点和结构 本书主要探讨了软件工程中是否有银弹的问题。作者认为缺乏合理的时间进度是造成项目滞后的最主要原因，比其他所有因素加起来影响还大。同时，人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的，但是往进度落后的项目中增加新的人手只会让进度更加落后。 目标读者和应用场景 本书适合所有软件工程师、项目经理、软件开发者、软件工程专业学生等正在或者将要从事软件开发的人员阅读。 三、核心观点与主题1. 主题一 焦油坑 子观点1 在过去几十年的大型系统开发中，只有极少数的项目满足了目标、进度和预算的需求。 实例或案例 表面上看起来，项目中每一个单独的问题都是容易解决的，但是当他们累积在一起的时候，团队的行动就会变得越来越慢。 2. 主题二 人月神话 子观点1 缺乏合理的进度安排是导致项目进度滞后的主要原因。 子观点2 使用人月作为衡量一项工作的规模是一个危险的带有欺骗性的神话。 子观点3 向落后的项目中增加人手，只会使进度更加落后。 子观点4 在程序员群体中，乐观主义过于弥漫。 实例或案例 之所以缺乏合理的进度安排是导致项目进度滞后，主要原因是人们认为人和月是可以相互替换的。 使用人月作为衡量一项工作的规模是一个危险的带有欺骗性的神话。也是因为它暗示了人员数量和时间是可以相互替换的。但是人数和时间可以相互替换仅仅适用于工作人员之间不需要相互交流的情况。但是这在系统编程中是不可能的。增加更多的人手不一定会缩短时间进度，反而会延长时间进度。 因为新加入的人手需要经过一段时间的培训，并且会使之前的很多工作失效，反而增加了很多额外的工作量。主要就是因为人员之间的交流是有成本的。 3. 主题三 外科手术队伍 子观点1 大型项目的每一个部分都应该由一个团队解决，不过该团队应该以类似外科手术般的方式组建。 实例或案例 小型精干队伍效率很高，但是开发大型系统需要数十年的时间，人数不够用。但是大量的人手需要相互交流，开发效率又不会很高。 因此Mills建议大型项目的每一个部分都应该由一个团队解决，但是该团队应该以类似外科手术般的方式组建。 如果要将外科手术团队的概念应用到几百人的队伍上。解决办法就是让原来1/7或者更少的人去决定软件的设计，而不是让所有人去参与讨论和交流。以此来降低交流的成本，提高效率。并且需要有一个系统结构师负责从上往下进行所有设计。 4. 主题四 贵族专制、民主政治和系统设计 子观点1 在系统的设计中，概念完整性应该是最重要的考虑因素。 子观点2 设计方法和体系结构方面的工作与具体实现相分离是获得概念完整性的强有力的方法。 实例或案例 软件的目的是使计算机更加容易使用，也就是说软件需要追求易用性。而简洁和直白来自概念的完整性，每个部分必须反映相同的原理需求的一致平衡。在语法上，每个部分应使用相同的技巧。因此易用性实际上需要设计的一致性和概念上的完整性。 概念的完整性要求设计必须由一个人或者非常少数的人员来实现。但是进度的压力要求很多人员来开发系统。因此体系结构同实现必须仔细地区分开。 5. 主题五 没有银弹 子观点1 没有任何一种单纯的技术或管理上的进步，能够独立地承诺在十年内大幅度地提高生产率、可靠性和简洁性。 实例或案例 所有软件活动包括根本任务和次要任务，根本任务为打造构成抽象软件实体的复杂概念结构，次要任务为使用编程语言表达这些抽象实体，在空间和时间限制内将他们映射为机器语言。但除非全部次要任务的时间缩减到零，不然不会带来生产率数量级上的提高。 并不是因为软件发展得太慢，而是因为计算机硬件发展得太快。作者认为软件开发中困难的部分是规格说明、设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。 所以，当我们面对软件开发的复杂性时，我们必须接受一个事实：软件开发本质上就是一项困难的工作。我们可以通过改进技术和管理策略来缓解这些困难，但是无法完全消除。 四、亮点与启发 最有影响的观点或实例 本书中最有影响力的观点之一是“人月神话”，即人员数量和时间可以相互替换。作者认为这是一个危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。实际上，增加人员数量并不能缩短项目时间表。相反，它会增加沟通和协调方面的工作量，并可能导致进度延误。 另一个我觉得有意思的观点是软件开发过程中的大部分决策应该由尽可能少的人做出。因为让整个开发团队都参与决策的制定会大大地增加交流的成本，因此在团队中，“仁慈”的专制是有必要的。 对个人或专业发展的启示 没有银弹说明在未来几十年时间内，不会有让开发效率提升几个数量级的工具的出现。软件开发过程中更多的难题还是在于对现实问题的解决方案进行建模。因此没必要焦虑以后被更先进的生产力工具所替代。而更应该专注于对核心技术的学习，构建自己的技术壁垒。 五、批评与局限性 任何有争议、模糊或过时的信息 对于银弹是否存在其实是有很多争议的，以至于作者重新写了一章来讨论银弹是否存在的问题。 可能的不足或缺陷 比起日益发展的技术，人月神话讲的更多的是开发大型项目时，对于团队管理需要考虑的问题，这些问题是确实存在的，不可忽视。但是书中并没有给出非常具体的解决办法，而且有的书中提及的有些工具已经过时了，现在有效率更高更有效的替代工具。 六、实际应用和拓展 在实际工作/学习中如何应用这些概念 在小组作业或者多人合作项目中，最好不要民主地让每个人都去参与决策的制定，因为这会增加很多交流的成本，导致工作一直被延迟。比较好的做法是选出一个负责人，负责对每一个决策进行定夺。同时也不能扼杀每个小组成员的创意性，得听取每个成员的意见。 此外往小组中增加更多的人手也不一定会增加项目完成的效率，因为这同样会增加小组内完成任务时交流的成本。 七、总结与评价 对书籍的整体评价 很经典，具有启发性，书中的一些观点在本科阶段上课时经常会听到。读了原著后对那些观点有了更深的理解。 书籍的长处和短处 书中使用了很多的比喻和例子去论证作者的观点。但可能因为年代久远或者翻译不够接地气，读起来很困难，很多地方要慢慢读才能看懂。","link":"/2023/10/09/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%20The%20Mythical%20Man-Month%E3%80%8B%E7%AC%94%E8%AE%B0/"},{"title":"《原子习惯 Atomic Habits》第一章&amp;第二章 笔记","text":"一、原子习惯的力量小习惯大作用日常习惯产生的微小改变很重要。 成功是日常习惯产生的结果，而不是千载难逢的转变。 同时，你目前的成功与否无关紧要，重要的是你目前的习惯是否正在把你推向成功。需要更注重于当前的过程，而不是已经拥有的结果。 习惯的正面积累和负面积累正面积累： 生产力 -每天多完成一点额外工作会给你更多的余裕 知识 人际关系 -对别人更好一点会更容易得到帮助 负面积累： 压力 负面想法 愤怒 进步的真正过程努力的结果在一开始可能不会显现出来，只有超过了阈值时才会发生巨大变化。造成巨大变化是持久的努力而不是最后一击。所以别看不到什么起色就放弃了。 忘记目标，专注过程设立一个目标虽然可以指明方向，但是目标最终能不能完成可能和设立目标关系不大。 因为设立完目标后，需要规划怎么努力。如果不注重目标，但依旧努力，依旧可能会达成目标。 当花太多时间研究目标的话，会产生下面的问题： 赢家和输家拥有相同的目标 -设立远大目标就能成功只是幸存者偏差 达成目标只是一个短暂的改变 -专注过程，结果会自然变得更好，而不是只关注结果 目标限制了你的快乐 -不要把快乐推迟到成功之后，也不要觉得失败了就该难受，学会享受过程 目标限制了你的长期进步 -唯目标心态会导致完成目标后就开始摆烂，没有动力再推动自己前进，甚至坏习惯复发 原子习惯的系统原子习惯指的是一个微小的改变、一份边际效应和每天进步一点点。他们的特点是微小并且容易，属于系统的一部分，但是最终会积累成巨大能量 章节总结 习惯是自我提升的复利，每天进步一点点，日积月累一大步 习惯是双刃剑，因为分为好习惯和坏习惯 小的改变一开始不会产生影响，最终才会得到巨大收获，需要保持耐心。 原子习惯是庞大系统的一部分 如果想要好的结果，专注系统，忘记设立目标 成功无关目标，失败源于系统 二、习惯如何塑造你的个性(反之亦然)习惯的改变分为三个层面： Outcomes -What you get Process -What you do Identity -What you believe “我在戒烟” -这个是Outcome层的；”我不抽烟” -这个是Identity层的。 只有将习惯融入自己的个性，并且对自己的习惯感到自豪，才能培养长久的习惯。 成为一个读者，而不是旨在读完一本书 成为一个跑者，而不是旨在跑完马拉松 成为一个音乐家，而不是旨在学一门乐器 当你的行为和个性高度一致时，你就不是在强迫自己保持习惯，而是acting like the type of person you already believe yourself to be. 反之亦然，你觉得自己不聪明，那你就会变得不聪明；你觉得自己就是懒，那你就无法早起。 不要觉得自己的个性是天生的不可改变的，如果你想提升自己，你需要不断地调整自己的Identity。 改变个性/内在的两个步骤改变自己的行为就是改变自己的个性。 改变内在分为两个步骤 弄清楚你想成为什么样的人 通过一点点的提升证明自己 举个例子，如果你想薪水翻倍，就去想想高薪水的人都是什么样的。比如高薪的人乐于学习并且自律，然后就研究自己如何成为一个乐于学习且自律的人，而不是总想着我要赚钱。 当你弄清楚了自己想成为什么样的人，就可以养成各种习惯去强化这个Identity。 比如早上起床的时候就可以想“公司总裁会不会睡懒觉？”；想暴饮暴食的时候就想“健康自律的人会不会暴饮暴食？”。 如果你总是表现得像一个自律的人，那么你最后就会成为一个自律的人。 行为和内在之间存在双向影响，我们最好用自己的意念去驱使这个循环，而不是让结果来驱使。 着重关注自己想成为什么样的人，而不是一个特定的结果 习惯重要的真正原因习惯帮助你成为你想要成为的人，他们是改变你最深层内在的途径。 章节总结 改变分为三个层面：Outcome, Process, Identity 最有效的改变习惯的方法是关注自己想成为什么样的人，而不是想获得什么 成为最好版本的自己需要不断地调整自己的信仰和内在 习惯之所以重要，不是因为他们给你带来了好的结果，而是改变了你的内在 我想成为什么样的人自律的人 早睡早起，抵制诱惑，多花时间干正事 健康的人 每天坚持锻炼 外向的人 有合适机会时就主动参加别人的活动，对别人更好一点 赚大钱的人 专注于提升能力，提升修养","link":"/2023/02/09/%E3%80%8A%E5%8E%9F%E5%AD%90%E4%B9%A0%E6%83%AF%20Atomic%20Habits%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0&%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AC%94%E8%AE%B0/"},{"title":"《图解HTTP》笔记 第一章 了解Web及网络基础","text":"1.1 使用HTTP协议访问Web当我们在浏览器中输入 URL 并返回显示内容时，实际上使用的就是 HTTP（HyperText Transfer Protocol，超文本传输协议）来进行数据传输。 1.2 HTTP的诞生 为知识共享而规划 Web 基本理念：通过超文本将互联网连成可互相参阅的万维网（WWW）。 WWW 的三项技术： HTML：文本标记语言。 HTTP：文档传输协议。 URL：指定文档所在地址。 WWW 简称为 Web。 Web 的成长时代 各种 Web 客户端和服务器陆续出现，推动了 Web 的发展。 HTTP 的发展历程 HTTP/0.9：初始版本，未正式公布为标准。 HTTP/1.0：正式标准，仍然在许多服务端广泛使用。 HTTP/1.1：目前最主流的版本。 HTTP/2.0：新版本，尚未完全普及。 1.3 网络基础 TCP/IP TCP/IP 协议族 TCP/IP 是一系列网络协议的集合，负责管理网络通信。 TCP/IP 的分层管理 TCP/IP 协议分为四层： 网络接口层：负责相邻节点之间的数据传输。 网际层：实现主机间的逻辑通信，负责选择传输路径（包括 IP 协议）。 传输层：实现主机进程间的逻辑通信（包括 TCP、UDP）。 应用层：用户与网络的接口，应用层协议如 HTTP、DNS、FTP 等。 分层设计的好处： 每层只需要解决其特定的问题，简化了设计。 分层后，各层之间的接口定义明确，改变某层的内部实现不会影响其他层。 TCP/IP 通信传输流 数据传输过程中包括封装和解包。 HTTP 与 IP、TCP 和 DNS 的关系 IP（互联网协议）：负责将数据从一个主机传输到另一个主机。 TCP（传输控制协议）：确保数据在传输中完整无误。 DNS（域名系统）：将域名解析为 IP 地址。 URL 和 URI URI（统一资源标识符）：用于标识网络资源的标识符。 URL（统一资源定位符）：是 URI 的子集，专门用于表示资源的具体地址。 URI/URL 格式： 协议名：使用何种协议访问资源（如 HTTP）。 登录信息：可选项，指定用户名和密码。 服务器地址：域名或 IP 地址。 服务器端口号：默认端口号或指定端口号。 资源路径：资源所在的路径。 查询字符串：用于传递参数，以 key=value 的形式。","link":"/2023/03/24/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"title":"《图解HTTP》笔记 第七章 HTTPS","text":"7.1 HTTP的缺点HTTP 协议在传输过程中存在以下问题： 通信使用明文，容易被窃听： HTTP 传输的数据是明文的，没有加密，任何中间人都可以拦截和查看传输内容。 例如，用户的登录信息、支付信息等敏感数据可以被轻易窃取。 缺少身份验证，容易被伪装： 任何人都可以发起 HTTP 请求，无法确保与之通信的服务器或客户端是真实的。 可能访问的是伪装的服务器，导致数据被盗用。 报文完整性无法验证，可能被篡改： 在传输过程中，数据可能会被修改，而 HTTP 无法保证传输过程中报文的完整性。 即使使用了 MD5 校验和，校验值本身也可能被篡改。 7.2 HTTPS = HTTP + 加密 + 认证 + 完整性保护 HTTPS 与 SSL： HTTPS 是 HTTP 协议的安全版本，实际上是在 HTTP 外层加了一层 SSL（Secure Socket Layer）加密协议。 通过 SSL 提供的加密机制来保证数据的安全性。 注意：HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。 加密技术： HTTPS 结合了 对称加密 和 非对称加密 两种加密方式，提供了更高的安全性。 a. 对称加密： - 使用相同的密钥对数据进行加密和解密，密钥需要同时传递给通信双方。 - 问题：密钥在传输过程中可能被第三方窃取，导致安全风险。 b. 非对称加密： - 使用 公钥 和 私钥，服务器生成一对密钥，公钥提供给客户端，私钥仅在服务器端保存。 - 客户端使用公钥加密数据，服务器使用私钥解密。公钥即使被窃取，第三方也无法解密数据。 c. 混合加密机制： - HTTPS 同时使用了对称加密和非对称加密。首先通过非对称加密安全地传输对称加密的 共享密钥。 - 之后，使用共享密钥进行对称加密通信，提高效率。 - 原因：非对称加密计算复杂，效率低下，因此实际传输数据时使用对称加密来提高性能。 证明公钥真实性的证书： 尽管加密通信能保证传输安全，但仍然无法确认公钥是否来自真实服务器，因此需要验证公钥的真实性。 证书机构（CA，Certificate Authority） 会颁发数字证书，证明服务器的身份。 流程： 服务器向 CA 提交公钥和相关信息。 CA 验证服务器身份并颁发数字证书，客户端通过证书验证服务器的公钥真实性。 HTTPS 握手过程： 握手过程简介： 客户端发起请求，要求建立 HTTPS 连接。 服务器返回公钥和数字证书。 客户端验证证书的有效性，并生成对称加密的密钥，使用服务器公钥加密密钥并传输给服务器。 服务器使用私钥解密对称加密密钥，双方建立加密通道。 双方通过对称加密方式进行安全通信。 SSL 和 TLS： SSL（Secure Sockets Layer） 是 HTTPS 的核心，负责提供加密传输的基础。 TLS（Transport Layer Security）是 SSL 的升级版本，目前主流的协议版本为 SSL 3.0 和 TLS 1.0。两者常被统称为 SSL。 HTTPS 的速度慢： HTTPS 相比 HTTP 需要额外的加密和解密操作，因此会占用更多的计算资源，导致性能下降。 在对安全性要求不高的场景下，通常直接使用 HTTP 以节省资源。 总结 HTTPS 是 HTTP 的安全版本，通过加密、身份验证、和完整性保护来弥补 HTTP 的三大缺陷。 HTTPS 结合了对称加密和非对称加密的优点，既保证了安全性，又提高了性能。 证书机构（CA） 负责验证公钥的真实性，防止伪造服务器。 HTTPS 握手过程 是一个复杂的多步骤流程，涉及公钥、私钥、对称加密密钥的安全传输。 HTTPS 的安全性高于 HTTP，但同时需要更多的计算资源，因此在某些场景下仍使用 HTTP。","link":"/2023/03/30/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%83%E7%AB%A0%20HTTPS/"},{"title":"《图解HTTP》笔记 第三章 HTTP报文结构","text":"HTTP报文 HTTP报文 是 HTTP 协议在通信时传递的信息单元。 请求报文：客户端发送的报文。 响应报文：服务器端返回的报文。 HTTP 报文由 报文首部 和 报文主体 组成。 请求报文和响应报文的结构 HTTP 报文首部包含不同类型的首部字段。 首部字段 分为四种类型： 请求首部：客户端发送的请求报文包含的首部信息。 响应首部：服务器发送的响应报文包含的首部信息。 通用首部：请求和响应报文都可以使用的通用信息。 实体首部：用于描述报文主体内容的信息。 这些首部字段的具体作用会在后面的章节中详细解释。 数据压缩 简介：通过对报文内容进行压缩，减少数据体积，提高传输效率。 报文主体和实体主体：二者指代相同的内容，但未压缩时称为报文主体，压缩后称为实体主体。 内容编码（Content-Encoding）：用于指定报文压缩的算法。常见的编码方式有： gzip：常见的压缩算法。 compress：另一种压缩算法。 deflate：压缩方式。 identity：不进行压缩。 分块传输编码（Transfer-Encoding）： 报文通过 Transfer-Encoding 分块传输，便于处理大文件或未知长度的文件传输。 发送多种数据的多部分对象集合 HTTP 支持在同一个报文中传输多种类型的数据。 需要将 Content-Type 首部字段修改为： multipart/form-data：用于客户端向服务端发送多部分数据，如表单。 multipart/byteranges：用于服务端返回多个字节范围的数据，通常与 206 Partial Content 状态码一起使用。 获取部分内容的范围请求 客户端可以通过 范围请求 获取资源的部分数据。 使用的首部字段为 Range，例如：1Range: bytes=500-999 该请求只获取资源的第 500 到 999 字节的数据。 内容协商返回合适的内容 内容协商（Content Negotiation）：服务器根据客户端的请求，返回合适的内容格式或语言。 常用的协商相关首部字段有： Accept：客户端可接受的媒体类型。 Accept-Charset：客户端可接受的字符集。 Accept-Encoding：客户端支持的内容编码。 Accept-Language：客户端支持的语言。 Content-Language：服务器提供的资源的语言信息。 内容协商的三种类型： 服务器驱动协商： 服务器根据请求报文中的首部字段，选择合适的资源返回给客户端。 客户端驱动协商： 客户端根据返回的可选项，自己选择最合适的内容。 透明协商： 结合服务器驱动和客户端驱动的方式，自动选择合适的内容。","link":"/2023/03/24/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/"},{"title":"《图解HTTP》笔记 第二章 简单HTTP协议","text":"Client/Server架构 HTTP 协议采用 客户端/服务端 架构。 客户端 发送请求。 服务端 返回响应。 请求和响应 通信流程：客户端通过 HTTP 发送请求报文，服务端接收到请求后返回响应报文。 无请求无响应：如果服务端未收到请求，不会主动发送响应。 HTTP 不保存状态 HTTP 是无状态协议，不会保存先前的请求或响应信息。 Cookie：通过使用 Cookie，可以在 HTTP 中保存和管理状态，实现客户端与服务端之间的状态记录。 请求 URI 定位资源 HTTP 使用 URL 来定位和访问资源。 HTTP 方法 HTTP 使用 请求方法 来指定对资源的操作，常用的请求方法有： GET：获取资源。 用于请求指定 URL 的资源。 POST：传输请求体。 向服务器提交数据，数据放在请求体中。 PUT：传输文件。 用于上传文件，文件数据放在请求体中。 HEAD：获取报文首部。 和 GET 类似，但只返回响应头部，不包含响应体。 通常用于检查资源是否有效。 DELETE：删除资源。 删除指定的 URL 资源。 OPTIONS：询问支持的方法。 查询服务器支持的请求方法。 TRACE：追踪路径。 追踪请求经过的代理服务器路径，用于诊断网络问题。 Max-Forwards 用于限制跳数，较少使用，可能引发安全问题。 CONNECT：建立隧道协议。 用于建立隧道协议（通常是 SSL/TLS）以安全传输数据。 例如：CONNECT 代理服务器名:端口号 HTTP版本。 使用请求方法指定操作 客户端通过在请求行中指定请求方法来执行对资源的操作。 持久连接 问题： 在 HTTP/1.0 及之前，每次请求-响应都需要重新建立和释放 TCP 连接。 这种做法开销较大，因为每次连接只能进行一次通信。 长连接： HTTP/1.1 默认使用长连接（Keep-Alive），而 HTTP/1.0 默认是短连接。 使用长连接，多个请求可以通过同一个连接发送，减少了重复建立连接的开销。 流水线（Pipeline）： HTTP 通常是在收到响应后再发送下一个请求。 使用流水线技术，可以在同一连接上并行发送多个请求，无需等待响应，大大提高了效率。 流水线机制引入于 HTTP/1.1，而不是 HTTP/2.0。 使用 Cookie 管理状态 HTTP 无状态的缺点： HTTP 本身不记录状态，简化了协议，但在某些情况下需要状态记录，比如用户登录。 为了解决这一问题，引入了 Cookie 技术。 Cookie 的作用： Cookie 是一小段数据，由服务器发送给客户端。 客户端接收到 Cookie 后，会在后续请求中自动携带 Cookie，帮助服务端识别客户端的状态。 Cookie 通过在响应头中使用 Set-Cookie 设置。 通常，Cookie 中包含 Session ID，用于识别特定客户端会话。","link":"/2023/03/24/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%80%E5%8D%95HTTP%E5%8D%8F%E8%AE%AE/"},{"title":"《图解HTTP》笔记 第六章 HTTP首部","text":"6.1 简介 HTTP报文首部 HTTP 报文首部包括报文行和报文头部，主要用于传递元数据信息。 HTTP 报文由 报文首部 和 报文主体 组成。报文首部包括： 请求行（请求报文）或 状态行（响应报文） 报文头：包含元数据信息的首部字段 报文主体：用于传输实际的数据 HTTP首部字段 首部字段结构：首部字段由 字段名 和 字段值 组成，即 Key: Value 对，多个字段可以组合在一起传输。 四种首部字段类型： 通用首部字段：适用于请求和响应报文，传递常见的信息。 请求首部字段：用于客户端向服务器发送的请求报文中，传递客户端的元数据。 响应首部字段：用于服务器向客户端发送的响应报文中，传递服务端的元数据。 实体首部字段：用于描述报文体（请求体或响应体）的元数据，如长度、编码方式等。 HTTP/1.1 首部字段概览： 通用首部字段：如 Cache-Control, Connection, Date。 请求首部字段：如 Host, User-Agent, Accept。 响应首部字段：如 Server, ETag, Location。 实体首部字段：如 Content-Type, Content-Length, Content-Encoding。 End-to-end 和 Hop-by-hop 首部： 端到端首部：在整个请求和响应链中有效，转发时不变。常见端到端首部有 Cache-Control, Content-Type。 逐跳首部：仅对单次转发有效，不会在代理或中继服务器之间转发。例如 Connection, Keep-Alive, Proxy-Authenticate 等。 6.3 通用首部字段详解 Cache-Control 简介：用于控制缓存机制，指示请求和响应如何缓存或是否缓存。通过多个指令组合使用。 缓存指令： public：缓存对所有用户有效。 private：缓存仅对特定用户有效。 no-cache：必须先验证缓存的有效性再使用缓存。 no-store：不允许缓存，所有内容都必须直接从服务器获取。 max-age：指定缓存的最大有效时间（秒数），超过该时间后必须重新请求。 s-maxage：用于公共缓存的最大有效时间，优先于 max-age。 must-revalidate：缓存过期后必须重新验证其有效性，不能使用过期缓存。 no-transform：禁止代理或其他中间服务器更改传输中的资源内容。 Connection 简介：控制不再转发给代理的首部字段，并用于管理持久连接（长连接或短连接）。 Connection: close：表示关闭连接，使用短连接。 Connection: Keep-Alive：表示保持连接，使用长连接，适用于多次请求-响应的通信。 HTTP/1.1 默认使用长连接。 Date 简介：表示报文的创建时间，格式为 Date: Tue, 15 Nov 1994 08:12:31 GMT。 Pragma Pragma: no-cache：遗留字段，主要用于 HTTP/1.0，表示不使用缓存内容，必须重新请求服务器。 Transfer-Encoding 简介：指示报文主体传输时的编码方式，常用于分块传输大文件。 Transfer-Encoding: chunked：分块传输，使报文可以逐块发送和接收，不必知道总长度。 Upgrade 简介：用于请求或响应中切换协议，如从 HTTP 切换到 HTTPS 或 TLS。 示例：Upgrade: TLS/1.0, HTTP/1.1。 Via 简介：用于记录请求或响应报文经过的代理服务器信息，显示报文通过的每一个中间节点。 Warning 简介：用于告知客户端与缓存相关的警告信息，例如 Warning: 110 - Response is Stale（响应数据过期）。 6.4 请求首部字段 Accept 简介：用于指定客户端可以接收的媒体类型。 示例：Accept: text/html, application/json;q=0.9（表示优先接收 text/html，但也能接受 application/json）。 Accept-Charset 简介：用于指定客户端可以接收的字符集编码。 示例：Accept-Charset: utf-8, iso-8859-1;q=0.7。 Accept-Encoding 简介：指定客户端支持的内容编码方式。 常见编码方式：gzip, compress, deflate, identity（不编码）。 Accept-Language 简介：用于指定客户端希望的响应语言。 示例：Accept-Language: en-US, fr;q=0.8。 Authorization 简介：客户端向服务器提供身份验证信息，用于访问受限资源。 示例：Authorization: Basic dXNlcjpwYXNzd29yZA==。 Host 简介：指定请求的目标主机名，用于支持虚拟主机。 示例：Host: www.example.com。 Range 简介：请求获取资源的部分内容，用于分段下载大文件。 示例：Range: bytes=500-999（请求第 500 到 999 字节的资源）。 User-Agent 简介：客户端浏览器或设备信息，用于识别发起请求的设备类型。 示例：User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)。 6.5 响应首部字段 Accept-Range 简介：用于告知客户端服务器是否支持范围请求（分段下载）。 示例：Accept-Range: bytes（支持字节范围请求）。 ETag 简介：资源的唯一标识符，用于检测资源是否发生变化。每次资源修改都会更新 ETag。 示例：ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d9&quot;。 Location 简介：用于重定向响应，告知客户端资源的新位置，通常与 3XX 状态码配合使用。 示例：Location: http://www.example.org/index.html。 Retry-After 简介：告知客户端需要等待的时间后再重新发起请求。 示例：Retry-After: 120（120秒后重试）。 Server 简介：用于告知客户端服务器的相关信息。 示例：Server: Apache/2.4.1 (Unix)。 Vary 简介：用于指定缓存响应时需考虑的首部字段，如果 Vary 中的字段值不同，则缓存失效。 示例：Vary: Accept-Encoding。 6.6 实体首部字段 Content-Encoding 简介：描述实体内容的编码方式。 示例：Content-Encoding: gzip（实体内容采用 gzip 压缩）。 Content-Length 简介：表示实体内容的字节大小。 示例：Content-Length: 348。 Content-Type 简介：描述实体内容的媒体类型。 示例：Content-Type: text/html; charset=utf-8。 Content-Range 简介：用于描述部分实体内容的范围。 示例：Content-Range: bytes 200-1000/67589。 Expires 简介：指明实体内容的过期时间，过期后需要重新获取资源。 示例：Expires: Wed, 21 Oct 2023 07:28:00 GMT。 6.7 为Cookie服务的首部字段 Set-Cookie 简介：服务端通过该字段设置客户端的 Cookie，用于会话管理和身份验证。 示例：Set-Cookie: sessionId=abc123; Path=/; Expires=Wed, 21 Oct 2023 07:28:00 GMT; Secure; HttpOnly。 Expires：指定 Cookie 的有效期。 Path：指定 Cookie 有效的 URL 路径。 Domain：指定 Cookie 有效的域。 Secure：只允许在 HTTPS 连接中传输。 HttpOnly：仅限于 HTTP 使用，禁止通过 JavaScript 访问。 Cookie 简介：客户端在发送请求时，携带服务端设置的 Cookie。 示例：Cookie: sessionId=abc123。","link":"/2023/03/29/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20HTTP%E9%A6%96%E9%83%A8/"},{"title":"《图解HTTP》笔记 第四章 HTTP状态码","text":"状态码用于告知服务端请求处理的状态 状态码：通过状态码，客户端可以得知请求报文是否被成功处理。 状态码按照处理结果的不同分为多个类别，最具有代表性的状态码有 14 种。 2XX 成功信息 200 OK： 请求已成功处理，服务器返回请求的资源。 204 No Content： 请求已成功处理，但不返回任何实体内容。 206 Partial Content： 请求成功，返回部分内容。通常用于响应 Range 请求，客户端请求资源的某一部分。 3XX 重定向信息 301 Moved Permanently： 请求的资源已永久移动到新的 URL。客户端应使用新的 URL 来访问资源。 302 Found： 请求的资源临时移动到新的 URL，将来可能会恢复原地址。浏览器会继续使用原 URL 发送请求。 303 See Other： 请求的资源已临时移动到新的 URL，客户端应使用 GET 方法访问新 URL。 304 Not Modified： 资源未被修改，客户端可以继续使用缓存的资源。通常与 If-Match 和 ETag 相关。 307 Temporary Redirect： 请求的资源临时重定向，但要求客户端保持原有的请求方法（如 POST），不应改为 GET。 4XX 客户端错误 400 Bad Request： 请求报文存在语法错误，服务器无法理解该请求，需要修改后重新发送。 401 Unauthorized： 请求未通过认证，客户端需要提供有效的认证凭据。 403 Forbidden： 服务器拒绝访问资源，可能由于权限问题，例如 IP 地址不符合条件。 404 Not Found： 服务器上找不到客户端请求的资源。 405 Method Not Allowed： 请求方法不被支持，客户端可以通过 OPTIONS 请求获取资源支持的请求方法，响应中的 Allow 首部字段列出支持的方法。 499（nginx专用）： 表示客户端主动断开连接，通常是服务器处理速度太慢导致。 5XX 服务端错误 500 Internal Server Error： 服务器在处理请求时发生了内部错误。 501 Not Implemented： 服务器不支持请求的方法。与 405 Method Not Allowed 的区别： 405 表示服务器支持该方法，但资源不支持该方法。 501 表示服务器完全不支持该方法。 502 Bad Gateway： 网关服务器收到无效响应，导致无法正常处理请求。 503 Service Unavailable： 服务器暂时不可用，通常伴随 Retry-After 首部字段，指示客户端何时可以重新尝试请求。 504 Gateway Timeout： 网关服务器在尝试访问上游服务器时超时。","link":"/2023/03/28/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"},{"title":"《疯狂Java》笔记 反射机制","text":"本章要点 使用 Class 对象 Java 8 新增的方法参数反射 动态创建 Java 对象 动态调用方法 访问并修改 Java 对象的属性值 使用反射操作数组 使用 Proxy 和 InvocationHandler 创建动态代理 AOP 入门 Class 类的泛型 通过反射获取泛型类型 18.3 通过反射查看类信息简介：Java 中变量有编译时类型和运行时类型。编译时类型是变量声明的类型，而运行时类型是对象的实际类型。通过 instanceof 可以判断一个对象是否是某个类型，而通过反射可以获取对象的类信息，甚至在运行时动态操作类和对象。反射允许在运行时动态获取类的详细信息，例如构造器、成员变量、方法等，并且可以创建对象、调用方法、访问和修改对象的属性值。反射特别适合在运行时根据字符串动态生成对象的场景。 获取 Class 对象的三种方式 **Class.forName(String name)**： 通过类的全限定名获取 Class 对象，可能会抛出 ClassNotFoundException。 例如：1Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;); 类的 .class 属性： 例如 Person.class，这种方式速度更快，且更安全。 调用对象的 getClass() 方法： 返回该对象所属类的 Class 对象。 从 Class 对象中获取信息 可以获取类的构造器、方法、成员变量、注解、内部类、外部类、实现的接口、继承的父类等。 例如：12Method[] methods = clazz.getMethods(); // 获取所有方法Field[] fields = clazz.getDeclaredFields(); // 获取所有成员变量 Java 8 新增的方法参数反射 Java 8 开始支持通过反射获取方法的参数名和参数类型，这对动态操作方法参数非常有用。 通过 Method.getParameters() 可以获取参数的详细信息。 使用反射生成并操作对象 创建对象： 通过调用 Class 对象的 newInstance() 方法创建对象： 12Class&lt;?&gt; clazz = Class.forName(&quot;com.example.Person&quot;);Object obj = clazz.newInstance(); // 调用无参构造函数 通过构造器创建对象，先通过 getConstructor() 获取构造器对象，再调用其 newInstance() 方法： 12Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class);Object obj = constructor.newInstance(&quot;John&quot;, 30); // 调用有参构造函数 调用方法： 通过 getMethod() 方法获取 Method 对象，再使用 invoke() 方法调用该方法：12Method method = clazz.getMethod(&quot;sayHello&quot;);method.invoke(obj); // 调用无参方法 如果调用 private 方法，需要使用 setAccessible(true) 来提升访问权限。 访问成员变量值： 使用 getField() 获取 public 成员变量，或使用 getDeclaredField() 获取任意权限的成员变量。 通过 getXXX() 和 setXXX() 方法来获取或修改成员变量的值，例如：1234Field field = clazz.getDeclaredField(&quot;name&quot;);field.setAccessible(true); // 如果是 private 成员String name = (String) field.get(obj);field.set(obj, &quot;NewName&quot;); 操作数组 可以通过反射创建和操作数组。例如，创建一个指定类型和大小的数组：123int[] arr = (int[]) Array.newInstance(int.class, 10);Array.set(arr, 0, 42); // 设置数组的第一个元素为 42int value = Array.getInt(arr, 0); // 获取数组的第一个元素 18.4 使用反射生成 JDK 动态代理动态代理简介：代理是一种设计模式，代理对象充当被代理对象的替代品，通常在调用被代理对象之前或之后增加额外的功能。代理分为静态代理和动态代理。静态代理是提前写好代理类，缺点是需要为每个类单独编写代理类。动态代理则是在运行时动态生成代理类，更加灵活。 使用 Proxy 和 InvocationHandler 创建动态代理 Proxy 提供了创建动态代理的静态方法，InvocationHandler 是接口，用于处理代理对象的方法调用。 例如：12345678910111213141516171819202122public class MyInvocationHandler implements InvocationHandler { private Object target; public MyInvocationHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;Before method: &quot; + method.getName()); Object result = method.invoke(target, args); System.out.println(&quot;After method: &quot; + method.getName()); return result; }}MyInterface proxyInstance = (MyInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new MyInvocationHandler(target));proxyInstance.someMethod(); 动态代理与 AOP 动态代理常用于 AOP（面向切面编程），在方法调用前后执行额外的操作，比如日志记录、权限检查等。 动态代理相比静态代理更灵活，因为它能够动态生成代理类，而无需预先编写代理代码。 18.6 反射和泛型泛型与 Class 类：在 JDK 1.5 引入了泛型，可以为 Class 对象增加泛型参数，以保证类型安全并避免强制类型转换。 泛型和 Class 类 例如：12345public class ObjectFactory { public &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws Exception { return clazz.newInstance(); }} 使用泛型可以确保返回值的类型安全，避免类型转换异常。 通过反射获取泛型类型 反射只能获取类的原始类型，无法直接获取泛型类型。如果需要获取成员变量的泛型类型，可以使用 getGenericType()：123456789Field field = clazz.getDeclaredField(&quot;map&quot;);Type type = field.getGenericType();if (type instanceof ParameterizedType) { ParameterizedType paramType = (ParameterizedType) type; Type[] actualTypes = paramType.getActualTypeArguments(); for (Type actualType : actualTypes) { System.out.println(actualType.getTypeName()); // 输出泛型参数类型 }} 总结 反射机制可以在运行时动态获取类的详细信息，并通过反射生成对象、调用方法、访问和修改成员变量。 动态代理允许在运行时创建代理类，方便实现 AOP 编程等高级功能。 泛型和反射结合使用时，可以通过 Class&lt;T&gt; 来确保类型安全，并且通过反射还能获取泛型类型参数的信息。 反射不仅可以用于类、方法和字段的操作，还可以用于数组的创建和操作，甚至可以动态生成代理对象。","link":"/2023/04/01/%E3%80%8A%E7%96%AF%E7%8B%82Java%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"《疯狂Java》笔记 异常","text":"本章要点 异常的定义和概念 Java异常机制的优势 使用try-catch捕获异常 多异常捕获 finally块的作用 自动关闭资源的try语句 异常处理的合理嵌套 Checked异常和Runtime异常 使用throws声明异常 使用throw抛出异常 自定义异常 异常链和异常转译 异常的跟踪栈信息 异常的处理规则 10.1 异常概述Java 的异常处理机制可以将“业务代码”和“异常处理代码”分离，提高代码可读性。 异常处理机制的关键字 try：用于包裹可能会发生异常的代码块。 catch：捕获并处理指定类型的异常。 finally：无论是否抛出异常，都会执行，用于回收资源。 throws：声明方法可能抛出的异常。 throw：实际抛出一个异常。 异常的分类 Checked 异常： 编译时必须处理的异常，所有的 Checked 异常都必须明确处理（捕获或声明）。 Runtime 异常： 运行时异常，可以选择不处理，常见如 NullPointerException。 10.2 异常处理机制 使用try-catch捕获异常 当try块中的代码在运行时出现异常时，系统会自动生成一个异常对象，并将其交给 JVM。JVM 会查找匹配的 catch 块，找到后进行处理，若找不到，程序会退出。 异常类的继承体系 Throwable 是所有异常的父类，异常类分为两大类： Error：不可恢复的错误，通常与 JVM 相关，如内存溢出。 Exception：可捕获和处理的异常，如 IndexOutOfBoundsException、NullPointerException。 捕获顺序：应先捕获子类异常，再捕获父类异常。例如： 1234567try { // 可能发生异常的代码} catch (IndexOutOfBoundsException e) { // 处理数组越界异常} catch (Exception e) { // 处理其他异常} Java 7 提供的多异常捕获 使用竖线 | 来捕获多个异常。例如： 12345try { // 可能发生异常的代码} catch (IOException | SQLException e) { e.printStackTrace();} 捕获多个异常时，异常变量隐式被 final 修饰，因此不允许对其重新赋值。 访问异常信息 常见的异常信息获取方式： getMessage()：获取异常的描述信息。 printStackTrace()：打印异常的跟踪栈信息。 getStackTrace()：获取异常的堆栈跟踪数组。 使用finally回收资源 finally 块中的代码总是会执行，因此适合回收资源。 需要注意： 如果调用了 System.exit(1) 退出 JVM，finally 块不会执行。 不要在 finally 块中使用 return 或 throw，这会导致 try 块中的 return 被忽略。 异常处理的嵌套 可以在 try、catch、finally 块中嵌套更多的 try-catch 块，虽然允许嵌套，但应避免复杂的嵌套结构。 Java 7 自动关闭资源的try语句 使用 try-with-resources 语句，自动关闭实现了 AutoCloseable 或 Closeable 接口的资源。例如： 123456try (BufferedReader br = new BufferedReader(new FileReader(&quot;file.txt&quot;))) { // 使用资源} catch (IOException e) { e.printStackTrace();}// BufferedReader 会自动关闭 10.3 Checked异常和Runtime异常体系 Checked 异常 Java 异常分为两类，Checked 异常和 Runtime 异常： Checked 异常必须被显式捕获或通过 throws 声明，编译时必须处理，如 IOException 和 SQLException。 Runtime 异常无需显示声明或捕获，可以选择性处理，如 NullPointerException。 使用throws声明抛出异常 使用 throws 声明方法可能抛出的异常： 123public void readFile() throws IOException { // 可能抛出 IOException} 如果方法内无法处理异常，可以将异常抛出给调用者。如果未处理，最终由 JVM 处理，打印跟踪栈并终止程序。 注意事项 子类在覆盖父类方法时，不能声明比父类方法更多或更严重的异常，否则会编译失败。 10.4 使用throw抛出异常 抛出异常 可以使用 throw 关键字显式抛出异常。例如： 1throw new IllegalArgumentException(&quot;非法参数&quot;); Checked 异常的抛出 抛出 Checked 异常时，必须在 try 块中或使用 throws 关键字声明，否则编译会报错。 Runtime 异常的抛出 可以随时抛出 Runtime 异常，编译器不会要求显式捕获。 自定义异常 可以通过继承 Exception 或 RuntimeException 来创建自定义异常。例如： 12345public class MyException extends Exception { public MyException(String message) { super(message); }} catch 和 throw 同时使用 可以在捕获到异常后重新抛出新的异常。例如： 12345try { // 可能发生异常的代码} catch (IOException e) { throw new MyException(&quot;自定义异常&quot;, e); // 异常链} 异常链 异常链可以将捕获的原始异常包裹在新的异常中，这样可以保留原始异常的上下文信息，便于调试和追踪。例如： 1throw new MyException(&quot;自定义异常&quot;, e); // 包裹原始异常 10.6 异常处理规则 不要过度使用异常 仅在无法预料的错误情况下使用异常。能够通过正常逻辑处理的错误，不应抛出异常。 避免过大的try块 大的 try 块会增加捕获异常的复杂性，容易导致代码混乱。应将try块的范围缩小，集中处理特定异常。 避免Catch All 不应使用 Exception 或 Throwable 捕获所有异常，这样会掩盖具体的异常信息。应该有针对性地捕获异常类型。 不要忽略捕获的异常 捕获异常后应适当地处理异常或抛出新的异常，不能简单地忽略或仅打印错误信息。 总结 Java 的异常机制通过 try-catch-finally 实现，能够有效分离正常业务逻辑和错误处理代码。 异常处理应该尽量简洁，不应使用过多嵌套或过于复杂的异常捕获机制。 使用异常链可以传递更详细的错误信息，有助于调试。 合理使用 Checked 异常和 Runtime 异常，避免滥用异常机制。","link":"/2023/03/27/%E3%80%8A%E7%96%AF%E7%8B%82Java%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%BC%82%E5%B8%B8/"},{"title":"《疯狂Java》笔记 泛型","text":"简介在JDK 1.5添加泛型之前，集合类没法记住每个对象的类型，只能把所有的对象当作 Object 类处理。并且取出对象后需要进行强制类型转换，容易出现 ClassCastException。有了泛型之后，可以记住集合中元素的类型，并在往集合中添加对象时检查类型是否正确。 章节要点 编译时类型检查的重要性。 使用泛型实现编译时类型检查。 定义泛型接口、泛型类。 派生泛型接口、泛型类的子类、实现类。 使用类型通配符。 设定类型通配符的上限。 设定类型形参的上限。 在方法签名中定义类型形参。 泛型方法和类型通配符的区别与联系。 设定类型通配符的下限。 泛型方法与方法重载。 Java 8 改进的类型推断。 擦除与转换。 泛型与数组。 9.1 泛型入门 集合不使用泛型会带来的问题 将元素放入集合时不会对类型进行检查。 取出集合时，需要进行强制类型转换，容易出现 ClassCastException。 例如： 12345List list = new ArrayList();list.add(&quot;Hello&quot;);list.add(10); // 没有泛型检查，允许插入不同类型的对象String str = (String) list.get(0); // 需要强制类型转换Integer num = (Integer) list.get(1); // 可能导致 ClassCastException 使用泛型后 Java 5 引入了 “参数化类型（Parameterized Type）” 和 “类型形参”，允许在创建集合时指定集合元素的类型。 也称为泛型（Generic）。 使用泛型指定集合元素类型后： 对象在放入集合时会进行检查，类型不对则报错。 取出集合元素后，不需要进行强制类型转换。 例如： 1234List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);// list.add(10); // 编译时就会报错String str = list.get(0); // 不需要强制类型转换 Java 7 泛型的菱形语法 Java 7 之前，泛型需要这样写： 1List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Java 7 之后可以省略构造器的泛型信息： 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 因为 &lt;&gt; 像菱形，所以叫菱形语法。 9.2 深入泛型泛型是在定义类、接口、方法时使用类型形参，类型形参将在变量声明、对象创建和方法调用时被动态指定。 泛型接口、类的定义方法 Java 5 之后的 List 接口、Iterator 接口、Map 接口定义了泛型类型形参。例如： 1234public interface List&lt;E&gt; { // E 是类型形参 void add(E element); E get(int index);} 从泛型类派生子类 子类继承泛型类时，必须给类型形参传入具体的类型实参，不能直接写类型形参。 错误的写法： 1class MyClass&lt;T&gt; extends ArrayList&lt;T&gt; {} // 错误：子类不能继续保持类型形参 正确的写法： 1class MyStringList extends ArrayList&lt;String&gt; {} // 正确：为父类指定具体类型 也可以省略类型参数，这时会被当作 Object 处理： 1class MyList extends ArrayList {} // 等价于 ArrayList&lt;Object&gt; 不存在泛型类的Class对象 无论实例化泛型类时指定了什么类型参数，它们都被认为是同一个 Class。 例如： 123List&lt;String&gt; list1 = new ArrayList&lt;&gt;();List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();System.out.println(list1.getClass() == list2.getClass()); // true 因此在泛型类的静态方法中，不允许使用类型形参，因为静态方法不依赖于实例化。 错误的示例： 123public class GenericClass&lt;T&gt; { private static T value; // 错误：静态成员不能使用泛型类型} 类型擦除 Java 的泛型是通过 类型擦除 实现的。泛型类型信息在编译时被擦除，替换为它们的上限（如果没有指定上限，则替换为 Object）。这解释了为什么不同类型参数的泛型类在运行时被认为是同一个 Class。 9.3 类型通配符 使用类型通配符 为表示所有泛型类的父类，可以使用类型通配符 ?。 例如： 1List&lt;?&gt; list = new ArrayList&lt;String&gt;(); // 可以指向任何类型的List 由于通配符没有确定具体的类型，因此无法往其中加入元素，唯一允许加入的元素是 null。 1list.add(null); // 唯一允许的添加 设定通配符的上限 可以对通配符的匹配类型设定上限： 1List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;(); // 只能是 Number 的子类 由于通配符没有确定具体类型，因此无法往其中加入元素，只能读取数据。 设置类型形参的上限 可以在定义泛型类时指定类型形参的上限： 123public class Apple&lt;T extends Number&gt; { private T size;} 甚至可以指定多个上限： 123public class Data&lt;T extends Number &amp; Comparable&lt;T&gt;&gt; { private T data;} 设定通配符的下限 使用 &lt;? super T&gt; 来设定通配符的下限，可以确保传入的类型参数是特定类的父类。 例如： 12List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;();list.add(10); // 可以添加 Integer 类型的对象 9.4 泛型方法 定义泛型方法 在定义方法时，可以使用类型形参： 123public &lt;T&gt; T genericMethod(T t) { return t;} 类型形参声明必须位于修饰符和返回值之间： 123public &lt;T&gt; void print(T value) { System.out.println(value);} 编译器可以自动推断类型参数，调用时无需显式传入类型参数： 1print(&quot;Hello&quot;); // 自动推断为 String 泛型方法和类型通配符的区别 泛型方法用于方法的参数和返回值之间有依赖关系的场景： 123public &lt;T&gt; T copy(T t) { return t;} 通配符用于允许传入不同类型实参的场景： 12345public void printList(List&lt;?&gt; list) { for (Object elem : list) { System.out.println(elem); }} 泛型构造器和菱形语法 构造器方法也可以使用泛型，但其泛型与类的泛型不同： 12345public class MyClass { public &lt;T&gt; MyClass(T t) { System.out.println(t); }} 如果显式指定了构造器的类型参数，则不能使用菱形语法。 泛型方法与方法重载 如果定义了两个泛型方法，虽然不会编译错误，但在调用时可能会出现问题。例如： 12public &lt;T&gt; void method(T t) {}public &lt;T&gt; void method(List&lt;T&gt; list) {} 泛型与数组 泛型与数组的局限性 在Java中，不能直接创建泛型数组，因为泛型类型信息在运行时被擦除，数组必须知道其具体的类型。 错误的示例： 1List&lt;String&gt;[] array = new List&lt;String&gt;[10]; // 编译错误","link":"/2023/03/18/%E3%80%8A%E7%96%AF%E7%8B%82Java%E3%80%8B%E7%AC%94%E8%AE%B0%20%E6%B3%9B%E5%9E%8B/"},{"title":"《疯狂Java》笔记 注解","text":"简介注解（Annotation）是一种特殊的标记，可以在编译、运行的时候通过反射获取，并且执行相应的处理。注解的好处是可以在不改变原有逻辑的情况下添加一些补充的信息。Annotation 是一个接口，可以通过反射来获得指定对象的注解对象，然后通过注解对象获取其中的元数据。注解的处理工具称为 APT（Annotation Processing Tool）。 本章要点 Annotation 的概念和作用 @Override @Deprecated @SuppressWarnings 自定义注解 重复注解 Type Annotation 提取注释信息 @Retention @Target @Documented @Inherited 14.1 基本 Annotation @Override 用于标识当前方法是重写了父类的方法。 如果没有正确地重写父类的方法，例如方法签名不匹配，编译时会报错。 例如：1234@Overridepublic String toString() { return &quot;This is an override method.&quot;;} @Deprecated 用于标识该方法或类已过时，不建议使用。 如果使用了标记为 @Deprecated 的方法或类，编译器会发出警告。 例如：1234@Deprecatedpublic void oldMethod() { // 旧的实现，不推荐使用} @SuppressWarnings 用于抑制编译器的警告信息。 常用于抑制类型不安全的操作警告，例如：1234@SuppressWarnings(&quot;unchecked&quot;)public void testMethod() { List list = new ArrayList();} @FunctionalInterface 用于声明接口为函数式接口，函数式接口只能有一个抽象方法。 可以通过 Lambda 表达式创建该接口的实例。 例如：1234@FunctionalInterfacepublic interface MyFunction { void apply();} 14.2 JDK 的元 Annotation元 Annotation 用于修饰其他的 Annotation。 @Retention 用于指定 Annotation 的生命周期，决定注解信息保存到何时。 使用 @Retention(RetentionPolicy.RUNTIME) 时，注解在运行时可通过反射获取。 例如：12@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation {} @Target 用于限制注解可以应用的程序元素，例如只能作用于方法、类、变量等。 例如：12@Target(ElementType.METHOD)public @interface MyMethodAnnotation {} @Documented 表示使用了该注解的元素会出现在 Javadoc 文档中。 例如：12@Documentedpublic @interface MyDocumentedAnnotation {} @Inherited 表示注解具有继承性，即如果某个类使用了该注解，子类将自动继承该注解。 例如：123@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface MyInheritedAnnotation {} 14.3 自定义 Annotation 定义普通注解 定义注解和定义接口类似，只需在 interface 前加上 @ 符号。 例如：123public @interface MyAnnotation { String value() default &quot;defaultValue&quot;;} 注解的使用范围 注解可以用于修饰类、方法、变量、接口等程序元素。 有成员变量的注解 注解可以包含成员变量，并且可以指定默认值。例如：1234public @interface MyAnnotation { String name(); int age() default 18;} 注解的分类 标记注解：不包含成员变量，仅依赖自身存在提供信息。例如：1public @interface MarkerAnnotation {} 元数据注解：包含成员变量，用于存储额外的元数据。例如：123public @interface MetaDataAnnotation { String info();} 提取注解数据 注解本身不会自动生效，必须通过反射等工具来提取并处理注解信息。 AnnotatedElement 是所有程序元素（如 Class、Method、Constructor）的父接口，可以通过反射获取其注解信息。 获取注解的例子：123Method method = MyClass.class.getMethod(&quot;myMethod&quot;);MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);System.out.println(annotation.name()); 重复注解（Java 8 新增） Java 8 之前，一个注解在同一个程序元素上只能使用一次。 Java 8 引入了 @Repeatable，允许一个程序元素上使用同一注解多次。 例如：12345678@Repeatable(MyAnnotations.class)public @interface MyAnnotation {}public @interface MyAnnotations { MyAnnotation[] value();}@MyAnnotation@MyAnnotationpublic void myMethod() {} Type Annotation（Java 8 新增） Java 8 扩展了注解的使用范围，允许注解用于类型参数、泛型类型等新位置。 14.4 编译时处理 AnnotationAPT 工具（Annotation Processing Tool）可以在编译源代码时，根据注解生成额外的附属文件，如配置文件、代码等。APT 处理注解的细节主要涉及编译时的代码分析和生成，具体细节可以查阅相关资料。 总结 注解可以为程序添加元数据，并通过反射机制在运行时提取和处理这些元数据。 Java 的元注解（如 @Retention、@Target、@Inherited 等）用于控制注解的生命周期、作用范围以及是否继承。 Java 8 引入了重复注解和类型注解，进一步扩展了注解的使用场景。 自定义注解可以根据需要灵活应用于方法、类、字段等元素，并通过反射提取其数据。 APT 工具用于在编译时处理注解，生成所需的附属文件或代码。","link":"/2023/03/31/%E3%80%8A%E7%96%AF%E7%8B%82Java%E3%80%8B%E7%AC%94%E8%AE%B0%20%E6%B3%A8%E8%A7%A3/"},{"title":"《疯狂Java》笔记 类加载机制","text":"本章要点 类加载 类连接的过程 类初始化的过程 类加载器及其实现机制 继承 ClassLoader 实现自定义类加载器 使用 URLClassLoader 18.1 类的加载、连接和初始化JVM 可能在第一次使用某个类时加载该类，也可能采用预加载机制来提前加载某个类。 JVM 和类 当执行一个 Java 程序时，会启动一个 JVM 进程，所有线程和数据都在这一个进程里。 JVM 终止的情况： 程序正常执行结束。 出现未捕捉的异常或错误。 调用 System.exit()。 进程被外部强制关闭。 类的加载（不包括连接和初始化） 当程序使用某个类时，如果该类尚未被加载到内存中，JVM 会通过类加载器将类的 .class 文件加载到内存，并创建一个 java.lang.Class 对象。 类加载的来源： 本地 .class 文件。 .jar 包中的类文件。 网络上的类文件。 动态编译的 Java 源文件。 类的连接 类加载后生成一个 Class 对象，接下来进入连接阶段，连接包括以下三个步骤： 验证：检查 .class 文件的正确性，确保字节码文件符合 JVM 规范。 准备：为类的静态变量分配内存空间，并设置默认值（如 0、null）。 解析：将类中的符号引用（以字符串表示）替换为实际的内存地址（直接引用）。 类的初始化 负责将类的静态变量设置为指定的初始值，可能通过直接赋值或静态代码块实现。 JVM 的初始化步骤： 检查当前类是否已加载并连接。 检查父类是否已初始化，如果没有，则先初始化父类。 执行类中的静态初始化语句或静态代码块。 类初始化的时机 类在以下几种情况会被初始化： 对类进行实例化。 调用类的静态方法。 访问类的静态变量。 使用反射创建 Class 对象。 初始化该类的子类。 特殊情况： static final 修饰的常量在编译时即可确定，因此使用时不会导致类的初始化。 loadClass() 与 forName() 的区别： 使用类加载器的 loadClass() 只会加载类，不会进行初始化。 Class.forName() 会进行类的加载、连接和初始化。 18.2 类加载器类加载器负责将 .class 文件加载到内存中，并生成对应的 Class 对象。 类加载器简介 Java 中类的唯一标识是类的全限定名（包名+类名）。 JVM 通过类的全限定名+类加载器的组合，唯一标识一个类。 JVM 的三层初始类加载器： Bootstrap ClassLoader（根类加载器）： 负责加载 Java 核心类库，如 java.lang.* 包。 由 C/C++ 实现，无法通过 Java 代码获取。 Extension ClassLoader（扩展类加载器）： 负责加载 JRE 的扩展类库。 System/Application ClassLoader（系统/应用类加载器）： 负责加载用户类路径（CLASSPATH）下的类。 类加载机制 全盘加载：当类加载器加载一个类时，还会加载该类所依赖的所有其他类。 双亲委派机制：类加载器会先委托父类加载器尝试加载类，只有当父类加载失败时，才会自己尝试加载。 缓存机制：类加载器会缓存已加载的类，当再次请求加载时直接从缓存返回，避免重复加载。 双亲委派机制的好处： 防止类的重复加载，确保每个类只加载一次。 保证核心类库的安全性，避免应用程序类加载器覆盖核心类库。 创建自定义类加载器 通过继承 ClassLoader 并重写其方法，用户可以实现自定义的类加载器。 ClassLoader 类的关键方法： loadClass()： 首先检查缓存中是否已经加载过该类，然后委托父加载器尝试加载，最后调用 findClass() 方法。 findClass()： 自定义类加载器时常重写此方法，直接从指定路径或来源加载类的字节码。 调用 defineClass() 将字节码转换为 Class 对象。 重写 findClass() 的好处： 不影响双亲委派机制和缓存机制，适合实现自定义类加载逻辑。 例如，可以根据用户需求动态加载类或从非传统来源加载类文件。 URLClassLoader 类 URLClassLoader 是 ClassLoader 的一个实现，允许从本地文件或网络 URL 中加载类文件。 它是扩展类加载器和应用程序类加载器的父类，常用于加载来自网络的资源或 JAR 包。 例如：123URL[] urls = new URL[]{new URL(&quot;file:/path/to/classes/&quot;)};URLClassLoader loader = new URLClassLoader(urls);Class&lt;?&gt; clazz = loader.loadClass(&quot;com.example.MyClass&quot;); 总结 类加载 是 JVM 动态加载类的过程，分为加载、连接和初始化三个阶段。 类加载器 是负责将 .class 文件加载到内存的组件，JVM 中使用双亲委派机制来管理类的加载。 用户可以通过继承 ClassLoader 实现自定义类加载器，并根据需求动态加载类。 双亲委派机制 能确保核心类库的安全性，并防止类的重复加载。 URLClassLoader 是一个实用的类加载器实现，能够从网络或本地路径加载类文件。","link":"/2023/03/31/%E3%80%8A%E7%96%AF%E7%8B%82Java%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"}],"tags":[{"name":"保研","slug":"保研","link":"/tags/%E4%BF%9D%E7%A0%94/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"项目管理","slug":"项目管理","link":"/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"学习习惯","slug":"学习习惯","link":"/tags/%E5%AD%A6%E4%B9%A0%E4%B9%A0%E6%83%AF/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[],"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}