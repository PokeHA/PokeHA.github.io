<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022计算机保研经历：末九6%的头铁之路（南大软院、浙大软院、武大计算机、中科大先研院、西交软院）</title>
    <url>/2022/12/02/2022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86%EF%BC%9A%E6%9C%AB%E4%B9%9D6-%E7%9A%84%E5%A4%B4%E9%93%81%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%B5%99%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%AD%A6%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%85%88%E7%A0%94%E9%99%A2%E3%80%81%E8%A5%BF%E4%BA%A4%E8%BD%AF%E9%99%A2%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a><strong>Prelude</strong></h1><p>上岸躺平了好长时间了，还是决定写点东西记录一下</p>
<p>我的保研经历总的来说就是头铁+狗屎运，希望大家引以为戒，警钟撅烂(</p>
<h1 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a><strong>个人情况</strong></h1><h2 id="学术背景"><a href="#学术背景" class="headerlink" title="学术背景"></a><strong>学术背景</strong></h2><p><strong>学校</strong>：真末流985</p>
<p><strong>专业</strong>：软件工程</p>
<p><strong>排名</strong>：6%</p>
<p><strong>外语</strong>：CET4 600多 CET6 550多</p>
<p><strong>科研</strong>：无，没找过导师做东西</p>
<p><strong>项目</strong>：全是课设，其中有一个老师给了很大的发挥空间，做了点有用的东西出来</p>
<p><strong>竞赛</strong>：蓝桥杯国三+省一、建模国赛省一，其余都是一些水赛</p>
<span id="more"></span>

<h2 id="院校偏向"><a href="#院校偏向" class="headerlink" title="院校偏向"></a><strong>院校偏向</strong></h2><ul>
<li>就业导向 不直博</li>
<li>是不是0812无所谓，倒不如说更希望读专硕</li>
<li>主要看重院校的 Title 以及 是否放实习</li>
<li>交叉院校不怎么考虑</li>
<li>梦校 南软 or 浙软</li>
</ul>
<h1 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a><strong>夏令营</strong></h1><h2 id="申请情况"><a href="#申请情况" class="headerlink" title="申请情况"></a><strong>申请情况</strong></h2><table>
<thead>
<tr>
<th align="left">学校</th>
<th align="left">院系</th>
<th align="center">入营</th>
<th align="center">结果</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">西安交通大学</td>
<td align="left">软件学院</td>
<td align="center">✅</td>
<td align="center">优营</td>
<td align="left">计院夏令营不发offer所以没报</td>
</tr>
<tr>
<td align="left">中国科学技术大学</td>
<td align="left">先研院</td>
<td align="center">✅</td>
<td align="center">无</td>
<td align="left">面试大暴死</td>
</tr>
<tr>
<td align="left">复旦大学</td>
<td align="left">工研院</td>
<td align="center">❌</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">同济大学</td>
<td align="left">软件学院</td>
<td align="center">❌</td>
<td align="center"></td>
<td align="left">其实没报，但有和我排名相近的同学报了入营了</td>
</tr>
<tr>
<td align="left">哈尔滨工业大学(深圳)</td>
<td align="left">计算机学院</td>
<td align="center">❌</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">武汉大学</td>
<td align="left">计算机学院</td>
<td align="center">❌</td>
<td align="center"></td>
<td align="left">保底用，没让入营，是我高攀不起了</td>
</tr>
<tr>
<td align="left">南京大学</td>
<td align="left">软件学院</td>
<td align="center">❌</td>
<td align="center"></td>
<td align="left">夏令营的唯一目标，一直做准备，没想到机会都不给</td>
</tr>
</tbody></table>
<h2 id="参营记录"><a href="#参营记录" class="headerlink" title="参营记录"></a><strong>参营记录</strong></h2><h3 id="1-西安交通大学-软件学院"><a href="#1-西安交通大学-软件学院" class="headerlink" title="1. 西安交通大学 软件学院"></a><strong>1. 西安交通大学 软件学院</strong></h3><p>本来想用西交计院来保底用，但是室友告知才发现计院这次夏令营不发offer，于是就报了软院。</p>
<p>我们院基本上报的都入营了，没啥悬念。</p>
<p>6.28 面试 5-10min吧</p>
<blockquote>
<ul>
<li>自我介绍 可用ppt 可以英文</li>
<li>有没有科研经历</li>
<li>喜欢科研还是工程</li>
<li>有没有考虑过留学（一个老师看我口语还行）</li>
<li>你的表达太口语化了，学术场景下不合适，希望你用英语多读读论文（另一个老师委婉地怼了我，于是事后我把自我介绍的措辞改了些）</li>
<li>你的父母是不是住在西安（自我介绍里提到了）</li>
</ul>
</blockquote>
<p>基本就是聊天，没拷打专业课，没啥压力。然后不出所料地拿到优营了，好像985的都是优营。</p>
<h3 id="2-中科大-先研院"><a href="#2-中科大-先研院" class="headerlink" title="2. 中科大 先研院"></a><strong>2. 中科大 先研院</strong></h3><p>本来也是用来保底的，听说是有手就行，但一年校内两年校外企业的模式不是很喜欢，感觉像卖身。而且当时一直在准备学院的实习答辩，就没准备，直接参加面试了。</p>
<p>7.22 面试 30min</p>
<p>先是让用英文做自我介绍，根据自我介绍问了两个英文问题。然后就是根据简历问问题，但是问得非常深，我九成的问题都回答不出来，对面的麦也非常糊，听不清声音，只能不停道歉。感觉是压力面，也可能是我太菜了。最后也不出所料地没有优营，虽然优营率超过90%。</p>
<p>暴死的原因很简单，就是没有好好准备简历，写得天花乱坠，实际上每一行我都讲不出什么东西。简历面可以是向老师疯狂输出的大好机会，但是准备不好的话就会像我一样给自己挖了一堆坑。</p>
<p>不过先研院的优营!&#x3D;offer，还需要找到愿意收自己的导师才行，发的优营数量远超过实际offer数量，要留个心眼。</p>
<p>对了先研院入营之后给每个人都邮递了大礼包，还挺感动的，虽然我不去hhhh</p>
<p><img src="/2022/12/02/2022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86%EF%BC%9A%E6%9C%AB%E4%B9%9D6-%E7%9A%84%E5%A4%B4%E9%93%81%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%B5%99%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%AD%A6%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%85%88%E7%A0%94%E9%99%A2%E3%80%81%E8%A5%BF%E4%BA%A4%E8%BD%AF%E9%99%A2%EF%BC%89/bigpack.jpg" alt="先研院大礼包"></p>
<h3 id="3-南京大学-软件学院"><a href="#3-南京大学-软件学院" class="headerlink" title="3. 南京大学 软件学院"></a><strong>3. 南京大学 软件学院</strong></h3><p>虽然营都没入，但拿出来说说。</p>
<p>因为我本身是工作导向，以后整个后端就差不多了，科研什么的完全不想搞。</p>
<p>结合往年类似排名的学长去向，南软就是我唯一的理想去处，离家还近，梦校！</p>
<p>所以夏令营期间的计划就是直接拿下南软，然后开始躺平到928。</p>
<p>但是现实狠狠地砸烂了我的如意算盘。南软直接没让我入营。明明南计都放了排名比我低的同学入营了。我为了防止南计先让我入营，还特地没报南计。看来是我会错意了。</p>
<p>虽然我当时没联系南软的导师，但是绿群里好多陶瓷了导师的也没入营（关于南软需不需要联系导师其实很有文章，后面会说）</p>
<p>而且后来研究了下才发现，那些我以为和我排名相同去了南软的学长，实际上人家前五学期的排名高多了，夏令营直接上岸了南软，然后前六学期的排名才掉到和我一样的（流汗黄豆</p>
<h3 id="4-南京大学-计算机学院"><a href="#4-南京大学-计算机学院" class="headerlink" title="4. 南京大学 计算机学院"></a><strong>4. 南京大学 计算机学院</strong></h3><p>没报，但也拿出来说说。</p>
<p>南大的计院和软院的招生政策可以说是完全不同。</p>
<p>总结一下就是：南计入营容易拿offer难，南软入营难拿offer容易。</p>
<p>南计在夏令营的时候会用海王营放一大堆人进来，给每个人机会。然后通过一个超难的机考来筛人。如果想去南计的话，请确保自己在夏令营的时候就把所有的基础知识复习完毕。排名低但是基础功扎实去了南计的例子是存在的。</p>
<p>我在夏令营的时候一直在整课设，完全没复习，所以不敢挑战。</p>
<p>虽然但是，从最后的去向图来看，排名高的去南大的，基本都是计院；排名低的去南大的，基本都是软院。</p>
<h2 id="夏令营总结"><a href="#夏令营总结" class="headerlink" title="夏令营总结"></a><strong>夏令营总结</strong></h2><p>夏令营期间高估了自己，眼高手低，以为自己能直接上岸南软所以就没有海投。</p>
<p>但是最后只拿到了一个西交软offer。一些本可以在夏令营期间拿到的不错的中九offer，也因为完全没报，所以没拿到。比如华科和中山那些。</p>
<p>接下来就是两个月的专业课复习time了，然后全力冲刺预推免</p>
<h1 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a><strong>预推免</strong></h1><h2 id="申请情况-1"><a href="#申请情况-1" class="headerlink" title="申请情况"></a><strong>申请情况</strong></h2><table>
<thead>
<tr>
<th align="left">学校</th>
<th align="left">院系</th>
<th align="center">入营</th>
<th align="center">结果</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">浙江大学</td>
<td align="left">软件学院</td>
<td align="center">✅</td>
<td align="center">优营</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">南京大学</td>
<td align="left">软件学院</td>
<td align="center">✅</td>
<td align="center">优营</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">武汉大学</td>
<td align="left">计算机学院</td>
<td align="center">✅</td>
<td align="center">候补</td>
<td align="left">bar比夏令营时候低了，不过大家都是候补</td>
</tr>
<tr>
<td align="left">华中科技大学</td>
<td align="left">计算机学院</td>
<td align="center">❌</td>
<td align="center"></td>
<td align="left">可能预推免期间不怎么招人了</td>
</tr>
<tr>
<td align="left">哈尔滨工业大学(深圳)</td>
<td align="left">计算机学院</td>
<td align="center">❌</td>
<td align="center"></td>
<td align="left">招的人太少了，感觉bar已经到top2级别了</td>
</tr>
</tbody></table>
<h2 id="参营记录-1"><a href="#参营记录-1" class="headerlink" title="参营记录"></a><strong>参营记录</strong></h2><h3 id="1-浙江大学-软件学院"><a href="#1-浙江大学-软件学院" class="headerlink" title="1. 浙江大学 软件学院"></a><strong>1. 浙江大学 软件学院</strong></h3><p>自从被南软背刺，浙软就是我的新欢。</p>
<p>整个预推免期间都是按照浙软来准备的。</p>
<p>入营倒是很容易，我们院的保研边缘人都入营了。不过分为软件工程和人工智能两个专业，人工智能招的人很少，软工180，AI30。但是发现大家竟然都去梭哈人工智能了，导致人工智能的报录比比软件工程高不少。我报的就是软件工程，那没事了。</p>
<p>浙软的考核包括机试+面试，说是 机考*0.85+面试*0.15，但是只要机考不拉跨，基本就稳了</p>
<p><strong>机试 9.19</strong></p>
<p>用的平台是PTA，四道题，中文题目，三个小时，时间还算够用。</p>
<p>总共参加726人，我考了88，rk 104，不算高，但也够用了。</p>
<p>我当时是准备的方法是刷了很多PAT真题，但PAT是陈越姥姥出的，题目英文。浙软机考现在换了出题人，题目变成了中文，出题风格也变了。</p>
<p>这次的题目考察重点不是纯数据结构知识，都和数学沾点边，一堆处理分数和素数之类的。我数学也不咋地，没想出啥高效解法，就用暴力做了。只能说我刷了那么多PAT，虽然用处不是很大，但也打了点底子吧。</p>
<p><strong>面试 9.23</strong></p>
<p>好像是20min-30min，不过这次准备得很充分，所以感觉时间过得很快。</p>
<p>首先是个人陈述5-8min，其中包含1min的英文内容。可以用PPT。</p>
<p>没有英文提问。</p>
<p>自我介绍完后问了我点项目的问题。</p>
<p>专业课方面问了数据结构的哈夫曼编码和操作系统的内存管理方式。</p>
<p>数学方面问了下面的问题</p>
<blockquote>
<p>拉格朗日中值定理是什么</p>
<p>特征值为0，和矩阵的秩有什么关系</p>
</blockquote>
<p>我第一个直接说不会，然后换成了第二个，第二个我想都没想直接说不会hhh</p>
<p>其实我知道浙软的面试一定会问点数学问题，线性代数我也复习了点，其实第二道题面试结束我就想到答案了。但是出于对数学的恐惧我直接说了不会hhhh。然后老师也就没再问我数学问题了。</p>
<p>剩下的时间又问了我点项目上的东西就结束了。</p>
<p><strong>结果</strong></p>
<p>9.26 录取名单出了，我排69&#x2F;180，算是通过两个月的努力凭本事拿到的offer。</p>
<p>替补也给了180个，928的时候差点就穿了，不过还没穿。</p>
<p>浙软可以说只要用心准备都能拿到offer，很给面子。效率也很高，各种名单出的很快，很透明。</p>
<h3 id="2-南京大学-软件学院"><a href="#2-南京大学-软件学院" class="headerlink" title="2. 南京大学 软件学院"></a><strong>2. 南京大学 软件学院</strong></h3><p>南软我又来辣</p>
<p>夏令营发现自己没入营之后我就开始去陶瓷导师了。当时其实非常讨厌陶瓷，一是陶瓷了也可能不去，不好意思鸽老师；二是我没啥科研经历，自己都不认为会有老师愿意收我。</p>
<p>于是就只陶瓷了南软的一个导师，但没想到上来拐弯抹角了会后就问我能不能直博，我直接拒绝了，然后我就以为黄了。之后也没管过了，伤透了心，一心研究浙软。</p>
<p>没想到两个月后南软的导师问我报名了没，我就说报了，其实我当时能不能入南软营都无所谓了，心想你难道还能把我捞进去不成？</p>
<p>然后导师就真的一声不吭地把我捞入营了，排名比我高的都没入。我tm直接黑人问号，不是说南软导师没法捞人吗。</p>
<p>之前有的学长说需要陶瓷，有的说不用陶瓷。现在我才懂了，南软是半强com，导师有推荐名额，能保入营，但拿offer看自己本事。所以陶瓷了也没入营的可能是导师不乐意捞。</p>
<p><strong>考核</strong></p>
<p>南软的考核也分笔试和面试，但没公布分数组成。</p>
<p><strong>笔试 9.20</strong></p>
<p><em>每年可能都不一样，我说的仅仅是当年情况</em></p>
<p>预推免时考的都是选择题，和夏令营时考的内容不一样。</p>
<p>这次的内容全是程序基础题，看代码选运行结果，需要对语法和特性很熟悉，一半C++，一半Java，最后还有一些软件工程题。</p>
<p>半个小时30题吧，时间够了。</p>
<p>考完看不到分数，不知道考得咋样。</p>
<p><strong>面试 9.21</strong></p>
<p>笔试通过的会发邮件让参加面试，面试里要求不准说出字记得姓名和学校。</p>
<p>我的情况比较奇葩，遇到的老师比较水。</p>
<p>上来让我自我介绍，不需要PPT。可能我讲的时间有点长，讲完之后，就告诉我可以了结束了，总耗时差不多5min。</p>
<p>我愣了下，问 “这就结束了吗？可以退出会议了？”，答复是 yes。然后就懵逼地退出了会议。</p>
<p>事后问了其他人，有的组是被狠狠拷打了。所以当时我很忐忑，不知道自己到底是稳了还是寄了。</p>
<p><strong>结果</strong></p>
<p>9.23 收到了预推免结果为优秀的短信，但当时非常怀疑，害怕这个优秀也得排在夏令营优秀后面的wl里。因为wl非常麻烦，不公布名单，要不停联系教务处问排名才能知道自己能不能被录取。</p>
<p>9.26 南软发了预录取的邮件，这下心里的石头终于落下了。</p>
<p>自我感觉能拿下南软的offer纯属运气，之前准备的那么多东西在面南软的时候也没用上。而且南软的考核真的纯纯黑盒，连个群都没拉，只通过短信和邮件通知，跟搞黑幕一样。不过我是既得利益者，不好说啥(</p>
<h3 id="3-武汉大学-计算机学院"><a href="#3-武汉大学-计算机学院" class="headerlink" title="3. 武汉大学 计算机学院"></a><strong>3. 武汉大学 计算机学院</strong></h3><p>武大计算机夏令营的时候bar挺高，没让我进。不过预推免倒让我进了。</p>
<p>武大我其实不太感冒，因为不是太面向就业。我当时想的是要不浙软南软，要不就去西交找个羊导，破釜沉舟了属于是。</p>
<p>反正也是保底，就当作给浙软南软的面试当排练了。</p>
<p>武大的考核只有面试</p>
<p>9.22面的，15min，1-2min的自我介绍。</p>
<p>然后就是一些比较抽象的问题：</p>
<blockquote>
<p>为什么想来武汉大学（英文问题）</p>
<p>介绍自己的项目</p>
<p>研究生阶段和本科阶段学习的区别</p>
<p>落地和不落地项目的区别</p>
<p>自己的性格</p>
</blockquote>
<p>没怎么问专业课，都是这种开放问题，这种问题我也不太会编，回答得不咋地。</p>
<p><strong>结果</strong></p>
<p>9.23 出了预推免的名单，我排前一半，不咋地，不过超过了不少武大本校✌是没想到的。</p>
<p>后来听说大家都是候补，而且因为名额缩减，夏令营的优营都不知道能不能录完。</p>
<p>反正我也不去武大，就直接放弃了。</p>
<h1 id="最终去向"><a href="#最终去向" class="headerlink" title="最终去向"></a><strong>最终去向</strong></h1><p>主要就是纠结去浙软还是去南软了。</p>
<p>其实也没啥好纠结的。</p>
<ul>
<li>我本来就是江苏人，南大离得近，放假能回家</li>
<li>南软两年，浙软两年半，南软能更早出去赚钱</li>
<li>南软放实习，浙软平时不放，最后的半年可以自由实习</li>
<li>南软在南京市区，浙软在宁波，没啥浙大归属感</li>
<li>南软有个不嫌弃我还捞我的导师</li>
</ul>
<p>就我个人而言，南软除了title比浙软小一点，其他所有方面我都很满意。</p>
<p>虽然大一的时候我墙上贴的是浙大，但最后还是去南软辣。</p>
<p><img src="/2022/12/02/2022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86%EF%BC%9A%E6%9C%AB%E4%B9%9D6-%E7%9A%84%E5%A4%B4%E9%93%81%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%B5%99%E5%A4%A7%E8%BD%AF%E9%99%A2%E3%80%81%E6%AD%A6%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%85%88%E7%A0%94%E9%99%A2%E3%80%81%E8%A5%BF%E4%BA%A4%E8%BD%AF%E9%99%A2%EF%BC%89/result.png" alt="保研结果"></p>
]]></content>
      <tags>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux从入门到精通》笔记 第10章 进程管理</title>
    <url>/2023/11/26/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC10%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><strong>快速上手：结束一个失控的程序</strong></p>
<ul>
<li><code>./badpro &amp;</code><ul>
<li>后台执行当前目录的badpro可执行文件</li>
</ul>
</li>
<li><code>ps aux | grep badpro</code><ul>
<li>在所有后台进程中寻找badpro</li>
</ul>
</li>
<li><code>kill 12974</code><ul>
<li>杀死端口号为12974的进程</li>
</ul>
</li>
</ul>
<p><strong>什么是进程</strong></p>
<ul>
<li><strong>简介</strong><ul>
<li>进程是运行着的程序</li>
</ul>
</li>
<li><strong>进程的重要信息</strong><ul>
<li>内存地址</li>
<li>进程当前的状态</li>
<li>进程正在使用的资源</li>
<li>进程的优先级</li>
<li>进程的属主</li>
</ul>
</li>
</ul>
<p><strong>进程的常用属性</strong></p>
<ul>
<li><strong>PID：进程的ID号</strong><ul>
<li>在对进程进行操作时，使用的都是PID，而不是进程名</li>
</ul>
</li>
<li><strong>PPID</strong><ul>
<li>父进程的PID</li>
<li>Linux中所有的进程都由另一个进程创建</li>
<li>实际上子进程由父进程克隆而来</li>
</ul>
</li>
<li><strong>UID和EUID</strong><ul>
<li>真是和有效的用户ID</li>
<li>UID为进程属主</li>
<li>EUID为有效用户ID，一般情况下和用户ID相同</li>
</ul>
</li>
<li><strong>GID和EGID</strong><ul>
<li>真实和有效的组ID</li>
</ul>
</li>
<li><strong>谦让度和优先级</strong><ul>
<li>优先级越高越容易被执行</li>
<li>谦让度和优先级是相反的概念</li>
<li>用户只能够设置谦让度</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p><strong>监视进程：ps命令</strong></p>
<ul>
<li><strong>ps</strong><ul>
<li>显示前台所有的进程信息</li>
</ul>
</li>
<li><strong>ps aux</strong><ul>
<li>显示当前系统上所有的进程信息<br>   <img src="/2023/11/26/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC10%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image.png"></li>
</ul>
</li>
<li><strong>ps lax</strong><ul>
<li>可以在ps aux的基础上提供父进程PPID和谦让度NI</li>
<li>不会显示进程属主的用户名</li>
</ul>
</li>
</ul>
<p><strong>即时跟踪进程信息：top命令</strong></p>
<ul>
<li>ps可以给出当前系统中所有进程信息的快照，但是缺乏时效性</li>
<li><strong>top</strong><ul>
<li>可以实时跟踪当前系统中进程的情况</li>
<li>显示的信息会占满一页，每10s更新一次</li>
<li>可以显示cpu使用率、内存占用率等信息</li>
<li>按q退出监视程序</li>
</ul>
</li>
</ul>
<p><strong>查看占用文件的进程</strong></p>
<ul>
<li><strong>lsof 文件名</strong><ul>
<li>给出给出使用当前文件的进程的信息</li>
</ul>
</li>
</ul>
<p><strong>向进程发送信号：kill</strong></p>
<ul>
<li><strong>简介</strong><ul>
<li>kill命令可以杀死进程</li>
</ul>
</li>
<li><strong>kill标准语法</strong><ul>
<li>kill [-signal] pid</li>
</ul>
</li>
<li><strong>kill命令的常用signal</strong><ul>
<li>使用kill -l可以显示所有的signal<br>   <img src="/2023/11/26/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC10%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-1.png"></li>
</ul>
</li>
<li><strong>kill 12974</strong><ul>
<li>终止某个进程</li>
</ul>
</li>
<li><strong>Ctrl+C</strong><ul>
<li>等同于信号INT</li>
</ul>
</li>
<li><strong>sudo kill -KILL pid</strong><ul>
<li>-TERM只是向进程发送终止信号，进程可能忽略该信号</li>
<li>-KILL可以从内核级别杀死一个进程</li>
</ul>
</li>
</ul>
<p><strong>调整进程的谦让度：nice和renice</strong></p>
<ul>
<li><strong>nice</strong><ul>
<li><strong>简介</strong><ul>
<li>nice可以在程序启动的时候设置谦让度</li>
<li>谦让度越低优先级越高</li>
</ul>
</li>
<li><strong>使用例子</strong><ul>
<li>nice -n 2 bc<ul>
<li>以谦让度2启动bc</li>
</ul>
</li>
<li>sudo nice -n -3 bc<ul>
<li>以谦让度-3启动bc</li>
</ul>
</li>
<li>nice bc<ul>
<li>不加-n的话，无法指定谦让度，默认为10</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>renice</strong><ul>
<li><strong>简介</strong><ul>
<li>可以在程序运行时设置其谦让度</li>
</ul>
</li>
<li>renice +12 -p 8567<ul>
<li>通过-p指定进程的pid</li>
<li>将pid为8567的进程的谦让度设置为12</li>
</ul>
</li>
</ul>
</li>
<li><strong>现在设置谦让度没什么意义了，cpu会自动调度</strong></li>
</ul>
<p><strong>&#x2F;PROC文件系统</strong></p>
<ul>
<li><strong>简介</strong><ul>
<li>proc文件夹存放了和内核有关系统状态的信息</li>
<li>ps和top读取的就是&#x2F;proc文件夹中的信息</li>
</ul>
</li>
</ul>
<p><strong>小结</strong><br><img src="/2023/11/26/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC10%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-2.png"></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux从入门到精通》笔记 第5章 Shell基本命令</title>
    <url>/2023/11/12/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC5%E7%AB%A0%20Shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Shell 简介</strong></p>
<ul>
<li>命令行是输入命令的界面</li>
<li>Shell是命令解释器，是程序</li>
<li>Linux默认的Shell是 Bash Shell</li>
</ul>
<p><strong>输入输出约定</strong></p>
<ul>
<li><strong>提示符</strong><ul>
<li>输入行开头的 $ 或 # 表示提示符<ul>
<li>$表示普通身份</li>
<li>#表示root身份</li>
</ul>
</li>
</ul>
</li>
<li><strong>命令格式</strong><ul>
<li>提示符+命令+注释</li>
<li>注释 由”##”开头</li>
</ul>
</li>
</ul>
<p><strong>简单文件指令</strong></p>
<ul>
<li><strong>进入目录：</strong> cd+地址<ul>
<li>cd &#x2F; ：进入根目录</li>
<li>cd ：单独一个cd不带参数，进入home下的用户目录</li>
<li>cd &#x2F;地址：地址以斜杠开头，表示进入从根目录开始的完整地址</li>
</ul>
</li>
<li><strong>列出当前地址下的文件和目录：</strong> ls</li>
<li>**&#x2F;etc目录下存放了linux的配置文件</li>
</ul>
<span id="more"></span>

<p><strong>提高效率：使用命令行补全和通配符</strong></p>
<ul>
<li><strong>补全</strong><ul>
<li>单击 tap 可以补全命令或者文件名</li>
<li>双击 tap 可以显示当前输入开头的所有内容</li>
</ul>
</li>
<li><strong>通配符</strong><ul>
<li>“*”  表示一个或多个字符</li>
<li>“?” 匹配单个字符</li>
<li>“[abc]” 匹配 a或b或c，单个字符</li>
<li>“[1-3]” “[a-z]” 表示字符范围中的某个字符</li>
<li>ls 字符串表达式<ul>
<li>这样就可以列出符合条件的关键字</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>完整的查看目录和文件命令</strong></p>
<ul>
<li><strong>显示当前路径:</strong> pwd</li>
<li><strong>改变目录:</strong> cd<ul>
<li>cd &#x2F;：进入根目录</li>
<li>cd ..：返回上一层目录<ul>
<li>.. 表示上一层目录</li>
<li>. 表示当前目录</li>
</ul>
</li>
<li>cd 或 cd ~：回到用户主目录</li>
</ul>
</li>
<li><strong>列出目录内容：</strong> ls<ul>
<li>ls的语法格式： ls [optional] [file]</li>
<li>ls：不带参数<ul>
<li>列出所有的目录和文件</li>
<li>颜色，不同平台上颜色不一样<ul>
<li>目录 蓝色</li>
<li>普通文件 白色</li>
<li>链接文件（快捷方式） 青色</li>
<li>可执行文件 草绿色</li>
</ul>
</li>
</ul>
</li>
<li>ls -F<ul>
<li>通过后缀标明 文件类型</li>
<li>&#x2F; 文件夹</li>
<li>@ 链接文件</li>
<li><ul>
<li>可执行文件</li>
</ul>
</li>
</ul>
</li>
<li>-a <ul>
<li>显示所有的“.”开头的隐藏文件</li>
<li>-aF<ul>
<li>指定多个选项只需要一个横杠</li>
</ul>
</li>
</ul>
</li>
<li>-l<ul>
<li>显示文件的属性</li>
</ul>
</li>
<li>ls + 路径名<ul>
<li>可以查看指定路径中的文件</li>
</ul>
</li>
</ul>
</li>
<li><strong>列出目录内容：</strong> dir和vdir<ul>
<li>dir 等同于 ls，不过不显示颜色</li>
<li>vdir 等同于 ls -l，显示详细信息</li>
</ul>
</li>
<li><strong>查看文本文件：</strong> cat和more<ul>
<li>cat <ul>
<li>cat 文件名：查看文本文件</li>
<li>cat -n 文件名：查看的时候显示行号</li>
</ul>
</li>
<li>more<ul>
<li>more 文件名：一页一页查看文件</li>
<li>按空格翻动一页，按Enter翻动一行，按Q退出</li>
</ul>
</li>
</ul>
</li>
<li><strong>查看文件的开头和结尾：</strong> head和tail<ul>
<li>head<ul>
<li>head 文件名：简单查看文件开头</li>
<li>head -n 行数 文件名：指定查看文件的行数</li>
</ul>
</li>
<li>tail<ul>
<li>用法和head相同</li>
</ul>
</li>
</ul>
</li>
<li><strong>更好的文本阅读工具：</strong> less<ul>
<li>基础用法：less 文件名</li>
<li>移动方式<ul>
<li>可以通过方向键控制文档移动</li>
<li>空格 下一页，B 上一页，Q 退出</li>
</ul>
</li>
<li>字符串搜索<ul>
<li>按下&#x2F;，输入key，按回车</li>
<li>搜到的关键字会被高亮</li>
</ul>
</li>
<li>less -M 文件名<ul>
<li>可以在最后一行显示文件名，行数，百分比</li>
</ul>
</li>
</ul>
</li>
<li><strong>查找文件内容：</strong> grep<ul>
<li>基本用法<ul>
<li>grep [options] PATTERN [FILE…]</li>
<li>grep 可选项 ‘模式串’ 文件名</li>
</ul>
</li>
<li>例子<ul>
<li>grep un day</li>
<li>在day文件中 查找包含 un 的那行</li>
</ul>
</li>
<li>当模式串中包含空格时，需要用单引号括起来</li>
<li>模式串还可以使用正则表达式</li>
</ul>
</li>
</ul>
<p><strong>find命令</strong></p>
<ul>
<li><strong>基本语法</strong><ul>
<li>find [option] [path…] [expression]</li>
</ul>
</li>
<li>例子<ul>
<li>find &#x2F;usr&#x2F;bin&#x2F; -name zip -print<ul>
<li>&#x2F;usr&#x2F;bin&#x2F;： 指定路径范围<ul>
<li>如果搜索全路径，可以用 “&#x2F;”</li>
</ul>
</li>
<li>-name zip： 指定名称</li>
<li>-print：将结果打印到屏幕，这个不加实际上也没事</li>
</ul>
</li>
<li>find &#x2F;etc&#x2F; -name init.d -type d -print<ul>
<li>-type d：指定文件类型为d，也就是目录文件<br>  <img src="/2023/11/12/%E3%80%8ALinux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC5%E7%AB%A0%20Shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image.png"></li>
</ul>
</li>
</ul>
</li>
<li>-atime +n<ul>
<li>最后一次使用在n天之前的文件</li>
</ul>
</li>
<li>-mtime +n<ul>
<li>最后一次修改在n天之前的文件</li>
</ul>
</li>
</ul>
<p><strong>更快速地定位文件 locate命令</strong></p>
<ul>
<li><strong>基本用法</strong><ul>
<li>locate [pattern]</li>
</ul>
</li>
<li>例子<ul>
<li>locate *.doc</li>
<li>直接找到所有类型为doc的文件</li>
<li>支持正则表达式</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>比起find方便多了，不需要太多的参数</li>
<li>并且更快，因为locate查询的是文件名数据库，不是文件目录</li>
<li>可以通过 updatedb手动更新数据库</li>
</ul>
</li>
<li><strong>依赖</strong><ul>
<li>sudo apt install mlocate</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>如果查的是新文件，那么每次查询前需手动 updatedb</li>
</ul>
</li>
</ul>
<p><strong>从终端运行程序</strong></p>
<ul>
<li><strong>使用方式</strong><ul>
<li>直接输入应用的名字</li>
<li>比如 $ firefox</li>
<li>如果运行当前目录中的文件，则需要 “.&#x2F;可执行文件名”</li>
</ul>
</li>
<li>$ firefox：前台打开firefox，并且关闭之后才能从控制台输入新的指令</li>
<li>$ firefox &amp;：后台打开firefox，此时可以正常输入指令</li>
<li>$ kill 12876：关闭端口号为12806的进程</li>
</ul>
<p><strong>查找特定程序 whereis</strong></p>
<ul>
<li><strong>whereis find</strong><ul>
<li>查找find程序的可执行文件位置 和  手册页存放位置</li>
</ul>
</li>
<li><strong>whereis -b find</strong><ul>
<li>查找find程序的二进制可执行文件</li>
</ul>
</li>
</ul>
<p><strong>用户及版本信息查看</strong></p>
<ul>
<li><strong>who</strong><ul>
<li>当前系统有哪些人登录</li>
</ul>
</li>
<li><strong>whoami</strong><ul>
<li>察看自己的身份</li>
</ul>
</li>
<li><strong>uname -a</strong><ul>
<li>给出操作系统所有信息</li>
</ul>
</li>
<li><strong>uname -r</strong><ul>
<li>给出内核版本信息</li>
</ul>
</li>
</ul>
<p><strong>寻求帮助 man命令</strong></p>
<ul>
<li><strong>man 命令名称</strong><ul>
<li>给出命令的详细帮助信息</li>
<li>实际上用的是less指令</li>
<li>j向上，k向下，或者用方向键也行</li>
<li>空格下一页，b上一页</li>
</ul>
</li>
</ul>
<p><strong>获取命令简介，whatis和apropos</strong></p>
<ul>
<li><strong>whatis find</strong><ul>
<li>给出find命令的简介，一句话</li>
</ul>
</li>
<li><strong>apropos search</strong><ul>
<li>给出与search相关的所有命令</li>
<li>属于用功能反推出命令</li>
</ul>
</li>
</ul>
<p><strong>小结</strong></p>
<ol>
<li>pwd 显示当前目录</li>
<li>cd 切换目录</li>
<li>ls 查看目录</li>
<li>find和locate可以查找文件和目录</li>
<li>grep可以查找文件内的内容</li>
<li>less 查看文件直接用这个就行</li>
<li>whereis 可以查找程序文件的位置</li>
<li>man 查看程序的详细帮助</li>
<li>whatis 查看程序的简要说明</li>
<li>apropos 通过功能查找指定的程序</li>
</ol>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第一章</title>
    <url>/2023/03/16/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/</url>
    <content><![CDATA[<h1 id="重新认识MySQL"><a href="#重新认识MySQL" class="headerlink" title="重新认识MySQL"></a><strong>重新认识MySQL</strong></h1><pre><code>1 MySQL的客户端/服务器架构
    a. 服务器处理存储的数据，客户端发出增删改查的请求
    b. 服务器进程的名称为mysqld
    c. 客户端进程的名称为mysql
2. MySQL的安装
    a. bin目录下的可执行文件
        i. MySQL的安装目录下有一个bin文件夹，有很多可执行文件
    b. 运行bin目录下的mysqld就可以开启mysql服务器
        i. 环境变量PATH
            1) 环境变量是一系列地址的集合，通过冒号隔开
            2) 指定了环境变量之后，输入命令的时候就会从环境变量的地址中找有没有这个命令
            3) 就不需要每次都到MySQL的目录下去执行命令了
</code></pre>
<span id="more"></span>
<pre><code>3. 启动MySQL服务器程序
    a. UNIX
        i. mysqld
        ii. mysqld_safe
        iii. mysql.server
        iv. mysql_multi
        v. 自己看详细区别，启动的时候查手册就行
    b. Windows
        i. mysqld
            1) 直接双击就能启动了
            2) 或者把mysqld注册为windows服务
                a) 需要长时间使用的程序都可以注册为服务
                b) 注册为服务的指令
                    i) &quot;文件的完整路径&quot; --install [-manual] [服务名]
            3) 然后通过net start MySQL来启动服务
            4) 用stop来停止服务
4. 启动MySQL客户端程序
    a. 连接方法
        i. 执行mysql文件就行
        ii. mysql -h主机名 -u用户名 -p密码
            1) mysql -hlocalhost -uroot -p123456
            2) -P 大写的P参数可以用来指定端口号
        iii. 小注意：
            3) 对于-h -u -p这种只有一个字母的参数，前面加一个dash
            4) 对于--password这种长参数，前面就需要加两个dash
    b. 断开连接并且关闭mysql客户端的方法
        i. 三种
            5) quit
            6) exit
            7) \q
        ii. 输出Bye时，就说明关闭成功了
        iii. 但是只是关闭了客户端程序，服务端程序并没有关闭
    c. 注意点
        i. 可以-p后面不加密码，然后会单独要求输入密码，更安全
        ii. 如果想在-p后面加密码，就注意和密码之间不能有空格
        iii. 如果客户端和服务端在同一台机器上，就可以省略 -h参数
        iv. 如果使用linux，可以省略-u参数，会自动使用linux的用户名
5. 客户端与服务器连接的过程
    本质就是进程的通信
    a. TCP/IP
        i. 一般服务器和客户端之间使用TCP连接
        ii. 服务器默认申请3306端口号
        iii. mysqld -P3307
            1) 可以在启动的时候指定申请的端口号
    b. 命名管道和共享内存
        i. 这两种都是windows提供的进程间通信方式
        ii. mysql可以用这种方式连接同一主机的进程
    c. Unix域套接字文件
        i. 也就是socket文件，linux里万物皆文件
        ii. 使用linux的话，如果客户端和服务端在同一台主机上
            2) 那么就可以使用linux套接字文件进行连接
6. 服务端处理请求的流程
    a. 简介
        i. 
</code></pre>
<p><img src="/image.png"></p>
<pre><code>    b. 连接管理
        i. 会给每个客户端都分配一个线程
            1) 因此会用到线程池，复用线程
        ii. 还能使用SSL来增强连接的安全性
    c. 解析和优化
        i. 简介
            2) mysql服务器获得文本形式的请求后，会进行 查询缓存、语法解析和查询优化
        ii. 查询缓存
            3) 只有查询语句一模一样时，才会命中缓存
                a) 只要有一点改变都不会命中
            4) 调用系统函数或者查询系统的表时，不会缓存请求
                a) 因为每次调用返回的值都有可能不同
            5) 当表被更新时，涉及到该表的缓存会立刻失效
            6) 因为维护缓存比较麻烦，所以MySQL8.0的时候就把查询缓存给删了
        iii. 语法解析
            7) 缓存未命中之后，就进行语法解析
            8) 判断sql语句语法是否正确
            9) 然后进行编译
        iv. 查询优化
            10) 服务器会对我们写SQL语句进行优化，提高执行效率
            11) 使用Explain就可以查看语句的执行计划
    d. 存储引擎
        i. mysql把对于数据的存储和读取都封装到了存储引擎中
            12) 前面的连接管理 解析和优化其实并不涉及到数据
        ii. 存储引擎负责数据的存储和读取
        iii. MySQL server完成了查询优化之后，只需要调用存储引擎提供的API就行了
7. 常用存储引擎
    a. 有很多不同的存储引擎
    b. 其实最常用的就是InnoDB和MyISAM
        i. 一个支持事务和外键，一个不支持
        ii. 后面有详细讲解
8. 关于存储引擎的操作
    a. 查看当前支持的存储引擎
        i. SHOW ENGINES;
    b. 设置表的存储引擎
        i. 可以给不同的表设置不同的存储引擎
        ii. 默认使用InnoDB
        iii. 创建表时指定存储引擎
</code></pre>
<p> <img src="/image-1.png"></p>
<pre><code>        iv. 修改表的存储引擎
</code></pre>
<p><img src="/image-2.png"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第七章 B+树索引的使用注意点</title>
    <url>/2023/03/20/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%83%E7%AB%A0%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<h2 id="7-1-索引的代价"><a href="#7-1-索引的代价" class="headerlink" title="7.1 索引的代价"></a>7.1 索引的代价</h2><ol>
<li><strong>索引虽然快，但在时间和空间上都有代价</strong>：<ul>
<li><strong>空间代价</strong>：<ol>
<li>B+树的每个节点都是一个数据页，一个页默认占用16KB，因此会有不少开销。</li>
</ol>
</li>
<li><strong>时间代价</strong>：<ol>
<li>对数据进行增删改操作后，需要对每个索引进行维护。</li>
<li>建立的索引越多，维护的开销也越大。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="7-2-B-树适用的条件（什么样的查询能够走索引）"><a href="#7-2-B-树适用的条件（什么样的查询能够走索引）" class="headerlink" title="7.2 B+树适用的条件（什么样的查询能够走索引）"></a>7.2 B+树适用的条件（什么样的查询能够走索引）</h2><ol>
<li><strong>简介</strong>：<ul>
<li>B+树并非万能，并不是所有的查询都可以走索引。</li>
<li>仅适用于几种特定的查询情况。 <span id="more"></span></li>
</ul>
</li>
<li><strong>全值匹配</strong>：<ul>
<li><strong>介绍</strong>：<ol>
<li>如果搜索条件中使用的字段与索引用到的字段完全一致，就是全值匹配。</li>
<li>对于联合索引，搜索时需要用到所有联合索引的字段。</li>
</ol>
</li>
<li><strong>问题</strong>：<ol>
<li>字段的顺序对查询是否有影响？<ul>
<li>无影响，查询优化器会自动优化，调整为联合索引的顺序。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>匹配左边的列</strong>：<ul>
<li>当使用联合索引进行查询时，可以使用索引左边连续的几个字段，仍能走索引。</li>
<li>如果跳过左边的字段，只用右边字段查询，则无法走索引。</li>
</ul>
</li>
<li><strong>匹配列前缀</strong>：<ul>
<li>对于字符串类型的字段，可以用前缀进行查询。</li>
<li>例如：<code>SELECT * FROM person_info WHERE name LIKE &#39;As%&#39;;</code>，因为字符串是按字典序排序的，所以可以走索引。</li>
<li><strong>中缀和后缀匹配无法走索引</strong>，只能全表扫描。例如：<code>SELECT * FROM person_info WHERE name LIKE &#39;%As%&#39;;</code>。</li>
<li><strong>后缀匹配想用索引</strong>的话，可以将所有数据逆序存储，使后缀变为前缀。</li>
</ul>
</li>
<li><strong>匹配范围值</strong>：<ul>
<li>B+树索引的记录是按索引字段排序的，可以轻松实现范围查询。</li>
<li><strong>联合索引范围查询</strong>时，只能使用最左边的字段走索引，其他字段需要逐个过滤。</li>
</ul>
</li>
<li><strong>精确匹配某一列并范围匹配另一列</strong>：<ul>
<li>对联合索引使用范围查询时，如果左边字段相同，右边字段可以走索引。</li>
</ul>
</li>
<li><strong>用于排序</strong>：<ul>
<li><strong>介绍</strong>：<ol>
<li>查询时如果使用 <code>ORDER BY</code> 子句，需要对指定字段排序。</li>
<li>如果 <code>ORDER BY</code> 使用的是索引字段，则可以省去排序过程。</li>
</ol>
</li>
<li><strong>联合索引排序注意事项</strong>：<ol>
<li><code>ORDER BY</code> 字段顺序必须与联合索引的字段顺序一致，否则无法走索引。</li>
<li>如果 <code>ORDER BY</code> 中混用了 <code>ASC</code> 和 <code>DESC</code>，则无法使用索引。</li>
<li><code>WHERE</code> 子句中的字段必须包含在索引字段中，否则也无法走索引。</li>
</ol>
</li>
<li><strong>无法使用索引进行排序的情况</strong>：<ol>
<li><code>ORDER BY</code> 中的字段属于不同索引。</li>
<li><code>ORDER BY</code> 中的字段使用了复杂表达式，例如：<code>SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong>用于分组</strong>：<ul>
<li>如果 <code>GROUP BY</code> 使用的字段与索引字段一致，分组查询时相当于已经分好组。例如：<code>SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number;</code>。</li>
</ul>
</li>
</ol>
<h2 id="7-3-回表的代价"><a href="#7-3-回表的代价" class="headerlink" title="7.3 回表的代价"></a>7.3 回表的代价</h2><ol>
<li><strong>二级索引范围查找</strong>：<ul>
<li>二级索引查找后得到一系列主键，需要通过主键到聚集索引查找完整用户记录。</li>
<li><strong>顺序IO</strong>：二级索引查找时使用，速度较快。</li>
<li><strong>随机IO</strong>：聚集索引查找时使用，速度较慢。</li>
</ul>
</li>
<li><strong>回表记录越多，二级索引效率越低</strong>：<ul>
<li>当回表记录多时，二级索引效率不如直接全表扫描。</li>
</ul>
</li>
<li><strong>查询优化器的选择</strong>：<ul>
<li>查询的记录较少时，使用二级索引+回表。</li>
<li>记录较多时，直接全表扫描。</li>
</ul>
</li>
<li><strong>覆盖索引</strong>：<ul>
<li>在 <code>SELECT</code> 子句中只使用索引字段，可以避免回表操作。</li>
</ul>
</li>
</ol>
<h2 id="7-4-如何挑选索引"><a href="#7-4-如何挑选索引" class="headerlink" title="7.4 如何挑选索引"></a>7.4 如何挑选索引</h2><ol>
<li>只为用于搜索、排序、分组的字段建立索引。<ul>
<li><code>WHERE</code> 子句、<code>ORDER BY</code> 子句和 <code>GROUP BY</code> 子句中的字段需要建立索引，<code>SELECT</code> 子句中的字段不需要建立索引。</li>
</ul>
</li>
<li><strong>考虑列的基数</strong>：<ul>
<li>列的基数指的是不重复数据的数量。</li>
<li>基数大的字段适合建立索引，因为基数小的字段重复值较多，建立索引意义不大。</li>
</ul>
</li>
<li><strong>索引字段的类型尽量小</strong>：<ul>
<li>能用 <code>INT</code> 就不要用 <code>BIGINT</code>，因为：<ol>
<li>数据类型小，比较操作更快。</li>
<li>数据类型小，索引占用空间更少，读取的记录更多。</li>
</ol>
</li>
</ul>
</li>
<li><strong>索引字符串的前缀</strong>：<ul>
<li>针对字符串类型的字段，可以只使用前缀建立索引。</li>
<li><strong>前缀索引的缺点</strong>：字段不完全有序，<code>ORDER BY</code> 只能使用文件排序。</li>
</ul>
</li>
<li><strong>索引字段必须单独出现在比较表达式中</strong>：<ul>
<li>例如：<ul>
<li><code>WHERE my_col * 2 &lt; 4</code> 无法走索引。</li>
<li><code>WHERE my_col &lt; 4 / 2</code> 可以走索引。</li>
</ul>
</li>
<li><strong>结论</strong>：索引字段必须单独出现在表达式中，不能使用嵌套表达式或函数调用。</li>
</ul>
</li>
<li><strong>主键插入顺序</strong>：<ul>
<li>新插入的记录如果主键不是最大的，会导致页面分裂和记录移位，从而影响性能。</li>
<li><strong>解决办法</strong>：使用自增主键，在字段后加 <code>AUTO_INCREMENT</code>。</li>
</ul>
</li>
<li><strong>避免冗余和重复索引</strong>：<ul>
<li>不要给同一个字段建立多个索引，例如 <code>UNIQUE</code> 关键字会自动建立索引。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第三章 字符集和比较规则</title>
    <url>/2023/03/16/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<ol>
<li><p><strong>字符集和比较规则简介</strong></p>
<ul>
<li><strong>字符集简介</strong><ul>
<li>字符集负责处理字符与二进制数据的存储关系</li>
</ul>
</li>
<li><strong>比较规则</strong><ul>
<li>字典序也就是比较他们二进制的大小</li>
<li>除了字典序外也有其他的比较规则</li>
</ul>
</li>
<li><strong>重要的字符集</strong><ul>
<li><strong>ASCII</strong><ol>
<li>128个字符，包括数字、大小写字母、空格等等</li>
<li>每个字符一个字节</li>
</ol>
</li>
<li><strong>GB2132</strong><ol>
<li>包括中文和其他国家的字符</li>
<li>存在于ASCII中的字符用1个字节存储</li>
<li>其余的字符用2个字节存储</li>
<li>也就是变长存储方式</li>
</ol>
</li>
<li><strong>GBK</strong><ol>
<li>对于GB2132的字符收集范围做了补充，其余一样</li>
</ol>
</li>
<li><strong>Unicode系列</strong><ol>
<li>对地球上所有的字符进行了收录，同样是变长编码</li>
<li><strong>utf-8</strong><ul>
<li>1-4个字节存储字符</li>
</ul>
</li>
<li><strong>utf-16</strong><ul>
<li>2或4个字节存储字符</li>
</ul>
</li>
<li><strong>utf-32</strong><ul>
<li>全用4字节存</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>MySQL支持的字符集</strong></p>
 <span id="more"></span>
<ul>
<li><strong>utf8和utf-8mb4</strong><ul>
<li><strong>utf8</strong><ol>
<li>utf8mb3的别名，依旧用1-3个字节存储字符</li>
</ol>
</li>
<li><strong>utf8mb3</strong><ol>
<li>是阉割版，用1-3个字节存储字符</li>
</ol>
</li>
<li><strong>utf8mb4</strong><ol>
<li>完整版，用1-4个字节存储字符</li>
<li>如果要存储更完整的数据的话就用这个，比如emoji表情</li>
</ol>
</li>
</ul>
</li>
<li><strong>字符集的查看</strong><ul>
<li>使用<code>SHOW CHARACTER SET</code>命令，可以指定匹配的模式</li>
</ul>
</li>
<li><strong>比较规则的查看</strong><ul>
<li>使用<code>SHOW COLLATION</code>命令，可以指定匹配的模式</li>
<li>每种语言都有多个比较规则</li>
<li>还会有个默认的比较规则<ol>
<li>比如utf8的默认比较规则就是utf8_general_ci</li>
<li>ci是case insensitive</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字符集和比较规则的应用</strong></p>
<ul>
<li><strong>各级别的字符集和比较规则</strong><ul>
<li>字符集的级别分为<ol>
<li>服务器级别</li>
<li>数据库级别</li>
<li>表级别</li>
<li>列级别</li>
</ol>
</li>
</ul>
</li>
<li><strong>客户端和服务器通信中的字符集</strong><ul>
<li>客户端和服务器通信时需要进行字符集的转换</li>
<li>因为转换来转换去容易出错，所以一般通知设置为一样的字符集</li>
</ul>
</li>
<li><strong>比较规则的应用</strong><ul>
<li>如果发现按列排序后不是自己想要的顺序</li>
<li>就可以考虑下更改比较规则</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第九章 InnoDB表空间详解</title>
    <url>/2023/03/22/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B9%9D%E7%AB%A0%20InnoDB%E8%A1%A8%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>表空间是一个抽象的概念，对应文件系统中一个或多个实际文件。每个独立表空间都对应一个 <code>.ibd</code> 文件。表空间由页组成，插入记录时是从表空间中拿出一个页来写入。本章会讲解表空间的细节。</p>
<h2 id="9-1-回忆一些旧知识"><a href="#9-1-回忆一些旧知识" class="headerlink" title="9.1 回忆一些旧知识"></a>9.1 回忆一些旧知识</h2><ol>
<li><strong>页面类型</strong>：<ul>
<li>InnoDB 以页为单位管理存储空间。</li>
<li>数据页的类型名为 <code>FIL_PAGE_INDEX</code>。</li>
</ul>
</li>
<li><strong>页面通用部分</strong>：<ul>
<li>所有页面都有两个通用部分：<code>File Header</code> 和 <code>File Trailer</code>。</li>
<li><code>File Header</code> 记录页面相关信息，如页号、页类型、上一页、下一页、校验和等。</li>
<li><code>File Trailer</code> 主要用于校验页面的完整性，防止断电导致页面更新不完整。</li>
<li><strong>File Header的部分信息</strong>：<ol>
<li><code>FIL_PAGE_OFFSET</code>：即页号，有4个字节，最多支持2^32个页，意味着表空间最多可支持64TB的数据。</li>
<li><code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code>：存储前后页号，形成双向链表，主要用于 <code>INDEX</code> 类型的页面。</li>
<li><code>FIL_PAGE_TYPE</code>：页面类型。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="9-2-独立表空间结构"><a href="#9-2-独立表空间结构" class="headerlink" title="9.2 独立表空间结构"></a>9.2 独立表空间结构</h2><p>本节主要讲解系统表空间和独立表空间的结构。系统表空间较为复杂，因此先从系统表空间开始。</p>
<ol>
<li><strong>区 (Extent) 的概念</strong>：<ul>
<li><strong>简介</strong>：<ol>
<li>为了更好地管理页，引入了区的概念。</li>
<li>每连续64个页组成一个区，一个区大小为1MB。</li>
<li>每256个区组成一组。  <span id="more"></span></li>
</ol>
</li>
<li><strong>组的结构</strong>：<ol>
<li><strong>第一组的前三个页面是固定类型</strong>：<ul>
<li><code>FSP_HDR</code>：记录该表空间的属性。</li>
<li><code>IBUF_BITMAP</code>：存储 <code>INSERT BUFFER</code> 的信息。</li>
<li><code>INODE</code>：记录段信息。</li>
</ul>
</li>
<li><strong>其余组的头结构</strong>：<ul>
<li><code>XDES</code>：记录该组中所有区的属性。</li>
<li><code>IBUF_BITMAP</code>：与前述相同。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>段 (Segment) 的概念</strong>：<ul>
<li><p><strong>为什么引入区的概念</strong>：</p>
<ol>
<li>如果只使用页进行分配，逻辑上相邻的两个页在物理存储上可能相隔较远，影响数据的顺序读取。</li>
<li>以区为单位分配空间，能将相邻的数据限制在一定范围内，提高读取效率。</li>
</ol>
</li>
<li><p><strong>叶子节点与非叶节点的区别对待</strong>：</p>
<ol>
<li>叶子节点通常需要进行顺序读取，因此最好存放在不同的区内，避免影响读取性能。</li>
<li>一个索引生成两个段：一个用于叶子节点，一个用于非叶节点。</li>
</ol>
</li>
<li><p>**碎片区 (Fragment)**：</p>
<ol>
<li>对于数据较少的表，分配整个区会浪费空间，因此引入碎片区的概念。</li>
<li>碎片区的页面可以分配给不同的段。</li>
</ol>
</li>
<li><p><strong>段的空间分配步骤</strong>：</p>
<ol>
<li>先以碎片区的页面为单位分配空间。</li>
<li>当已经使用了32个碎片区页面后，开始以整个区为单位分配。</li>
</ol>
</li>
</ul>
</li>
<li><strong>区的分类</strong>：<ul>
<li>表空间由若干个区组成，区分为四种类型：<ol>
<li>空闲区。</li>
<li>有剩余空间的碎片区。</li>
<li>无剩余空间的碎片区。</li>
<li>附属于某个段的区。</li>
</ol>
</li>
<li><strong>XDES Entry</strong>：用于管理区的结构，每个区都有一个 <code>XDES Entry</code>，记录了区的属性。<ol>
<li>包含 <code>Segment ID</code>（区所属段的编号）、链表节点、区状态（FREE, FREE_FRAG, FULL_FRAG, FSEG）、页面状态位图等。</li>
</ol>
</li>
<li><strong>XDES Entry链表</strong>：<ul>
<li>插入数据时，InnoDB会维护三个链表：<ol>
<li><code>FREE链表</code>：记录所有状态为FREE的XDES Entry。</li>
<li><code>FREE_FRAG链表</code>：记录状态为FREE_FRAG的XDES Entry。</li>
<li><code>FULL_FRAG链表</code>：记录状态为FULL_FRAG的XDES Entry。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>段的结构</strong>：<ul>
<li>段由零散的页面和多个区组成。</li>
<li>每个段对应一个 <code>INODE Entry</code> 结构，记录段的属性。</li>
<li><strong>INODE Entry的结构</strong>：<ol>
<li><code>Segment ID</code>：段的ID。</li>
<li><code>NOT_FULL_N_USED</code>：记录 <code>NOT_FULL</code> 链表中已使用的页面数量。</li>
<li><code>List Base Node</code>：三个链表的基节点。</li>
<li><code>Magic Number</code>：标记INODE Entry是否已初始化。</li>
<li><code>Fragment Array Entry</code>：记录碎片区使用的页面号。</li>
</ol>
</li>
</ul>
</li>
<li><strong>各类型页面的详细情况</strong>：<ul>
<li><p><strong>FSP_HDR 页面</strong>：</p>
<ol>
<li>记录表空间的整体属性和区的 <code>XDES Entry</code>。</li>
<li>包含 <code>List Base Node</code>，用于存储 FREE、FREE_FRAG、FULL_FRAG 链表的基节点。</li>
</ol>
</li>
<li><p><strong>XDES 页面</strong>：记录该组中所有区的 <code>XDES Entry</code>。</p>
</li>
<li><p><strong>INODE 页面</strong>：记录 <code>INODE Entry</code>，负责段的管理。</p>
</li>
</ul>
</li>
<li><strong>Segment Header的运用</strong>：<ul>
<li>在 B+树索引的根节点 <code>Page Header</code> 中存有两个 <code>Segment Header</code>，分别指向叶子节点段和非叶子节点段的 <code>INODE Entry</code>。</li>
</ul>
</li>
<li><strong>真实表空间对应文件大小</strong>：<ul>
<li>独立表空间对应数据库子目录下的 <code>.ibd</code> 文件，文件大小会随页面增多自动扩展。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第二十五章 锁</title>
    <url>/2023/04/07/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%94%81/</url>
    <content><![CDATA[<ol>
<li><strong>解决并发事务带来问题的两种基本方式</strong>  <ol>
<li><strong>并发事务带来的问题</strong>  <ul>
<li>大致分为三种：  <ol>
<li><strong>读读</strong>  <ul>
<li>多个并发事务读取相同的数据，这种情况不会产生问题。</li>
</ul>
</li>
<li><strong>写写</strong>  <ul>
<li>简介：  <ul>
<li>多个并发事务对相同记录进行修改，会产生<strong>脏写</strong>问题，这是很严重的。  </li>
<li>脏写在所有隔离级别下都不允许发生。</li>
</ul>
</li>
<li><strong>脏写的解决办法</strong>：  <ul>
<li>加锁，使多个事务对于同一记录的写操作排队执行。</li>
</ul>
</li>
<li><strong>加锁解锁的过程</strong>：  <ol>
<li>加锁：  <ul>
<li>创建一个锁结构，<code>trx_id</code>设置为当前事务的ID。  </li>
<li>如果该记录已有其他锁，<code>is_waiting</code>设置为<code>true</code>，表示正在等待获取锁；否则<code>is_waiting</code>设置为<code>false</code>，表示成功获取锁。</li>
</ul>
</li>
<li>解锁：  <ul>
<li>事务提交后，释放当前锁结构，并选择下一个等待该锁的锁结构，将<code>is_waiting</code>设置为<code>false</code>，唤醒对应事务的线程。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>读写和写读</strong>  <ul>
<li>简介：  <ul>
<li>多个并发事务，一个读，一个写，会产生<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>的问题。</li>
</ul>
</li>
<li><strong>解决读写问题的两种方案</strong>：  <ol>
<li><strong>方案一：使用MVCC</strong>  <ul>
<li>MVCC可以解决幻读问题，因为写操作针对的是最新版本，而读操作读取的是旧版本，因此不会产生读写冲突。</li>
</ul>
</li>
<li><strong>方案二：读写操作都使用加锁</strong>  <ul>
<li>对于时效性要求高的场景，比如读取账户余额，希望每次读取到的都是最新版本的记录，这时需要对读、写操作都加锁。  </li>
<li>加锁可以解决脏读和不可重复读问题，但对于幻读问题比较麻烦，因为没法对不存在的记录加锁。  </li>
<li>解决脏读：对写操作加锁，事务提交后释放锁。  </li>
<li>解决不可重复读：对读操作加锁，防止其他事务修改该记录。  <span id="more"></span></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>一致性读（Consistent Reads&#x2F;快照读）</strong>  <ul>
<li>使用MVCC进行读操作被称为<strong>一致性读</strong>或<strong>快照读</strong>。  </li>
<li>在<strong>读提交</strong>和<strong>可重复读</strong>隔离级别下，执行普通<code>SELECT</code>语句时，系统进行快照读。  </li>
<li>快照读不需要加锁，其他事务可以正常执行写操作。</li>
</ul>
</li>
<li><strong>锁定读（Locking Reads）</strong>  <ul>
<li>使用锁解决事务并发时，需要确保读-写、写-写操作互斥，而读-读操作不受影响。  </li>
<li><strong>两种锁</strong>：  <ol>
<li><strong>共享锁（Shared Locks，简称S锁）</strong>：执行读操作之前，需要获取该记录的S锁。  </li>
<li><strong>独占锁（Exclusive Locks，简称X锁）</strong>：执行写操作之前，需要获取该记录的X锁。</li>
</ol>
</li>
<li><strong>共享锁和独占锁的兼容性</strong>：  <ol>
<li>如果先获得一条记录的S锁，可以继续获得该记录的S锁，但无法获得X锁。  </li>
<li>如果先获得一条记录的X锁，则该记录的S锁和X锁都无法再获得。  </li>
<li><strong>总结</strong>：S锁与S锁兼容，S锁与X锁不兼容，X锁与X锁不兼容。</li>
</ol>
</li>
<li><strong>锁定读的语法</strong>：  <ol>
<li><strong>读操作加S锁</strong>：  <ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
</ul>
</li>
<li><strong>读操作加X锁</strong>：  <ul>
<li><code>SELECT ... FOR UPDATE;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>写操作</strong>  <ul>
<li>讲述了<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>操作如何加锁。  </li>
<li><code>DELETE</code>操作相当于获取X锁的锁定读。  </li>
<li><code>UPDATE</code>操作涉及到<code>DELETE</code>和<code>INSERT</code>。  </li>
<li><code>INSERT</code>操作不用显式加锁，但涉及到隐式锁。</li>
</ul>
</li>
</ol>
</li>
<li><strong>多粒度锁</strong>  <ul>
<li>锁的粒度可以细至单条记录（行锁），也可以粗至整个表（表锁）。</li>
</ul>
<ol>
<li><strong>意向锁（Intentional Lock）</strong>  <ul>
<li>表级锁除了S锁和X锁外，还包括意向锁。  </li>
<li><strong>意向S锁（IS锁）</strong>：表内存在行级S锁时，表级添加意向S锁。  </li>
<li><strong>意向X锁（IX锁）</strong>：表内存在行级X锁时，表级添加意向X锁。  </li>
<li>使用意向锁可以快速判断表内是否有行级锁，避免遍历整表。</li>
</ul>
</li>
<li><strong>表级锁与行级锁的兼容性</strong>  <ul>
<li>表级锁与意向锁的兼容性其实就是行级锁与表级锁的兼容性。</li>
</ul>
</li>
</ol>
</li>
<li><strong>MySQL中的行锁和表锁</strong>  <ul>
<li>不同存储引擎对于锁的支持有所不同，主要讨论InnoDB。</li>
</ul>
<ol>
<li><strong>其他存储引擎中的锁</strong>  <ul>
<li>MyISAM、Memory、Merge等存储引擎不支持事务，但支持表级锁（S锁和X锁）。  </li>
<li>加锁是为了防止不同会话之间产生影响，因此同一表通常只有一个会话能够进行写操作。</li>
</ul>
</li>
</ol>
</li>
<li><strong>InnoDB中的锁</strong>  <ul>
<li>InnoDB支持表锁和行锁：  <ol>
<li><strong>表级锁</strong>  <ul>
<li><strong>表级S锁和X锁</strong>：  <ul>
<li>DQL和DML操作不会加表级锁，只有DDL操作才会加表级锁，通常用的是元数据锁（Metadata Locks）。</li>
</ul>
</li>
<li><strong>意向锁（IS锁、IX锁）</strong>：  <ul>
<li>在给表中的记录加行锁时，InnoDB会自动给表添加意向锁。</li>
</ul>
</li>
<li><strong>AUTO-INC锁</strong>：  <ul>
<li>用于获取自增变量的锁。当多个事务同时往同一表插入数据时，为了避免生成相同的自增ID，系统会加锁获取自增值。</li>
</ul>
</li>
</ul>
</li>
<li><strong>行级锁</strong>  <ul>
<li>行级锁也称为记录锁，InnoDB中的行级锁有多种类型：  <ol>
<li><strong>Record Locks</strong>：  <ul>
<li>最普通的行锁，锁住一行记录，分为S锁和X锁。</li>
</ul>
</li>
<li><strong>Gap Locks</strong>：  <ul>
<li>防止插入幻影记录，常用于可重复读隔离级别解决幻读问题。  </li>
<li>如果对一条记录使用了Gap锁，不允许在该记录前的间隙插入数据，但该记录本身不被锁住。  </li>
<li>可以对最大记录后的<code>supremum</code>施加Gap锁，防止插入。</li>
</ul>
</li>
<li><strong>Next-key Locks</strong>：  <ul>
<li>结合Record锁和Gap锁，既锁住一条记录，也防止在该记录前的间隙插入数据。</li>
</ul>
</li>
<li><strong>Insert Intention Locks</strong>：  <ul>
<li>表示有事务想在一个间隙插入记录，但该间隙已被Gap锁锁住。事务会先创建一个插入意向锁，并阻塞自己，等待Gap锁释放。  </li>
<li>插入意向锁之间不会相互阻塞。</li>
</ul>
</li>
<li><strong>隐式锁</strong>：  <ul>
<li>当事务插入一条记录时，该记录不会立即被显式锁定，但如果其他事务访问这条未提交的记录，系统会自动创建隐式锁。  </li>
<li>这种锁需要与事务ID（<code>trx_id</code>）配合使用，系统会通过<code>trx_id</code>来判断记录的创建事务状态。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>InnoDB锁的内存结构</strong>  <ul>
<li>MySQL不会为每一条需要加锁的记录单独创建锁结构，而是将同一事务中多个记录的锁放在同一个锁结构中。  </li>
<li><strong>锁合并的条件</strong>：  <ol>
<li>锁属于同一个事务。  </li>
<li>加锁的记录在同一个页面中。  </li>
<li>加锁的类型相同。  </li>
<li>等待状态相同。</li>
</ol>
</li>
</ul>
<ol>
<li><strong>具体的锁结构</strong>  <ul>
<li>锁结构包括事务信息、索引信息、表锁或行锁的信息以及锁的模式和类型等。  </li>
<li>锁结构的最后有一堆比特位，用于映射页面中的不同用户记录，表示这些记录是否加了行锁。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第二十四章 隔离级别与MVCC</title>
    <url>/2023/04/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/</url>
    <content><![CDATA[<ol>
<li><strong>事前准备</strong>  <ul>
<li>创建一个表并插入数据，准备测试事务的隔离级别与MVCC机制。</li>
</ul>
</li>
<li><strong>事务隔离级别</strong>  <ul>
<li>数据库支持并发执行事务，但会产生一些问题，需要通过隔离性来解决。隔离性越高，并发性就越差。</li>
</ul>
<ol>
<li><strong>事务并发执行遇到的问题</strong>  <ol>
<li><strong>脏写 Dirty Write</strong>  <ul>
<li>一个事务修改了另一个未提交事务修改过的数据。如果第一个事务回滚了，就会导致第二个事务的数据更新失败。</li>
</ul>
</li>
<li><strong>脏读 Dirty Read</strong>  <ul>
<li>一个事务读取了另一个未提交事务修改过的数据。如果第二个事务回滚了，第一个事务读取到的就是不存在的数据。</li>
</ul>
</li>
<li><strong>不可重复读 Non Repeatable Read</strong>  <ul>
<li>在同一事务中，多次读取同一数据，读取结果不一致。</li>
</ul>
</li>
<li><strong>幻读 Phantom</strong>  <ul>
<li>在一个事务中，两次以同一查询条件查询数据，第二次查询时读取到了之前没有见过的记录，通常是有新记录插入。</li>
</ul>
</li>
</ol>
</li>
<li><strong>SQL标准中的四种隔离级别</strong>  <ul>
<li>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读（问题严重性递减）  </li>
<li>四种隔离级别：  <ol>
<li>读未提交  </li>
<li>读提交  </li>
<li>可重复读  </li>
<li>串行化</li>
</ol>
</li>
<li>脏写问题在每一种隔离级别中都被解决。</li>
</ul>
</li>
<li><strong>MySQL支持的四种隔离级别</strong>  <ul>
<li>MySQL支持四种隔离级别，默认隔离级别为可重复读（MySQL的可重复读能够解决幻读）。  </li>
<li>设置事务隔离级别的语法：  <pre><code class="sql">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
</code></pre>
</li>
<li>作用域：  <ol>
<li><code>global</code>：全局有效。  </li>
<li><code>session</code>：当前会话有效。  </li>
<li>省略作用域：仅对下一条事务有效。</li>
</ol>
</li>
<li>也可以通过启动参数更改默认隔离级别：  <pre><code class="bash">--transaction-isolation=SERIALIZABLE
</code></pre>
  <span id="more"></span></li>
</ul>
</li>
</ol>
</li>
<li><strong>MVCC原理</strong>  <ul>
<li>MVCC（Multi-Version Concurrency Control，多版本并发控制）用于处理并发访问，解决读写冲突问题。</li>
</ul>
<ol>
<li><strong>版本链</strong>  <ul>
<li>版本链由<code>undo</code>日志组成的链表，每条<code>undo</code>日志都是该用户记录的一个旧版本，头节点是最新版本。  </li>
<li>聚集索引中有两个隐藏字段：  <ol>
<li><strong>trx_id</strong>：每当事务修改记录时，会将事务的<code>trx_id</code>赋值给该记录。  </li>
<li><strong>roll_pointer</strong>：每当记录被修改，旧版本写入<code>undo</code>日志，通过<code>roll_pointer</code>找到旧版本。</li>
</ol>
</li>
<li><code>undo</code>日志也有<code>trx_id</code>和<code>roll_pointer</code>，组成链表，称为版本链。</li>
</ul>
</li>
<li><strong>ReadView</strong>  <ul>
<li><code>ReadView</code>用于判断版本链中哪个版本对当前事务可见。  </li>
<li>主要包括四个内容：  <ol>
<li><strong>m_ids</strong>：系统中活跃的读写事务的<code>id</code>列表。  </li>
<li><strong>min_trx_id</strong>：<code>m_ids</code>中的最小值。  </li>
<li><strong>max_trx_id</strong>：系统将要分配给下一个事务的<code>id</code>。  </li>
<li><strong>creator_trx_id</strong>：创建该<code>ReadView</code>的事务的<code>id</code>。</li>
</ol>
</li>
<li><strong>ReadView判断版本可见性的步骤</strong>：  <ol>
<li>如果版本的<code>trx_id</code>与<code>creator_trx_id</code>相同，表示该事务在访问自己修改的记录，因此可见。  </li>
<li>如果<code>trx_id</code>小于<code>min_trx_id</code>，表示生成该版本的事务已提交，因此可见。  </li>
<li>如果<code>trx_id</code>大于<code>max_trx_id</code>，表示该版本由生成<code>ReadView</code>之后的事务创建，因此不可见。  </li>
<li>如果<code>trx_id</code>在<code>min_trx_id</code>和<code>max_trx_id</code>之间，检查是否在<code>m_ids</code>列表中：  <ul>
<li>在<code>m_ids</code>中表示活跃事务，不可见。  </li>
<li>不在<code>m_ids</code>中表示已提交事务，因此可见。</li>
</ul>
</li>
<li>如果当前版本不可见，继续在版本链中找下一个版本。</li>
</ol>
</li>
<li><strong>读提交和可重复读生成<code>ReadView</code>的时机不同</strong>：  <ol>
<li><strong>读提交</strong>：每次读取数据前生成<code>ReadView</code>。  </li>
<li><strong>可重复读</strong>：第一次读取数据时生成<code>ReadView</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong>MVCC小结</strong>  <ul>
<li>MVCC在读提交和可重复读隔离级别下，通过生成<code>ReadView</code>来判断记录版本链中的版本是否可见。  </li>
<li>删除用户记录时使用<code>delete_mask</code>，保留版本链支持MVCC。</li>
</ul>
</li>
<li><strong>关于Purge</strong>  <ul>
<li><code>insert undo</code>在事务提交后可以释放，但<code>update undo</code>由于支持MVCC不能立即删除。  </li>
<li><code>delete mark</code>操作仅是打标记而未实际删除，保留版本链支持MVCC。  </li>
<li>当系统判断<code>delete_mask</code>标记的记录或<code>update undo</code>日志不会被访问后，使用<code>purge</code>线程删除它们。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第五章 InnoDB数据页结构</title>
    <url>/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ol>
<li><p><strong>不同类型的页简介</strong></p>
<ul>
<li>页是InnoDB管理空间的基本单位</li>
<li>一个页的大小一般是16KB</li>
<li>InnoDB中有多种页<ul>
<li>存放Insert Buffer信息的页</li>
<li>存放INODE信息的页</li>
<li>存放undo信息的页</li>
<li>索引页INDEX<ul>
<li>这个就是用来存放记录的页</li>
<li>也称为数据页</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据页结构的快速浏览</strong></p>
<ul>
<li>数据页被划分为多个部分 如图<br>   <img src="/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-8.png"></li>
<li>总共分7个部分，简介如下：<br>   <img src="/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-9.png"> <span id="more"></span></li>
</ul>
</li>
<li><p><strong>User Records 记录在页中的存储</strong></p>
<ul>
<li><strong>简介</strong><br>   <img src="/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-11.png"><ul>
<li>纪录会以我们指定的行格式存储在User Records中</li>
<li>一开始只有Free Space，没有User Records部分</li>
<li>每插入一条记录时，将Free Space中的一部分划入到User Records中</li>
<li>当FreeSpace用完时，就得申请新的page了</li>
</ul>
</li>
<li><strong>记录头信息详解</strong><ul>
<li>Compact行格式记录头信息如下<br>   <img src="/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-12.png"></li>
<li>delete_mask<ul>
<li>标记当前记录是否被删除</li>
<li>之所以不直接删除是删除完重排序开销大</li>
<li>被删除的记录会组成一个垃圾链表，链表中的记录 都是可重用空间<ul>
<li>有新的记录的来的话，可以把被删除记录的空间覆盖掉</li>
<li>垃圾链表也通过next_record属性连接</li>
</ul>
</li>
</ul>
</li>
<li>min_rec_mask<ul>
<li>B+树每层非叶节点中 最小的记录，该标记为1</li>
</ul>
</li>
<li>n_owned<ul>
<li>表示该记录在槽中拥有多少条记录</li>
</ul>
</li>
<li>heap_no<ul>
<li>表示当前记录在该页面中的序号</li>
<li>但是是从2开始的<ul>
<li>因为每个页里面有两个伪记录</li>
<li>infimum和supremum</li>
<li>分别作为最小记录和最大记录，heap_no为0和1</li>
<li>不存放在User Records里</li>
</ul>
</li>
</ul>
</li>
<li>record_type<ul>
<li>表示记录类型，分别有四种<ul>
<li>0 普通记录</li>
<li>1 B+树非叶节点记录</li>
<li>2 最小记录</li>
<li>3 最大记录</li>
</ul>
</li>
<li>最小记录和最大记录的 record_type就为2和3</li>
</ul>
</li>
<li>next_record<ul>
<li>到下一条记录的真实数据的偏移地址<ul>
<li>可以理解为指向下一条记录的指针</li>
<li>之所以指向的是记录头和真实数据之间的地址<ul>
<li>是因为这样往左读就是记录头，往右读就是真实数据</li>
<li>这也是为什么变成字段长度列表和NULL值列表要逆序存储</li>
</ul>
</li>
</ul>
</li>
<li>整个就是一个链表结构<ul>
<li>所以对记录做增删改操作就是对链表做增删改操作</li>
</ul>
</li>
<li>该链表的顺序并不是插入顺序，而是按照主键排序的<ul>
<li>最小记录指向最小的用户记录</li>
<li>最大的用户记录指向最大记录</li>
</ul>
</li>
<li>为0时表示没有下一条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Page Directory 页目录</strong></p>
<ul>
<li><strong>简介</strong><ul>
<li>页目录是用来加快对于记录的查询速度的</li>
<li>如果不用页目录的话，只能进行顺序查找，效率很低</li>
<li>用页目录的话<ul>
<li>就可以把记录分为多个组</li>
<li>正常情况下，每个组中有4-8个记录</li>
<li>页目录 中存放每个组中最大记录的地址，每个地址都是一个槽</li>
<li>查找的时候就可以对槽进行二分查找，然后对槽内进行顺序查找</li>
</ul>
</li>
</ul>
</li>
<li><strong>页目录的详细运作方式</strong><ul>
<li>将所有记录划分为几个组，包括最大记录和最小记录<ul>
<li>最小记录单独为一组，包含最大记录的组含有1-8条记录，其余的组含有4-8条记录</li>
<li>插入或删除记录后，可能需要对分组进行合并或分裂，以满足条件</li>
</ul>
</li>
<li>每个组的最大记录中有个n_owned字段，记录该组中有多少条记录</li>
<li>页目录中存放每个每组中最大元素的地址，也称为槽</li>
<li>查询流程<ul>
<li>对页目录进行二分查找，找到目标记录所在的槽</li>
<li>通过上一个槽找到该槽中最小的记录</li>
<li>通过记录的 next_record 属性遍历找到目标记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Page Header 页面头部</strong></p>
<ul>
<li><strong>简介</strong><ul>
<li>Page Header 用于存储和记录相关的状态信息</li>
<li>比如当前存放了多少记录，有多少个槽等等</li>
</ul>
</li>
<li><strong>详细信息</strong><br>   <img src="/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-13.png"></li>
</ul>
</li>
<li><p><strong>File Header 文件头部</strong></p>
<ul>
<li><strong>简介</strong><ul>
<li>负责存储和和页面相关的状态信息</li>
<li>比如页号，上一个页号、下一个页号、页面类型</li>
</ul>
</li>
<li><strong>图解</strong><br>   <img src="/2023/03/18/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-14.png"></li>
<li><strong>常用字段</strong><ul>
<li>FIL_PAGE_SPACE_CHKSUM<ul>
<li>用于检测页面是否完整</li>
</ul>
</li>
<li>FIL_PAGE_OFFSET<ul>
<li>页号</li>
<li>可以用来定位一个页</li>
</ul>
</li>
<li>FIL_PAGE_TYPE<ul>
<li>页面类型</li>
<li>比如索引页就是FIL_PAGE_INDEX</li>
</ul>
</li>
<li>FIL_PAGE_PREV<ul>
<li>上一个页面的页号</li>
</ul>
</li>
<li>FIL_PAGE_NEXT<ul>
<li>下一个页面的页号</li>
<li>页面本质上是通过双向链表连接起来的<ul>
<li>索引页是有两个指针的，其他页就不一定了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>File Trailer 文件结尾</strong></p>
<ul>
<li><strong>作用</strong><ul>
<li>用于检测一个页是否完整</li>
</ul>
</li>
<li><strong>分为两部分</strong><ul>
<li>校验和<ul>
<li>这个校验和应该与Page Header中的校验和相同</li>
<li>如果不相同就说明当前页面数据出错了</li>
</ul>
</li>
<li>LSN 日志序列位置<ul>
<li>也是用来校验页面完整性的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第八章 数据目录</title>
    <url>/2023/03/21/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="8-1-数据库和文件系统的关系"><a href="#8-1-数据库和文件系统的关系" class="headerlink" title="8.1 数据库和文件系统的关系"></a>8.1 数据库和文件系统的关系</h2><p>存储引擎是通过文件系统将数据存储在磁盘上的，数据写回时也依赖文件系统。</p>
<h2 id="8-2-MySQL数据目录"><a href="#8-2-MySQL数据目录" class="headerlink" title="8.2 MySQL数据目录"></a>8.2 MySQL数据目录</h2><p>数据目录是数据库在文件系统中存储和加载数据的位置。</p>
<ol>
<li><p><strong>数据目录和安装目录的区别</strong>：</p>
<ul>
<li>安装目录是数据库的安装路径。</li>
<li>数据目录用于存储数据库在运行过程中产生的数据。</li>
</ul>
</li>
<li><p><strong>如何确定MySQL中的数据目录</strong>：</p>
<ul>
<li>数据目录对应一个系统变量 <code>datadir</code>。</li>
<li>执行查询语句即可获取数据目录位置。</li>
</ul>
</li>
</ol>
<h2 id="8-3-数据目录的结构"><a href="#8-3-数据目录的结构" class="headerlink" title="8.3 数据目录的结构"></a>8.3 数据目录的结构</h2><ol>
<li><p><strong>简介</strong>：</p>
<ul>
<li>数据目录包含用户创建的数据库、表、视图和触发器等用户数据，也包含一些额外数据。 <span id="more"></span></li>
</ul>
</li>
<li><p><strong>数据库在文件系统中的表示</strong>：</p>
<ul>
<li>每个数据库对应数据目录下的一个子目录。</li>
<li>新建数据库时，MySQL会在数据目录下创建与数据库同名的子目录，并生成一个 <code>db.opt</code> 文件，包含数据库的属性信息。</li>
</ul>
</li>
<li><p><strong>表在文件系统中的表示</strong>：</p>
<ul>
<li><p>每个表的信息分为两部分：</p>
<ol>
<li>表结构的定义。</li>
<li>表中的数据。</li>
</ol>
</li>
<li><p><strong>表结构的存储</strong>：</p>
<ul>
<li>表结构包括字段数量、字段类型、约束条件、索引信息等。</li>
<li>每创建一个表，数据库子目录下会生成一个 <code>.frm</code> 文件，用于存储表结构信息。</li>
</ul>
</li>
<li><p><strong>InnoDB的存储方式</strong>：</p>
<ol>
<li><p><strong>表空间（Table Space）</strong>：</p>
<ul>
<li>表空间对应文件系统上的一个或多个文件，被划分为多个页，用户记录存放在表空间下的某个页里。</li>
</ul>
</li>
<li><p><strong>系统表空间（System Table Space）</strong>：</p>
<ul>
<li>可以对应多个文件，并可自增。</li>
<li>默认是数据目录下的 <code>ibdata1</code> 文件。</li>
<li>在 MySQL 5.5.7 到 MySQL 5.6.6 版本之间，所有表的数据都存储在系统表空间中。</li>
</ul>
</li>
<li><p><strong>独立表空间（File-Per-Table Tablespace）</strong>：</p>
<ul>
<li>从 MySQL 5.5.6 开始，表的数据不再默认存储在系统表空间中，而是每个表拥有独立的表空间。</li>
<li>独立表空间下，每个表会在数据库子目录下生成一个 <code>.ibd</code> 文件，存储表数据和索引。</li>
</ul>
</li>
<li><p><strong>其他表空间类型</strong>：</p>
<ul>
<li>通用表空间（General Tablespace）。</li>
<li>Undo 表空间（Undo Tablespace）。</li>
<li>临时表空间（Temporary Tablespace）。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>MyISAM的存储方式</strong>：</p>
<ul>
<li>MyISAM 不使用表空间概念，所有表数据存储在数据库子目录下。</li>
<li>每个表在数据库子目录下生成三个文件：<ol>
<li><code>.frm</code>：存储表结构。</li>
<li><code>.MYD</code>：存储用户记录。</li>
<li><code>.MYI</code>：存储索引。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>视图在文件系统中的表示</strong>：</p>
<ul>
<li>视图是虚拟表，存储时不保存实际数据，只存储视图的结构，即 <code>.frm</code> 文件。</li>
</ul>
</li>
<li><p><strong>其他文件</strong>：</p>
<ul>
<li>数据目录下还包含一些额外文件：<ol>
<li><strong>服务器进程文件</strong>：MySQL 服务器会将自身进程ID写入该文件。</li>
<li><strong>服务器日志文件</strong>：包括查询日志、错误日志、redo日志等。</li>
<li><strong>证书和密钥</strong>：用于服务器和客户端的通信。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="8-4-文件系统对数据库的影响"><a href="#8-4-文件系统对数据库的影响" class="headerlink" title="8.4 文件系统对数据库的影响"></a>8.4 文件系统对数据库的影响</h2><p>MySQL 依赖文件系统存储数据，因此文件系统的限制会影响数据库的命名、表大小和性能。</p>
<ol>
<li><strong>数据库和表名长度</strong>：不允许超过文件系统的最大长度。</li>
<li><strong>特殊字符问题</strong>：为避免字符冲突，所有非拉丁字母和数字的字符都会被替换为 <code>@+编码</code>。</li>
<li><strong>文件大小限制</strong>：表大小受文件系统最大长度的限制。</li>
</ol>
<h2 id="8-5-MySQL系统数据库简介"><a href="#8-5-MySQL系统数据库简介" class="headerlink" title="8.5 MySQL系统数据库简介"></a>8.5 MySQL系统数据库简介</h2><p>除了用户数据库外，MySQL 还包括几个系统数据库：</p>
<ol>
<li><strong>mysql</strong>：<ul>
<li>核心系统数据库，存储用户账户和权限信息、存储过程、事件信息和日志信息等。</li>
</ul>
</li>
<li><strong>information_schema</strong>：<ul>
<li>存储所有其他数据库的元信息，如表、视图、触发器等。</li>
</ul>
</li>
<li><strong>performance_schema</strong>：<ul>
<li>监控 MySQL 服务器性能，存储服务器状态信息。</li>
</ul>
</li>
<li><strong>sys</strong>：<ul>
<li><code>sys</code> 结合了 <code>information_schema</code> 和 <code>performance_schema</code>，提供更便捷的视图来查看数据库信息。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第六章 B+树索引</title>
    <url>/2023/03/19/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AD%E7%AB%A0%20B+%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<ol>
<li><strong>没有索引的查找</strong>  <ul>
<li>在没有索引的情况下，查找记录的操作如下：</li>
</ul>
<ol>
<li><strong>在一个页中查找</strong>  <ul>
<li>假设记录数量较少，全部存储在一个数据页中。  </li>
<li>有两种情况：  <ol>
<li><strong>以主键为搜索条件</strong>：  <ul>
<li>先对页目录使用二分法找到对应的槽，然后遍历得到目标记录。</li>
</ul>
</li>
<li><strong>以其他字段为搜索条件</strong>：  <ul>
<li>只能遍历所有记录进行查找。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>在多个页中查找</strong>  <ul>
<li>如果表中的记录存储在多个数据页中，查找分为两个步骤：  <ol>
<li>使用双向链表遍历每个数据页，因为页之间不是有序的。  </li>
<li>在每个数据页中对记录进行查找。</li>
</ol>
</li>
<li><strong>问题</strong>：  <ul>
<li>没有索引时，需要遍历所有数据页才能找到目标记录。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>使用索引的情况</strong>  <ol>
<li><strong>一个简单的索引方案</strong>  <ul>
<li>通过以下步骤优化查找效率：  <ol>
<li>让所有数据页按主键有序排列。  </li>
<li>为每个数据页建立目录，目录项存储数据页中最小记录的主键和页号。  </li>
<li>通过二分法在目录中查找目标记录所在页，然后在该页中查找具体记录。  </li>
<li>该目录即为<strong>索引</strong>。   <span id="more"></span></li>
</ol>
</li>
</ul>
</li>
<li><strong>InnoDB中的索引方案</strong>  <ul>
<li>InnoDB索引相比简单方案的改进：  <ol>
<li>不使用连续空间存储索引项，避免空间不足的问题。  </li>
<li>目录项记录使用数据页存储，避免因增删数据而频繁移动索引项。</li>
</ol>
</li>
<li><strong>目录项记录</strong>：  <ul>
<li>目录项记录存储页号和该页中最小的主键值，<code>record_type</code>为1。  </li>
<li>用户记录的<code>record_type</code>为0。</li>
</ul>
</li>
<li><strong>B+树的结构</strong>：  <ul>
<li>InnoDB索引结构是一个B+树，每个节点是一个数据页。  </li>
<li>非叶子节点存储目录项记录，叶子节点存储用户记录。  </li>
<li>每层节点通过指针构成双向链表。</li>
</ul>
</li>
<li><strong>聚簇索引（聚集索引）</strong>：  <ul>
<li>特点：  <ol>
<li>聚簇索引也是B+树，基于主键排序。  </li>
<li>聚簇索引叶子节点存放实际用户记录。  </li>
<li>聚簇索引是自动创建的，反映了数据的存储方式。</li>
</ol>
</li>
</ul>
</li>
<li><strong>二级索引（非聚集索引&#x2F;辅助索引）</strong>：  <ul>
<li>特点：  <ol>
<li>需要额外创建，基于非主键字段进行排序。  </li>
<li>叶子节点存储指定字段和记录的主键，查到结果后需通过主键查找聚簇索引获取完整记录。</li>
</ol>
</li>
</ul>
</li>
<li><strong>联合索引</strong>：  <ul>
<li>特点：  <ol>
<li>基于多个字段进行排序。  </li>
<li>本质上是二级索引，拿到主键后仍需查询聚簇索引。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>InnoDB的B+树索引注意事项</strong>  <ol>
<li><strong>根页面万年不动</strong>  <ul>
<li>索引创建时，先创建一个根页面。  </li>
<li>根节点满后会分裂成两个页，原根节点从存储用户记录变为存储目录项记录，根节点始终不变。</li>
</ul>
</li>
<li><strong>非叶节点中目录项记录的唯一性</strong>  <ul>
<li>非聚集索引可能出现索引字段相同的情况，因此目录项记录增加主键字段确保唯一性。</li>
</ul>
</li>
<li><strong>一个数据页至少存储两条记录</strong>  <ul>
<li>B+树中的每个数据页至少存储两条记录。</li>
</ul>
</li>
</ol>
</li>
<li><strong>MyISAM中的索引方案简单介绍</strong>  <ul>
<li><strong>InnoDB</strong>：数据直接存储在聚簇索引的叶子节点中，数据即索引。  </li>
<li><strong>MyISAM</strong>：数据和索引分开存储，索引的叶子节点只存储记录的地址。  </li>
<li><strong>回表</strong>：  <ol>
<li>InnoDB通过主键查询聚簇索引找到记录。  </li>
<li>MyISAM通过地址直接定位到记录的位置。</li>
</ol>
</li>
</ul>
</li>
<li><strong>MySQL中创建和删除索引的语句</strong>  <ol>
<li><strong>注意点</strong>  <ul>
<li>InnoDB和MyISAM会自动为主键或声明为<code>unique</code>的字段创建B+树索引。  </li>
<li>并非每个字段都创建索引，因为增加记录时需要调整所有索引，开销较大。</li>
</ul>
</li>
<li><strong>创建索引的语法</strong>  <ul>
<li>创建表时指定索引：<code>INDEX</code>和<code>KEY</code>是同义词。  </li>
<li>修改表时可以创建或删除索引。  </li>
<li>还可以添加联合索引。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第十一章 连接的原理</title>
    <url>/2023/04/04/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<ol>
<li><strong>简介</strong><br> MySQL中的连接 <code>join</code>，如果使用不好可能会导致慢查询，所以最好弄懂原理再去用。</li>
<li><strong>连接简介</strong><ul>
<li><strong>连接的本质</strong><ul>
<li>连接本质还是查询</li>
<li>就是把驱动表的记录，拿到被驱动表里找匹配的记录</li>
<li>所以加快查询的方法也可以用来加快连接，比如建立索引</li>
</ul>
</li>
<li><strong>连接过程中的过滤</strong><ul>
<li>简介<ul>
<li>因为直接对多个表进行笛卡尔积的话，产生的结果非常多</li>
<li>因此需要在<code>Where</code>子句里添加过滤条件进行过滤</li>
</ul>
</li>
<li>过滤条件分为两种<ul>
<li>单表过滤条件<ol>
<li>只涉及到一个表的字段</li>
<li>比如 <code>t1.a &gt; 10</code></li>
</ol>
</li>
<li>双表过滤条件<ol>
<li>涉及到两个表的字段</li>
<li>比如 <code>t1.a &gt; t2.a</code></li>
</ol>
</li>
</ul>
</li>
<li>带有过滤条件的连接过程<ul>
<li>例子：<ol>
<li><code>SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#39;d&#39;;</code></li>
<li>包含了3个过滤条件</li>
</ol>
</li>
<li>大致执行过程：<ol>
<li>先选择一个表作为驱动表，比如<code>t1</code><ul>
<li>然后使用单表过滤条件对其进行查询</li>
<li>得到符合条件的记录</li>
</ul>
</li>
<li>对于我们得到的每一条记录<ul>
<li>到第二个表（被驱动表）中通过双表过滤条件找到匹配的记录</li>
<li>并且使用被驱动表的单表过滤条件进行过滤</li>
</ul>
</li>
<li>最后我们将所有得到的记录合在一起就得到了连接的结果</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>内连接和外连接</strong><ul>
<li>简介<ul>
<li>内连接：<ol>
<li>在一个表里有，但是在另一个表里匹配不到的记录，就不加入结果集</li>
<li>只写一个<code>join</code>就默认是内连接</li>
</ol>
</li>
<li>外连接：<ol>
<li>在一个表里有，但在另一个匹配不到的记录，也加入结果集</li>
<li>只不过没匹配到的字段用空值代替  <span id="more"></span></li>
</ol>
</li>
</ul>
</li>
<li>外连接还可以细分为：<ul>
<li>左外连接：<ol>
<li><code>SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</code></li>
<li><code>outer</code>可以直接省略</li>
<li>左边作为驱动表|内表，右边作为被驱动表|外表</li>
</ol>
</li>
<li>右外连接：<ol>
<li><code>SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</code></li>
<li>左边作为被驱动表|外表，右边作为驱动表|内表</li>
</ol>
</li>
<li>全外连接：<ol>
<li>注意<code>MySQL</code>不提供全外连接</li>
<li>所以只能使用<code>Union</code>把左外连接和右外连接的结果取并集作为全外连接</li>
</ol>
</li>
</ul>
</li>
<li><code>Where</code>子句 和 <code>On</code>子句：<ul>
<li>共同点：<ol>
<li><code>where</code>子句和<code>on</code>子句都可以用来指定连接时的过滤条件</li>
</ol>
</li>
<li>不同点：<ol>
<li>在内连接时，<code>on</code>子句和<code>where</code>子句是完全等价的</li>
<li>在外连接时，<code>on</code>子句会保留没有匹配到的记录，而<code>where</code>子句会过滤掉所有不匹配的记录</li>
</ol>
</li>
<li>注意：<ol>
<li>一般，只涉及到单表的过滤条件，放到<code>where</code>子句里，双表过滤条件放<code>on</code>子句里</li>
<li>放在<code>on</code>子句里的条件也叫连接条件</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>连接的原理</strong><ul>
<li>有的连接非常快，有的连接非常慢，下面讲讲原因</li>
</ul>
<ol>
<li><strong>嵌套循环连接 <code>Nested-Loop Join</code></strong><ul>
<li>简介：<ul>
<li>这个就是我们之前讲的最普通的连接方法</li>
<li>先对驱动表进行过滤，得到结果</li>
<li>对于得到的每一条记录，到被驱动表中找到匹配的记录，并且执行响应的过滤条件</li>
<li>如果有第三个表，那就对前两个表的连接结果中每一条记录，到第三个表里找到匹配的记录<ol>
<li>就像嵌套循环连接一样</li>
</ol>
</li>
</ul>
</li>
<li>特点：<ol>
<li>驱动表只需要访问一次，被驱动表需要访问多次，具体次数取决于驱动表过滤后的记录数量</li>
<li>这是最简单，但是代价最大的表连接方式</li>
</ol>
</li>
</ul>
</li>
<li><strong>使用索引加快连接</strong><ul>
<li>前面说到，驱动表会被访问一次，而被驱动表会被访问多次</li>
<li>因此我们可以给被驱动表的连接条件和过滤条件中涉及到的字段建立索引，能加快连接的速度<ol>
<li>如果有多个可用索引，查询优化器也会自动选择代价最低的方案进行使用</li>
</ol>
</li>
<li>注意别用<code>select *</code>，可能会导致<code>index</code>访问方法失效，也就是覆盖索引失效</li>
</ul>
</li>
<li><strong>基于块的嵌套循环连接 <code>Block Nested-Loop Join</code></strong><ul>
<li>问题：<ol>
<li>真实的生产环境中，一个表可能非常大，内存里没法一次全部放下，会一边加载一边释放</li>
<li>而在表连接时，被驱动表会被访问很多次。所以可能会导致被驱动表重复地加载到内存里来</li>
</ol>
</li>
<li>解决办法：<ol>
<li>所以需要想办法降低被驱动表访问的次数</li>
<li>本来驱动表里的每条记录都需要和被驱动表匹配一次，每匹配一次就需要加载一次被驱动表</li>
<li>解决办法就是让被驱动表一次和驱动表中的多条记录进行匹配</li>
<li>具体实现方法：<ol>
<li>引入一个<code>join buffer</code>，<code>join buffer</code>里存储多条驱动表的记录</li>
<li>对被驱动表进行扫描时，我们让其跟<code>join buffer</code>里的每一条记录都进行匹配</li>
<li>以此降低被驱动表的访问次数</li>
</ol>
</li>
<li>注意点：<ol>
<li>最好的情况就是<code>join buffer</code>一次能容纳所有的驱动表记录<ul>
<li><code>join buffer</code>的大小可以自己设置</li>
</ul>
</li>
<li><code>join buffer</code>里只会放查询字段和过滤条件中的字段<ul>
<li>所以没事别用<code>*</code>作为查询列表，也就是别用<code>select *</code></li>
</ul>
</li>
<li>不过最好的方法还是给被驱动表加上索引，其次再考虑<code>join buffer</code></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第十九章 事务简介</title>
    <url>/2023/04/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<ol>
<li><strong>事务的起源</strong>  <ul>
<li>事务就是一组对于数据存储操作的集合。比如转账就包括给一个账户扣钱，再给另一个账户增加钱。  </li>
<li>事务的四大特性：  <ol>
<li><strong>原子性</strong>  <ul>
<li>事务中的操作，要么全部执行，要么全部不执行，也就是回滚。</li>
</ul>
</li>
<li><strong>隔离性</strong>  <ul>
<li>多个事务同时执行时，不能相互产生影响。</li>
</ul>
</li>
<li><strong>一致性</strong>  <ul>
<li>数据库中的数据需要满足一致性。  </li>
<li>例如转账操作，转账前后所有账户的总金额应保持不变。  </li>
<li>一致性可以通过触发器实现。</li>
</ul>
</li>
<li><strong>持久性</strong>  <ul>
<li>事务的执行结果应该被永久保留。  </li>
<li>例如InnoDB通过<code>redo log</code>实现持久性。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>事务的概念</strong>  <ol>
<li><strong>定义</strong>  <ul>
<li>事务就是一组数据库操作。</li>
</ul>
</li>
<li><strong>事务的5个状态</strong>  <ol>
<li><strong>active</strong>  <ul>
<li>正在执行。</li>
</ul>
</li>
<li><strong>partially committed</strong>  <ul>
<li>完成了所有操作，但是更改还没有刷回外存。</li>
</ul>
</li>
<li><strong>failed</strong>  <ul>
<li>如果在<code>active</code>或<code>partially committed</code>状态时遇到错误，就会进入<code>failed</code>状态。</li>
</ul>
</li>
<li><strong>aborted</strong>  <ul>
<li>当事务处于<code>failed</code>状态时，需要进行回滚，回滚后为<code>aborted</code>状态。</li>
</ul>
</li>
<li><strong>committed</strong>  <ul>
<li>事务成功执行，且更改同步到外存。   <span id="more"></span></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>MySQL中事务的语法</strong>  <ul>
<li>事务的操作不是存储过程，而是将接下来进行的所有操作纳入一个事务中。</li>
</ul>
<ol>
<li><strong>开启事务</strong>  <ul>
<li>使用<code>BEGIN;</code>或<code>START TRANSACTION;</code>开启事务，表示后续操作都属于该事务。  </li>
<li><code>START TRANSACTION;</code>可以带有修饰符：  <ol>
<li><strong>READ ONLY</strong>：表示该事务为只读。  </li>
<li><strong>READ WRITE</strong>：表示该事务为读写事务（默认）。  </li>
<li><strong>WITH CONSISTENT SNAPSHOT</strong>：启动一致性读。</li>
</ol>
</li>
</ul>
</li>
<li><strong>提交事务</strong>  <ul>
<li>使用<code>COMMIT;</code>提交事务。</li>
</ul>
</li>
<li><strong>手动回滚事务</strong>  <ul>
<li>如果发现已提交的语句有误，可以调用<code>ROLLBACK;</code>手动回滚。事务出错时也会自动回滚。</li>
</ul>
</li>
<li><strong>支持事务的存储引擎</strong>  <ul>
<li>只有<code>InnoDB</code>和<code>NDB</code>支持事务。  </li>
<li>如果对不支持事务的表进行了修改，回滚操作无效。</li>
</ul>
</li>
<li><strong>自动提交</strong>  <ul>
<li>系统变量<code>autocommit</code>默认值为<code>ON</code>，表示每条语句都作为一个独立事务执行。  </li>
<li>关闭自动提交的两种方式：  <ol>
<li>显式执行<code>BEGIN;</code>或<code>START TRANSACTION;</code>。  </li>
<li>设置<code>autocommit</code>为<code>OFF</code>。</li>
</ol>
</li>
<li>关闭<code>autocommit</code>后，只有调用<code>COMMIT;</code>才能提交事务。</li>
</ul>
</li>
<li><strong>隐式提交</strong>  <ul>
<li>某些语句会导致隐式提交当前事务，包括：  <ol>
<li>数据定义语言（DDL）操作。  </li>
<li>修改<code>mysql</code>系统数据库中的表。  </li>
<li>事务控制或锁定语句。  </li>
<li>数据导入语句。  </li>
<li>MySQL主从复制操作。</li>
</ol>
</li>
</ul>
</li>
<li><strong>保存点</strong>  <ul>
<li><code>ROLLBACK;</code>会回滚所有内容，而有时我们只想回滚部分内容，因此可以使用保存点。  </li>
<li><strong>创建保存点</strong>：<code>SAVEPOINT 保存点名称;</code>  </li>
<li><strong>回滚到保存点</strong>：<code>ROLLBACK TO 保存点名称;</code>  </li>
<li><strong>删除保存点</strong>：<code>RELEASE SAVEPOINT 保存点名称;</code></li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第十二章 MySQL基于成本的优化</title>
    <url>/2023/04/05/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li><strong>什么是成本</strong>  <ul>
<li>同一查询会有多个执行方案，MySQL会自动选择成本最低的方案去进行查询。  </li>
<li>成本主要由两个方面组成：<ol>
<li><strong>IO成本</strong>  <ul>
<li>当我们想查询数据时，需要先把数据从磁盘里加载到内存里之后才可以查询。  </li>
<li>从外存加载到内存的时间损耗就可以称为IO成本。</li>
</ul>
</li>
<li><strong>CPU成本</strong>  <ul>
<li>检测记录是否满足查询条件、对结果集进行排序等等，就称为CPU成本。</li>
</ul>
</li>
</ol>
</li>
<li>读取一个页面的成本是1.0，读取和检测一条记录是否满足查询条件的成本是0.2，这些数字叫成本常数。  </li>
<li>对一条记录光读取不匹配的成本也是0.2。</li>
</ul>
</li>
<li><strong>单表查询成本</strong>  <ul>
<li><strong>准备工作</strong>  <ul>
<li>创建一个表。</li>
</ul>
</li>
<li><strong>基于成本的优化步骤</strong>  <ul>
<li><strong>简介</strong>  <ul>
<li><strong>流程简介</strong>：  <ol>
<li>在执行一条单表查询条件时，查询优化器会找出可行的执行方案。  </li>
<li>然后比对所有执行方案的代价。  </li>
<li>选择代价最低的执行方案进行执行。</li>
</ol>
</li>
<li><strong>更具体的流程</strong>：  <ol>
<li>根据搜索条件，找出所有可用的索引。  </li>
<li>然后计算全表扫描的代价。  </li>
<li>计算使用不同索引执行查询的代价。  </li>
<li>选择代价最低的执行计划进行查询。</li>
</ol>
</li>
</ul>
</li>
<li><strong>查询语句如下</strong>：<br>  <img src="/2023/04/05/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/image.png" alt="alt text"></li>
<li><strong>先分析可用的索引 possible keys</strong>：<br>  <img src="/2023/04/05/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/image-1.png" alt="alt text"><ul>
<li>发现possible keys 只有 idx_key1 和 idx_key2。</li>
</ul>
</li>
<li><strong>计算全表扫描的代价</strong>：  <ul>
<li>查询成本&#x3D;IO成本+CPU成本，所以计算全表扫描的代价主要看两个部分：  <ol>
<li>聚集索引占用的页面数量。  </li>
<li>表中的记录总数。</li>
</ol>
</li>
<li>这些信息可以通过表的统计数据获取：  <ol>
<li>使用 <code>SHOW TABLE STATUS LIKE &#39;single_table&#39;</code>。  </li>
<li>这些信息由MySQL负责收集。</li>
</ol>
</li>
<li>我们主要看Rows和Data_Length：  <ol>
<li><strong>Rows</strong>：  <ul>
<li>本选项表示表中的记录条数。对于使用 MyISAM 存储引擎的表来说，该值是准确的，对于使用 InnoDB 存储引擎的表来说，该值是一个估计值。</li>
</ul>
</li>
<li><strong>Data_length</strong>：  <ul>
<li>表示表占用的存储空间字节数。使用 MyISAM 存储引擎的表来说，该值就是数据文件的大小，对于使用 InnoDB 存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小。  </li>
<li>所以聚簇索引的页面数量 &#x3D; 1589248 ÷ 16 ÷ 1024 &#x3D; 97。    <span id="more"></span></li>
</ul>
</li>
</ol>
</li>
<li>最后的成本：  <ol>
<li><strong>IO成本</strong>：  <ul>
<li>97 x 1.0 + 1.1 &#x3D; 98.1。</li>
</ul>
</li>
<li><strong>CPU成本</strong>：  <ul>
<li>9693 x 0.2 + 1.0 &#x3D; 1939.6。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>计算使用不同索引的代价</strong>：  <ul>
<li>需要计算每个索引单独查询的代价，如果满足条件的话，还需要计算索引合并的代价。  </li>
<li><strong>idx_key2索引的成本分析</strong>：  <ol>
<li>查询条件为 key2 &gt; 10 AND key2 &lt; 1000。  </li>
<li>计算范围区间数量：  <ul>
<li>查询优化器认为一个范围区间算作一个页面。  </li>
<li>这里就只有一个范围区间，所以算作一个页面。</li>
</ul>
</li>
<li>计算需要回表的记录数量：  <ul>
<li>先在索引里定位的区间的两个端点。  </li>
<li>然后估算这两条记录中间夹了多少条记录。  </li>
<li>估算方式是找它们父节点中的目录项记录。  </li>
<li>读取二级索引记录算入CPU成本。</li>
</ul>
</li>
<li>进行回表：  <ul>
<li>每次回表都认为访问了一个页面，算入IO成本。  </li>
<li>每次回表时，对聚集索引记录的读取和匹配也会计入CPU成本。</li>
</ul>
</li>
<li><strong>总代价</strong>：  <ol>
<li><strong>IO成本</strong>：  <ul>
<li>范围区间数量+符合条件的二级索引记录数量。</li>
</ul>
</li>
<li><strong>CPU成本</strong>：  <ul>
<li>读取二级索引的成本+回表读取聚集索引的成本。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>idx_key1的成本分析</strong>：  <ol>
<li>搜索条件：  <ul>
<li>key1 IN (‘a’, ‘b’, ‘c’)。  </li>
<li>认为是产生了三个单点区间。</li>
</ul>
</li>
<li>计算范围区间数量：  <ul>
<li>这里有三个范围区间。  </li>
<li>认为访问了三个页面。</li>
</ul>
</li>
<li>计算回表记录数量：  <ul>
<li>对每个单点区间进行匹配，找到总记录数就行。</li>
</ul>
</li>
</ol>
</li>
<li><strong>判断是否可以进行索引合并</strong>：  <ol>
<li>这里用到了非主键范围匹配，所以不满足索引合并的条件。  </li>
<li>况且索引合并的成本计算比较麻烦，这里就不讲了。</li>
</ol>
</li>
</ul>
</li>
<li><strong>找到成本最小的执行方案</strong>：  <ul>
<li>所以这里选择 idx_key2 进行查询。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>基于索引统计数据的成本计算 Show Index</strong>  <ol>
<li><strong>index dive</strong>：  <ul>
<li>指的是通过访问索引来计算一个范围区间内有多少条记录。</li>
</ul>
</li>
<li><strong>带来的问题</strong>：  <ul>
<li>正常情况下是可以通过index dive来计算记录条数的。  </li>
<li>但是如果IN子句里参数非常多，导致出现了很多的单点范围区间，比如几百个：  <ul>
<li>会有一个叫index_dive_limit的系统变量，就是看有没有超过这个值。</li>
</ul>
</li>
<li>这时候就不会再通过index dive的方式计算单点区间中记录的数量。</li>
</ul>
</li>
<li><strong>通过索引统计数据估计记录数量</strong>：  <ul>
<li><code>show index from 索引名</code>：  <ul>
<li>可以展示一个索引的统计情况。  </li>
<li>我们主要看cardinality字段，也就是基数。  </li>
<li>基数表示该索引字段中不重复的值的数量。</li>
</ul>
</li>
<li>通过 <code>show table status</code> 命令获取 <code>rows</code> 字段：  <ul>
<li>rows表示总共有多少条记录。</li>
</ul>
</li>
<li><code>rows/cardinality</code>就可以得到平均一个值重复多少次。  </li>
<li>所以 符合条件的记录数量 &#x3D; 单点区间数量 * 平均重复次数。  </li>
<li>比index dive方便多了，但是不精确。</li>
</ul>
</li>
</ol>
</li>
<li><strong>连接查询的成本</strong>  <ol>
<li><strong>准备工作</strong>：  <ul>
<li>假设有两个表，和上面的一样，一个叫<code>s1</code>，一个叫<code>s2</code>。</li>
</ul>
</li>
<li><strong>Condition Filtering 介绍</strong>：  <ul>
<li>因为MySQL中连接查询采用的是嵌套循环连接算法，所以查询成本分为两个部分：  <ol>
<li>单次查询驱动表的成本。  </li>
<li>多次查询被驱动表的成本(具体查询次数取决于驱动表查询的结果集中有多少条记录)。</li>
</ol>
</li>
<li><strong>fanout 扇出值</strong>：  <ul>
<li>扇出值指的是对驱动表使用单表过滤条件进行过滤后得到记录的数量。  </li>
<li>fanout越小，查询被驱动表的次数越少。  </li>
<li>fanout有时候可以通过索引计算出来准确的值。  </li>
<li>如果有的过滤条件没法使用索引，那么就只能猜fanout的值，因为查询优化器不会去真正执行查询。</li>
</ul>
</li>
<li>对fanout进行猜的过程就叫做<strong>Condition Filtering</strong>。</li>
</ul>
</li>
<li><strong>两表连接的成本分析</strong>：  <ul>
<li>连接查询的成本组成如下：  <ol>
<li>连接查询总成本 &#x3D; 单次访问驱动表的成本 + 驱动表扇出数(fanout) x 单次访问被驱动表的成本。</li>
</ol>
</li>
<li><strong>注意</strong>：  <ul>
<li>对于左连接或右连接：  <ol>
<li>驱动表是固定的。  </li>
<li>所以只需要找到驱动表和被驱动表成本最低的查询方案就行了。</li>
</ol>
</li>
<li>对于内连接：  <ol>
<li>驱动表和被驱动表是可以互换的。  </li>
<li>需要考虑不同连接顺序的查询成本。  </li>
<li>选择成本最低的连接顺序。</li>
</ol>
</li>
</ul>
</li>
<li><strong>例子</strong>：  <ul>
<li>这是内连接，有两种连接方式，s1为驱动表或s2为驱动表。  </li>
<li>我们主要以s2为驱动表举例，并且定性分析，而不是定量分析。  </li>
<li><strong>s2为驱动表的情况</strong>：  <ol>
<li>计算驱动表的查询成本 <code>s2</code>：  <ul>
<li>过滤条件为 <code>s2.key2 &gt;1000 and s2.key2 &lt;2000</code>。  </li>
<li>可以看到驱动表可选的执行方案有全表扫描和使用<code>key2</code>的索引。  </li>
<li>这里范围匹配走索引肯定更快，满足range访问方法。</li>
</ul>
</li>
<li>计算被驱动表的查询成本 <code>s1</code>：  <ul>
<li>过滤条件为：  <ol>
<li><code>s1.key1 = 常数</code>。  </li>
<li><code>s1.key2 &gt; 1000 AND s1.key2 &lt; 2000</code>。</li>
</ol>
</li>
<li>因为对于key1的等值匹配，我们不知道具体的值，所以没法用index dive确定记录数量。  </li>
<li>因此可以用索引统计数据 <code>cardinality</code> 进行估算，也就是平均重复次数。  </li>
<li>可用的执行方法：  <ol>
<li>全表扫描 <code>all</code>访问方法。  </li>
<li><code>idx_key1</code> <code>ref</code>访问方法。  </li>
<li><code>idx_key2</code> <code>range</code>访问方法。</li>
</ol>
</li>
<li>一般情况下，<code>ref</code>优于<code>range</code>方法，所以这里选<code>idx_key1</code>。</li>
</ul>
</li>
<li><strong>最后的总成本为</strong>：  <ul>
<li>使用<code>idx_key2</code>访问s2的成本 + s2的扇出 × 使用<code>idx_key1</code>访问s1的成本。  </li>
<li>不过还需要和另一个连接顺序的成本作比较。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>两表连接如何优化</strong>：  <ul>
<li>可以看到两表连接的成本主要在驱动表的fanout和被驱动表的访问成本上。  </li>
<li>一个是降低驱动表的fanout。  </li>
<li>一个是降低被驱动表的单次访问成本：  <ol>
<li>可以给连接字段建立索引，能达到 <code>ref</code>访问方法。  </li>
<li>如果使用主键或唯一二级索引，能达到 <code>const</code>访问方法。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>多表连接成本分析</strong>  <ul>
<li>前面说计算连接查询的成本时，会把每种连接顺序的成本都计算一次。  </li>
<li>但如果有n个表，那就有n的阶乘个连接顺序。  </li>
<li>因此有下面几种优化方法：  <ol>
<li><strong>提前结束一个顺序的成本计算</strong>：  <ul>
<li>会维护一个当前最小连接查询成本。  </li>
<li>如果计算某个顺序时，发现成本已经超过了，就不继续往下计算了。</li>
</ul>
</li>
<li>**设置阈值 系统变量 <code>optimizer_search_depth</code>**：  <ul>
<li>如果连接表的个数没超过阈值，就穷举所有连接顺序。  </li>
<li>如果超过阈值，就只对和阈值相同数量的表进行穷举。</li>
</ul>
</li>
<li><strong>使用特定规则进行过滤</strong>：  <ul>
<li>当表的连接顺序满足某种规则时，直接不考虑。  </li>
<li>这些规则通过经验得到。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>调节成本常数</strong>  <ul>
<li>我们之前提到，读取一个页面的成本常数是1.0，读取并匹配一条记录的成本常数是0.2。  </li>
<li>其实还有很多其他的成本常数。  </li>
<li>并且分为两层：server层，存储引擎层。  <ul>
<li>server 负责连接管理、查询缓存、语法解析和连接优化。  </li>
<li>engine 负责对于数据的存储和访问。</li>
</ul>
</li>
<li>和这两层相关的存储常数分别放在 <code>mysql.server_cost</code> 和 <code>mysql.engine_cost</code> 里。  </li>
<li>还可以自己手动更改，但我这里不细讲了。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第十五章 Explain详解</title>
    <url>/2023/04/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20Explain%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li><strong>简介</strong>  <ul>
<li>MySQL在进行基于规则的优化和基于成本的优化之后，会生成最终的执行计划。  </li>
<li>执行计划记录了最终执行查询的步骤，比如多表连接的顺序，每个表采用什么访问方法等。  </li>
<li>使用<code>EXPLAIN</code>关键字可以查看一个查询语句的具体执行计划。</li>
</ul>
</li>
<li><strong>执行计划中的各列详解</strong>  <ol>
<li><strong>table</strong>  <ul>
<li>不管查询语句多么复杂，最后都是单表访问。  </li>
<li>所以执行计划中的每一条记录都对应一个单表，记录了对于该单表怎么执行（如访问方法<code>const</code>、<code>ref</code>、<code>range</code>等）。  </li>
<li>这些记录的顺序就是表的连接顺序。  </li>
<li><code>table</code>指的是该条记录对应的表名。</li>
</ul>
</li>
<li><strong>id</strong>  <ul>
<li><code>id</code>是<code>SELECT</code>关键字的id。  </li>
<li>每使用一个<code>SELECT</code>关键字，就会分配一个<code>id</code>。  </li>
<li>进行连接查询的表拥有同一个<code>id</code>。  </li>
<li>子查询则会使用另一个<code>id</code>。  </li>
<li>如果子查询被转换为连接查询，也会拥有相同的<code>id</code>。  </li>
<li><code>id</code>为<code>NULL</code>表示这是一个临时表。</li>
</ul>
</li>
<li><strong>select_type</strong>  <ul>
<li>每个<code>SELECT</code>语句代表一个小查询，会被分配一个<code>id</code>。  </li>
<li><code>select_type</code>表示这个<code>SELECT</code>关键字对应的小查询的类型。  </li>
<li>常见的<code>select_type</code>：  <ol>
<li><strong>simple</strong>：表示查询不包括子查询或<code>UNION</code>操作，常见于单表查询和连接查询。  </li>
<li><strong>primary</strong>：表示该查询是一个大查询，由几个小查询组成。使用了<code>UNION</code>或子查询的查询就是<code>primary</code>。  </li>
<li><strong>union</strong>：用于<code>UNION</code>查询，第一个小查询的类型是<code>primary</code>，其余的小查询类型是<code>union</code>。  </li>
<li><strong>union result</strong>：表示该表是一个用于<code>UNION</code>的临时表，并且这表没有<code>id</code>。  </li>
<li><strong>subquery</strong>：表示该查询是未转换为半连接的不相关子查询，并使用物化方式执行。  </li>
<li><strong>dependent subquery</strong>：表示这是未转换为半连接的相关子查询，会执行多遍。  </li>
<li><strong>dependent union</strong>：子查询中的<code>UNION</code>查询，依赖于外层查询。  </li>
<li><strong>drived</strong>：表示用物化表的方式执行派生表查询。  </li>
<li><strong>materialized</strong>：子查询物化后与外层查询进行连接查询。    <span id="more"></span></li>
</ol>
</li>
</ul>
</li>
<li><strong>partitions</strong>  <ul>
<li>跟分区相关，通常为<code>NULL</code>。</li>
</ul>
</li>
<li><strong>type</strong>  <ul>
<li>表示查询该表时使用的访问方法，如<code>system</code>、<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>index_merge</code>、<code>range</code>、<code>index</code>、<code>all</code>等。  </li>
<li>访问方法按效率从高到低排列：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>all</code>。  </li>
<li>详细解释：  <ol>
<li><strong>system</strong>：表中只有一条记录，用MyISAM或Memory存储引擎，表的统计信息是精确的。  </li>
<li><strong>const</strong>：单表查询时，对主键或唯一二级索引字段进行常数等值匹配。  </li>
<li><strong>eq_ref</strong>：连接查询时，对被驱动表的主键或唯一二级索引字段进行常数等值匹配。  </li>
<li><strong>ref</strong>：对普通二级索引字段进行常量等值匹配。  </li>
<li><strong>index_merge</strong>：索引合并，多个索引同时使用。  </li>
<li><strong>range</strong>：单表查询时使用范围查询。  </li>
<li><strong>index</strong>：使用覆盖索引，对二级索引进行扫描，不回表。  </li>
<li><strong>all</strong>：对聚集索引进行全表扫描。</li>
</ol>
</li>
</ul>
</li>
<li><strong>possible_keys和key</strong>  <ul>
<li><code>possible_keys</code>表示可以使用的索引，<code>key</code>表示实际使用的索引。  </li>
<li>注意：<code>possible_keys</code>并不是越多越好，可用索引越多，查询优化器就需要为更多的执行方案计算成本。</li>
</ul>
</li>
<li><strong>key_len</strong>  <ul>
<li>表示使用的索引字段的最大长度，主要功能是让我们知道使用联合索引时用到了几个字段。</li>
</ul>
</li>
<li><strong>ref</strong>  <ul>
<li><code>ref</code>表示对索引列进行等值匹配时，匹配的是什么类型。</li>
</ul>
</li>
<li><strong>rows</strong>  <ul>
<li>表示预计扫描的行数。</li>
</ul>
</li>
<li><strong>filtered</strong>  <ul>
<li>与<code>condition filtering</code>相关，用于计算<code>fanout</code>。  </li>
<li><code>filtered</code>是一个百分比，用于估计扫描到的记录中有多少记录符合条件。</li>
</ul>
</li>
</ol>
</li>
<li><strong>执行计划中剩下的字段</strong>  <ol>
<li><strong>Extra</strong>  <ul>
<li>提供一些额外的提示信息，如：  <ol>
<li><strong>no tables used</strong>：<code>FROM</code>子句为空。  </li>
<li><strong>impossible where</strong>：<code>WHERE</code>子句为永假式。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>JSON格式的执行计划</strong>  <ul>
<li>使用<code>FORMAT=JSON</code>，可以将执行计划通过JSON格式输出。</li>
</ul>
</li>
<li><strong>show warnings</strong>  <ul>
<li>执行完<code>EXPLAIN</code>后，再调用<code>SHOW WARNINGS</code>，就可以看到查询优化器重写后的查询语句。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第十四章 MySQL基于规则的优化</title>
    <url>/2023/04/05/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li><strong>简介</strong>  <ul>
<li>查询优化器除了会根据查询成本进行优化之外，还会使用特定规则查询语句进行重写，优化查询性能。</li>
</ul>
</li>
<li><strong>条件化简</strong>  <ul>
<li>条件化简会对查询语句进行简化：  <ol>
<li>移除不必要的括号。  </li>
<li><strong>常量传递</strong>  <ul>
<li>当查询条件使用<code>AND</code>连接时，可以将 <code>a = 5 AND b &gt; a</code> 替换为 <code>a = 5 AND b &gt; 5</code>。</li>
</ul>
</li>
<li><strong>等值传递</strong>  <ul>
<li><code>a = b AND b = c AND c = 5</code> 替换为 <code>a = 5 AND b = 5 AND c = 5</code>。</li>
</ul>
</li>
<li><strong>移除没用的条件</strong>  <ul>
<li>移除永真或者永假的表达式。</li>
</ul>
</li>
<li><strong>表达式计算</strong>  <ul>
<li>对只包含常量的表达式进行提前计算，<code>a = 5 + 1</code> 替换为 <code>a = 6</code>。  </li>
<li>注意不会对涉及字段的表达式进行化简，所以不要对索引字段使用表达式或函数。</li>
</ul>
</li>
<li><strong><code>HAVING</code>子句和<code>WHERE</code>子句合并</strong>  <ul>
<li>如果查询语句里没有聚集函数以及<code>GROUP BY</code>子句，就把<code>HAVING</code>子句和<code>WHERE</code>子句合并起来。</li>
</ul>
</li>
<li><strong>常量表检测</strong>  <ul>
<li>满足常量表查询有两种条件：  <ol>
<li>查询的表中没有记录，或者只有一条记录。  </li>
<li>使用<code>const</code>访问方法进行查询（对主键或者唯一二级索引进行等值匹配）。</li>
</ol>
</li>
<li>当查询优化器发现可以执行常量表查询时，就会跳过查询成本分析，直接查询。  <ol>
<li>然后把涉及到该表的查询条件全部替换为常数。  </li>
<li>最后再分析剩下的表的查询成本。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>外连接消除</strong>  <ul>
<li>因为内连接可以交换连接顺序，有更多执行方案，所以比起外连接有更多优化空间。  </li>
<li>可以在进行外连接时，在<code>WHERE</code>子句里指定被驱动表的字段不为<code>NULL</code>，这种方法叫做<strong>空值拒绝</strong>。  <ol>
<li>相当于把外连接转换为内连接，查询优化器也可以交换连接顺序了。    <span id="more"></span></li>
</ol>
</li>
</ul>
</li>
<li><strong>子查询优化</strong>  <ul>
<li><strong>子查询语法</strong>  <ol>
<li>子查询可以出现在所有子句里，一般出现在<code>FROM</code>和<code>WHERE</code>子句里。  </li>
<li><strong>子查询的类型</strong>  <ul>
<li>按照结果集分：  <ol>
<li><strong>标量子查询</strong>：子查询只返回一个单一的值。  </li>
<li><strong>行子查询</strong>：一行多列。  </li>
<li><strong>列子查询</strong>：一列多行，可以用于<code>IN</code>子句的参数。  </li>
<li><strong>表子查询</strong>：多列多行。</li>
</ol>
</li>
<li>按照与外层查询的关系来分：  <ol>
<li><strong>不相关子查询</strong>：子查询不依赖于外层查询的值。  </li>
<li><strong>相关子查询</strong>：子查询依赖于外层查询的值。</li>
</ol>
</li>
</ul>
</li>
<li><strong>子查询在表达式中的使用</strong>  <ul>
<li>对子查询使用逻辑运算符，如<code>[NOT] IN</code>子查询、<code>ANY/SOME/ALL</code>子查询、<code>[NOT] EXISTS</code>子查询。</li>
</ul>
</li>
<li><strong>子查询语法注意事项</strong>  <ul>
<li>子查询必须用小括号括起来。  </li>
<li><code>SELECT</code>子句中的子查询必须是标量子查询。  </li>
<li>可以用<code>LIMIT 1</code>限制记录数量，来得到标量子查询或行子查询。  </li>
<li>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。  </li>
<li>不允许在增删改的同时进行子查询。</li>
</ul>
</li>
</ol>
</li>
<li><strong>子查询在MySQL中的优化</strong>  <ol>
<li><strong>标量子查询、行子查询的执行过程</strong>  <ul>
<li>对于不相关的标量子查询、行子查询，MySQL会分别执行子查询和外层查询，相当于两个单表查询。  </li>
<li>对于相关的标量子查询、行子查询，MySQL会从外层查询中获取记录，放到子查询中执行，然后再判断外层查询的<code>WHERE</code>子句是否成立。</li>
</ul>
</li>
<li><strong>IN子查询优化</strong>  <ul>
<li><strong>物化表的引入</strong>：  <ol>
<li>对于结果集少的不相关<code>IN</code>子查询，直接把<code>IN</code>子句中的参数一个个拿到表里精确查找或范围查找。  </li>
<li>对于结果集特别大的<code>IN</code>子查询，引入物化表，将子查询的结果集存入临时表里，并且进行去重。  </li>
<li>使用物化表后，MySQL会把<code>IN</code>子查询转换为内连接，查询优化器会计算两种连接方式的成本，然后选择成本最低的方式执行。</li>
</ol>
</li>
<li><strong>IN子查询转半连接</strong>：  <ol>
<li>半连接不和内连接等价。  </li>
<li>半连接的实现方式有<code>Table pullout</code>、<code>DuplicateWeedout</code>、<code>LooseScan</code>、<code>Materialization</code>和<code>FirstMatch</code>等。</li>
</ol>
</li>
</ul>
</li>
<li><strong>ANY&#x2F;ALL子查询优化</strong>  <ul>
<li>需要搭配布尔表达式然后才能转换。  </li>
<li>比如：<code>&lt; ANY</code>子查询就是小于子查询的<code>MAX</code>值。</li>
</ul>
</li>
<li><strong>[NOT] EXISTS子查询的执行</strong>  <ul>
<li>对于不相关的<code>EXISTS</code>子查询，先执行子查询，然后外层查询。  </li>
<li>对于相关的<code>EXISTS</code>子查询，可以用索引加速，但优化空间有限。</li>
</ul>
</li>
<li><strong>派生表的物化</strong>  <ul>
<li>放在<code>FROM</code>子句里的子查询可以当作一个派生表。  </li>
<li>派生表有两种执行策略：物化派生表和消除派生表，优先消除派生表，因为可以省去物化表的成本。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》笔记 第四章 InnoDB记录结构</title>
    <url>/2023/03/17/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ol>
<li><p><strong>准备工作</strong></p>
<ul>
<li>不同存储引擎对于数据的存储格式都是不同的</li>
<li>这本书主要讲的是InnoDB的格式</li>
</ul>
</li>
<li><p><strong>InnoDB页简介</strong></p>
<ul>
<li>InnoDB会把数据划分为多个页</li>
<li>以页作为磁盘和内存之间交互的基本单位</li>
<li>页的大小一般为16KB</li>
<li>一次至少读取16KB内容的数据到内存<ul>
<li>同样的，一次最少刷新16KB的数据到磁盘</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>InnoDB行格式</strong></p>
<ul>
<li><p><strong>简介</strong></p>
<ul>
<li>我们以记录为单位往表中存储数据</li>
<li>每一条记录在磁盘上的存储方式就被称为 行格式 或者 记录格式</li>
<li>InnoDB有四种不同的行格式<ol>
<li>Compact</li>
<li>Redundant</li>
<li>Dynamic</li>
<li>Compressed <span id="more"></span></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>指定行格式的语法</strong></p>
<ul>
<li><code>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code></li>
<li><code>ALTER TABLE 表名 ROW_FORMAT=行格式名称</code></li>
</ul>
</li>
<li><p><strong>Compact行格式</strong></p>
<ul>
<li><strong>结构</strong><br> <img src="/2023/03/17/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/image.png"></li>
<li><strong>记录的额外的信息</strong><ul>
<li>也就是为了描述记录不得不添加的记录</li>
<li><strong>变长字段长度列表</strong><ul>
<li>因为有些字段是变长的，所以我们除了记录实际的数据之外，还需要记录每个变长数据占用的字节数</li>
<li>所以在Compact行格式中，会把每个变长字段数据的字节数按照逆序存放</li>
<li>每个变成字段数据占用的字节数用一个字节或两个字节存，取决于字符集和变长字段的最长长度</li>
<li>注意 当变长字段数据为null时，不存储它的长度</li>
</ul>
</li>
<li><strong>NULL值列表</strong><ul>
<li>用来标记哪些字段的值为null</li>
<li>每个字段用一个bit来标记，也是逆序，为1时表示该值为null</li>
<li>如果每个字段都不允许为null，那就不记录数据</li>
</ul>
</li>
<li><strong>记录头信息</strong><ul>
<li>记录一些额外信息，比如<ul>
<li>删除标记</li>
<li>记录类型</li>
<li>下一条记录的相对位置</li>
</ul>
</li>
<li>之后会详细讲</li>
</ul>
</li>
</ul>
</li>
<li><strong>记录的真实数据</strong><ul>
<li>除了实际的字段值之外，还会存储一些隐藏字段，比如<ul>
<li>行ID<ul>
<li>在没有主键，没有unique键的情况下</li>
<li>才会自动生成row id</li>
</ul>
</li>
<li>事务ID</li>
<li>回滚指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redundant行格式</strong></p>
<ul>
<li><strong>示意图</strong></li>
</ul>
<p>  <img src="/2023/03/17/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/image-1.png"></p>
<ul>
<li><strong>简介</strong><ul>
<li>这个过时了，看看就行</li>
<li>字段长度偏移表记录每个字段的结束地址<ul>
<li>需要用相邻的偏移量相减才能知道该字段的长度</li>
</ul>
</li>
<li>记录头信息和Compact差不多，有些许的不同</li>
<li>偏移量会有一个null比特位，标记该字段是否为null</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>行溢出数据的情况</strong></p>
<ul>
<li><strong>varchar(M)最多能存储的数据</strong><ul>
<li>mysql中对于varchar类型，最多可以占用65535个字节<ul>
<li>对于BLOB和TEXT类型倒没要求</li>
</ul>
</li>
<li>其中M表示最多可以存储的字符数量<ul>
<li>因为总体字节数有限制，所以M的大小取决于用的字符集占用几个字节</li>
</ul>
</li>
<li>其实是因为mysql对于一条记录的大小限制为65535个字节<ul>
<li>包括了除了真实数据之外的额外记录数据，比如变长字段长度列表和NULL列表</li>
</ul>
</li>
</ul>
</li>
<li><strong>记录中的数据太多产生的行溢出</strong><ul>
<li>因为数据库中的数据是以页为单位存储的，16KB，而varchar最多能存64KB的数据</li>
<li>所以当一个字段数据太多时，会只存一部分，以及一个指向其它页的指针，指针指向的页存放剩余的部分，也叫溢出页(这是Compact和Redundant行格式处理溢出的方法)</li>
</ul>
</li>
<li><strong>行溢出的临界点</strong><ul>
<li>一条记录中的所有数据以及额外记录信息 超过16KB时就会发生行溢出</li>
<li>不需要知道具体的临界点，只需要知道当存储数据很大时就可能发生溢出就行了</li>
</ul>
</li>
<li><strong>Dynamic和Compressed行格式</strong><ul>
<li>MySQL5.7默认使用的行格式就是Dynamic</li>
<li>这两种行格式和Compact的区别只在于对于行溢出的处理<ul>
<li>Dynamic和Compressed都会把产生行溢出的字段的全部真实数据放在其他页上，只在记录中存放指针</li>
</ul>
</li>
<li>Compressed会在Dynamic基础上对页面进行压缩，节省空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《人件 Peopleware》笔记</title>
    <url>/2023/10/25/%E3%80%8A%E4%BA%BA%E4%BB%B6%20Peopleware%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、书名和作者"><a href="#一、书名和作者" class="headerlink" title="一、书名和作者"></a><strong>一、书名和作者</strong></h2><ul>
<li><strong>书名：</strong> 人件 Peopleware: Productive Projects and Teams</li>
<li><strong>作者：</strong> Tom DeMarco &#x2F; Timothy Lister</li>
</ul>
<h2 id="二、书籍概览"><a href="#二、书籍概览" class="headerlink" title="二、书籍概览"></a><strong>二、书籍概览</strong></h2><ul>
<li><p><strong>主要论点和结构</strong></p>
<p>  本书是软件管理领域的传奇经典，被誉为“对美国软件业影响最大的一本书”。全书从管理人力资源、创建健康的办公环境、高效团队形成、改造企业文化和快乐工作等多个角度阐释了如何思考和管理软件开发的最大问题——人，以得到高效的项目和团队。</p>
<p>  全书分为六个主要部分，分别是“管理人力资源”、“办公环境”、“正确的人”、“高效团队养成”、“沃土”和“快乐地工作”。</p>
</li>
<li><p><strong>目标读者和应用场景</strong></p>
<p>  本书适合所有软件工程师、项目经理、软件开发者、软件工程专业学生等正在或者将要从事软件开发的人员阅读。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="三、核心观点与主题"><a href="#三、核心观点与主题" class="headerlink" title="三、核心观点与主题"></a><strong>三、核心观点与主题</strong></h2><h3 id="主题一-此时此刻，一个项目正在走向失败"><a href="#主题一-此时此刻，一个项目正在走向失败" class="headerlink" title="主题一  此时此刻，一个项目正在走向失败"></a><strong>主题一  此时此刻，一个项目正在走向失败</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  作为管理者，典型的失败情境：习惯把人当作固定的模块来管理。</p>
</li>
<li><p><strong>子观点2</strong></p>
<p>  在失败的绝大多数项目中，没有一个是因为单纯的技术问题导致失败的。</p>
</li>
<li><p><strong>子观点3</strong></p>
<p>  工作中的问题更多属于社会学范畴，而非技术范畴。<br>  但是大部分管理者总是将精力放在解决技术问题上，与人相关的要素被放到了最低优先级。</p>
</li>
<li><p><strong>子观点4</strong></p>
<p>  大家以为自己是高科技工作者（其实不是），并且习惯性地专注于工作中的技术问题。并不是因为他们重要，而是因为他们更简单。比人与人之间的互动简单多了。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p> 统计结果表明有15%的项目出现问题:项目取消、终止、延迟或者交付的产品从未被使用。项目越大，出现问题的几率就越高。对于持续时间达到25个工作年及以上的项目，足有25%的项目最后宣告失败。作者分析了这些案例，并且发现绝大多数失败项目中，没有一个是因单纯的技术问题导致失败的。</p>
</li>
</ul>
<h3 id="主题二-干酪汉堡，做一个卖一个"><a href="#主题二-干酪汉堡，做一个卖一个" class="headerlink" title="主题二  干酪汉堡，做一个卖一个"></a><strong>主题二  干酪汉堡，做一个卖一个</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  管理脑力劳动者，不应该采用快餐行业的管理方法。也就是不应该把员工当作可以随便替换的零部件。</p>
</li>
<li><p><strong>子观点2</strong></p>
<p>  营造一个不容许任何失误的氛围会让大家持有戒心，大家就会害怕犯错。在这种情况下，平均水平也许会提高，但是团队的社会氛围会遭受伤害。</p>
<p>  相反的做法是鼓励大家犯错。可以不时地去问问大家遭遇了那些错误，让大家明白犯错是可以的。</p>
</li>
<li><p><strong>子观点3</strong></p>
<p>  管理不是踢屁股。向人们施压可以增加短期输出，长远看还是无效的。</p>
<p>  不需要使用严格的度量来促使大家工作，大部分人是热爱工作的。有时可能需要采取一些手段让大家少工作一会儿。</p>
</li>
<li><p><strong>子观点4</strong></p>
<p>  在生产环境中，容易将人当作是机器的零部件。磨损了就可以换个新的。不要盲目地遵从这个风格。</p>
<p>  不要因为员工的独特个性而感到害怕，从而去扼杀它。</p>
</li>
<li><p><strong>子观点5</strong></p>
<p>  不要只关注每个员工在当下的产出，从而来评估员工对于项目的贡献。</p>
<p>  有的员工产生的作用并不是明显可见的，比如催化剂的角色，可以增加整个项目团队的粘性。</p>
</li>
<li><p><strong>子观点6</strong></p>
<p>  磨刀不误砍柴工。花更多的时间在思考和计划上，而不是在实施上。越是时间紧迫的项目，更是应该在团队内部进行频繁的头脑风暴。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  有的员工并不能做出明显的对项目的贡献，但可能是一个超级催化剂。这种存在使得团队内部更有黏度。可以帮助团队成员互相交流和相处，有他的项目会变得更加有趣。我们需要认识到催化剂这个角色在一个项目中的重要性。</p>
</li>
</ul>
<h3 id="主题三-维也纳在等你"><a href="#主题三-维也纳在等你" class="headerlink" title="主题三  维也纳在等你"></a><strong>主题三  维也纳在等你</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  管理者总是在研究如何让人们以牺牲自我生活为代价来承受更大的工作强度。</p>
</li>
<li><p><strong>子观点2</strong></p>
<p>  西班牙理论就是认为财富的总量是固定的，因此得殖民别人，抢黄金，造成的结果就是通货膨胀。</p>
<p>  生产效率应该是在单位工作时间内产生更多的价值，而管理者思考的是如何在单位薪酬内获取更多的价值。</p>
<p>  奉行西班牙理论的管理者想通过无偿的加班来获得生产效率的提高。他们给员工强化交付日期的重要性（其实可能是随意的，地球不会因为项目晚了一个月就停止转动）。让员工因为内疚而不得不牺牲自己的时间来工作。</p>
</li>
<li><p><strong>子观点3</strong></p>
<p>  项目成员都会意识到人生苦短，生活中还有很多比工作更重要的事情。</p>
</li>
<li><p><strong>子观点4</strong></p>
<p>  每加班一个小时，就可能导致员工在正常的工作时间摸鱼一个小时进行补偿，这是杀鸡取卵。<br>  但管理者看不到摸鱼时间，只关注总时间。实际上最终的有效工作时间还是相同的。</p>
</li>
<li><p><strong>子观点5</strong></p>
<p>  工作狂会自愿做很多加班，如果管理者无底线地对工作狂进行压榨。工作狂迟早有一天也会离职。</p>
</li>
<li><p><strong>子观点6</strong></p>
<p>  需要多考虑考虑生产效率和人员流失率之间的取舍，控制在可接受范围内。<br>  别超额完成任务后导致所有人在项目结束后离职。</p>
<p>  也要考虑工作速度和产品质量之间的关系。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  大多数组织不会对流失人员进行统计。无论什么时候讨论生产效率，衡量起来都好像人员流失根本不存在，或者与成本无关一样。DataGeneral的Eagle项目就是这样一个案例。该项目是西班牙理论的胜利：工作狂的项目成员通过不停加班把生产效率推向了一个前所未有的高度。但项目最后，几乎所有开发人员都离职了。</p>
</li>
</ul>
<h3 id="主题四-质量——如果时间允许"><a href="#主题四-质量——如果时间允许" class="headerlink" title="主题四  质量——如果时间允许"></a><strong>主题四  质量——如果时间允许</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  采取任何可能牺牲产品质量的行动都可能挑起员工反对的情绪。</p>
</li>
<li><p><strong>子观点2</strong></p>
<p>  当开发过程被置于极度的时间压力时，质量是第一个开始被牺牲的代价。<br>  但质量毫无疑问是重要的，不过很多管理者认为为了快速抢占市场，降低点质量也是可以的。</p>
</li>
<li><p><strong>子观点3</strong></p>
<p>  大部分人认为过度提高质量是做无用的工作。</p>
</li>
<li><p><strong>子观点4</strong></p>
<p>  有些日本的企业，项目团队拥有否决发布未成熟产品的权力。<br>  是否给予团队成员否决交付的权力是一个需要考虑的问题。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  惠普就被认为是一个通过制造者自定义高质量标准而提升生产效率获益的典型组织。从一开始，惠普就信奉质量。在这种环境下，需要更多时间或资金来生产高质量产品的说法压根儿就没有出现过。因此，开发人员形成的文化是交付的质量要超越市场的质量要求。他们追求质量的标志成为提高他们工作满意度的动因，从而拥有行业内最低的人员流失率。</p>
</li>
</ul>
<h3 id="主题五-再谈帕金森管理"><a href="#主题五-再谈帕金森管理" class="headerlink" title="主题五  再谈帕金森管理"></a><strong>主题五  再谈帕金森管理</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  帕金森定律：工作会自动膨胀，占满一个人所有的可用时间。但帕金森定律并不是公理，只是存在一定的真实成分。</p>
</li>
<li><p><strong>子观点2</strong></p>
<p>  一旦某个员工表现出工作低效，那么应该让他调换工作或跳槽，而不是继续施加更多的压力。</p>
</li>
<li><p><strong>子观点3</strong></p>
<p>  在某些情况下，不给团队压力，反而会得到最高的生产效率，但也不是绝对的。</p>
</li>
<li><p><strong>子观点4</strong></p>
<p>  一个组织的工作如果都忙忙碌碌，就会膨胀以至于占满整个工作日。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  倘若你不知道其实很少有管理者接受过管理方面的正规培训，你可能会错以为他们都是科班出身，在学校就学过帕金森定律及其分支理论。即使管理者对管理一无所知，他们也极为认同帕金森定律这一针对员工及其态度进行管理的公理。定律为他们提供了强有力的证据，只有设定不可能完成的交付日期，才能保证工作的完成。</p>
</li>
</ul>
<h2 id="四、亮点与启发"><a href="#四、亮点与启发" class="headerlink" title="四、亮点与启发"></a><strong>四、亮点与启发</strong></h2><ul>
<li><p><strong>最有影响的观点或实例</strong></p>
<p>  本书强调了在软件项目开发过程中，最重要的是人而不是技术。因为我们工作中所面临的问题，本质上都是社会性的问题而不是技术性的问题。因此我们需要学习如何尊重人，发挥人的潜能，通过人来创造高效率的团队。</p>
</li>
<li><p><strong>对个人或专业发展的启示</strong></p>
<p>  如果我以后成为了管理者，我需要像书中所讲的那样尊重自己的团队成员，规划合理的工作时间，打造怡人的工作环境，鼓励大家试错，尊重不同成员的个性，不以单一的指标去评判员工对于项目的贡献，以此来可持续性地提高整个团队的工作效率。</p>
</li>
</ul>
<h2 id="五、批评与局限性"><a href="#五、批评与局限性" class="headerlink" title="五、批评与局限性"></a><strong>五、批评与局限性</strong></h2><ul>
<li><p><strong>任何有争议、模糊或过时的信息</strong></p>
<p>  书中所讲的内容可能太过于理想化了，就像乌托邦一样，给员工最好的福利和最低的压力真的就能有最好的工作效率吗。并且考虑到当今IT行业的工作的环境，感到的只有离天堂太远的哀伤。</p>
</li>
</ul>
<h2 id="六、实际应用和拓展"><a href="#六、实际应用和拓展" class="headerlink" title="六、实际应用和拓展"></a><strong>六、实际应用和拓展</strong></h2><ul>
<li><p><strong>在实际工作&#x2F;学习中如何应用这些概念</strong></p>
<p>  书中提到了一个“流”的概念，流是一种深度的近乎于冥想的融入情况。在此种状态下，有一种普适幸福感存在，人们几乎不会意识到时间的流逝，工作会变得非常高产。</p>
<p>  不幸的是，我们需要一个缓慢的过程来进入状态，15分钟或更长时间的集中才能把自己锁定在流里面。在这个引入过程中，我们对噪声和干扰是非常敏感的。</p>
<p>  因此在我们平时的学习工作时，可以提前有意减少潜在的打扰对象，比如把手机放在远处、把耳机带上等等，这可以提高我们的工作效率。</p>
</li>
</ul>
<h2 id="七、总结与评价"><a href="#七、总结与评价" class="headerlink" title="七、总结与评价"></a><strong>七、总结与评价</strong></h2><ul>
<li><p><strong>对书籍的整体评价</strong></p>
<p>  很有启发性，读起来很有趣，语言也翻译得没有那么生涩，容易理解。书中讲解的内容和以后的工作也息息相关，可以派上用场。</p>
</li>
<li><p><strong>书籍的长处和短处</strong></p>
<p>  这本书读起来很有道理，但我毕业后先去干开发，这些道理又好像没用了，因为我是被管的那个。短处就是让我窥见了天堂，自己又只能下地狱，更绝望了。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《人月神话 The Mythical Man-Month》笔记</title>
    <url>/2023/10/09/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%20The%20Mythical%20Man-Month%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、书名和作者"><a href="#一、书名和作者" class="headerlink" title="一、书名和作者"></a><strong>一、书名和作者</strong></h2><ul>
<li><strong>书名：</strong> 人月神话　The Mythical Man-Month</li>
<li><strong>作者：</strong> Fred Brooks</li>
</ul>
<h2 id="二、书籍概览"><a href="#二、书籍概览" class="headerlink" title="二、书籍概览"></a><strong>二、书籍概览</strong></h2><ul>
<li><p><strong>主要论点和结构</strong></p>
<p>  本书主要探讨了软件工程中是否有银弹的问题。作者认为缺乏合理的时间进度是造成项目滞后的最主要原因，比其他所有因素加起来影响还大。同时，人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的，但是往进度落后的项目中增加新的人手只会让进度更加落后。</p>
</li>
<li><p><strong>目标读者和应用场景</strong></p>
<p>  本书适合所有软件工程师、项目经理、软件开发者、软件工程专业学生等正在或者将要从事软件开发的人员阅读。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="三、核心观点与主题"><a href="#三、核心观点与主题" class="headerlink" title="三、核心观点与主题"></a><strong>三、核心观点与主题</strong></h2><h3 id="1-主题一-焦油坑"><a href="#1-主题一-焦油坑" class="headerlink" title="1. 主题一  焦油坑"></a><strong>1. 主题一  焦油坑</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  在过去几十年的大型系统开发中，只有极少数的项目满足了目标、进度和预算的需求。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  表面上看起来，项目中每一个单独的问题都是容易解决的，但是当他们累积在一起的时候，团队的行动就会变得越来越慢。</p>
</li>
</ul>
<h3 id="2-主题二-人月神话"><a href="#2-主题二-人月神话" class="headerlink" title="2. 主题二 人月神话"></a><strong>2. 主题二 人月神话</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  缺乏合理的进度安排是导致项目进度滞后的主要原因。</p>
</li>
<li><p><strong>子观点2</strong></p>
<p>  使用人月作为衡量一项工作的规模是一个危险的带有欺骗性的神话。</p>
</li>
<li><p><strong>子观点3</strong></p>
<p>  向落后的项目中增加人手，只会使进度更加落后。</p>
</li>
<li><p><strong>子观点4</strong></p>
<p>  在程序员群体中，乐观主义过于弥漫。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  之所以缺乏合理的进度安排是导致项目进度滞后，主要原因是人们认为人和月是可以相互替换的。</p>
<p>  使用人月作为衡量一项工作的规模是一个危险的带有欺骗性的神话。也是因为它暗示了人员数量和时间是可以相互替换的。但是人数和时间可以相互替换仅仅适用于工作人员之间不需要相互交流的情况。但是这在系统编程中是不可能的。增加更多的人手不一定会缩短时间进度，反而会延长时间进度。</p>
<p>  因为新加入的人手需要经过一段时间的培训，并且会使之前的很多工作失效，反而增加了很多额外的工作量。主要就是因为人员之间的交流是有成本的。</p>
</li>
</ul>
<h3 id="3-主题三-外科手术队伍"><a href="#3-主题三-外科手术队伍" class="headerlink" title="3. 主题三 外科手术队伍"></a><strong>3. 主题三 外科手术队伍</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  大型项目的每一个部分都应该由一个团队解决，不过该团队应该以类似外科手术般的方式组建。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  小型精干队伍效率很高，但是开发大型系统需要数十年的时间，人数不够用。但是大量的人手需要相互交流，开发效率又不会很高。</p>
<p>  因此Mills建议大型项目的每一个部分都应该由一个团队解决，但是该团队应该以类似外科手术般的方式组建。</p>
<p>  如果要将外科手术团队的概念应用到几百人的队伍上。解决办法就是让原来1&#x2F;7或者更少的人去决定软件的设计，而不是让所有人去参与讨论和交流。以此来降低交流的成本，提高效率。并且需要有一个系统结构师负责从上往下进行所有设计。</p>
</li>
</ul>
<h3 id="4-主题四-贵族专制、民主政治和系统设计"><a href="#4-主题四-贵族专制、民主政治和系统设计" class="headerlink" title="4. 主题四 贵族专制、民主政治和系统设计"></a><strong>4. 主题四 贵族专制、民主政治和系统设计</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  在系统的设计中，概念完整性应该是最重要的考虑因素。</p>
</li>
<li><p><strong>子观点2</strong></p>
<p>  设计方法和体系结构方面的工作与具体实现相分离是获得概念完整性的强有力的方法。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  软件的目的是使计算机更加容易使用，也就是说软件需要追求易用性。而简洁和直白来自概念的完整性，每个部分必须反映相同的原理需求的一致平衡。在语法上，每个部分应使用相同的技巧。因此易用性实际上需要设计的一致性和概念上的完整性。</p>
<p>  概念的完整性要求设计必须由一个人或者非常少数的人员来实现。但是进度的压力要求很多人员来开发系统。因此体系结构同实现必须仔细地区分开。</p>
</li>
</ul>
<h3 id="5-主题五-没有银弹"><a href="#5-主题五-没有银弹" class="headerlink" title="5. 主题五 没有银弹"></a><strong>5. 主题五 没有银弹</strong></h3><ul>
<li><p><strong>子观点1</strong></p>
<p>  没有任何一种单纯的技术或管理上的进步，能够独立地承诺在十年内大幅度地提高生产率、可靠性和简洁性。</p>
</li>
<li><p><strong>实例或案例</strong></p>
<p>  所有软件活动包括根本任务和次要任务，根本任务为打造构成抽象软件实体的复杂概念结构，次要任务为使用编程语言表达这些抽象实体，在空间和时间限制内将他们映射为机器语言。但除非全部次要任务的时间缩减到零，不然不会带来生产率数量级上的提高。</p>
<p>  并不是因为软件发展得太慢，而是因为计算机硬件发展得太快。作者认为软件开发中困难的部分是规格说明、设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。</p>
<p>  所以，当我们面对软件开发的复杂性时，我们必须接受一个事实：软件开发本质上就是一项困难的工作。我们可以通过改进技术和管理策略来缓解这些困难，但是无法完全消除。</p>
</li>
</ul>
<h2 id="四、亮点与启发"><a href="#四、亮点与启发" class="headerlink" title="四、亮点与启发"></a><strong>四、亮点与启发</strong></h2><ul>
<li><p><strong>最有影响的观点或实例</strong></p>
<p>  本书中最有影响力的观点之一是“人月神话”，即人员数量和时间可以相互替换。作者认为这是一个危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。实际上，增加人员数量并不能缩短项目时间表。相反，它会增加沟通和协调方面的工作量，并可能导致进度延误。</p>
<p>  另一个我觉得有意思的观点是软件开发过程中的大部分决策应该由尽可能少的人做出。因为让整个开发团队都参与决策的制定会大大地增加交流的成本，因此在团队中，“仁慈”的专制是有必要的。</p>
</li>
<li><p><strong>对个人或专业发展的启示</strong></p>
<p>  没有银弹说明在未来几十年时间内，不会有让开发效率提升几个数量级的工具的出现。软件开发过程中更多的难题还是在于对现实问题的解决方案进行建模。因此没必要焦虑以后被更先进的生产力工具所替代。而更应该专注于对核心技术的学习，构建自己的技术壁垒。</p>
</li>
</ul>
<h2 id="五、批评与局限性"><a href="#五、批评与局限性" class="headerlink" title="五、批评与局限性"></a><strong>五、批评与局限性</strong></h2><ul>
<li><p><strong>任何有争议、模糊或过时的信息</strong></p>
<p>  对于银弹是否存在其实是有很多争议的，以至于作者重新写了一章来讨论银弹是否存在的问题。</p>
</li>
<li><p><strong>可能的不足或缺陷</strong></p>
<p>  比起日益发展的技术，人月神话讲的更多的是开发大型项目时，对于团队管理需要考虑的问题，这些问题是确实存在的，不可忽视。但是书中并没有给出非常具体的解决办法，而且有的书中提及的有些工具已经过时了，现在有效率更高更有效的替代工具。</p>
</li>
</ul>
<h2 id="六、实际应用和拓展"><a href="#六、实际应用和拓展" class="headerlink" title="六、实际应用和拓展"></a><strong>六、实际应用和拓展</strong></h2><ul>
<li><p><strong>在实际工作&#x2F;学习中如何应用这些概念</strong></p>
<p>  在小组作业或者多人合作项目中，最好不要民主地让每个人都去参与决策的制定，因为这会增加很多交流的成本，导致工作一直被延迟。比较好的做法是选出一个负责人，负责对每一个决策进行定夺。同时也不能扼杀每个小组成员的创意性，得听取每个成员的意见。<br>  此外往小组中增加更多的人手也不一定会增加项目完成的效率，因为这同样会增加小组内完成任务时交流的成本。</p>
</li>
</ul>
<h2 id="七、总结与评价"><a href="#七、总结与评价" class="headerlink" title="七、总结与评价"></a><strong>七、总结与评价</strong></h2><ul>
<li><p><strong>对书籍的整体评价</strong></p>
<p>  很经典，具有启发性，书中的一些观点在本科阶段上课时经常会听到。读了原著后对那些观点有了更深的理解。</p>
</li>
<li><p><strong>书籍的长处和短处</strong></p>
<p>  书中使用了很多的比喻和例子去论证作者的观点。但可能因为年代久远或者翻译不够接地气，读起来很困难，很多地方要慢慢读才能看懂。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《原子习惯 Atomic Habits》第一章&amp;第二章 笔记</title>
    <url>/2023/02/09/%E3%80%8A%E5%8E%9F%E5%AD%90%E4%B9%A0%E6%83%AF%20Atomic%20Habits%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0&amp;%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、原子习惯的力量"><a href="#一、原子习惯的力量" class="headerlink" title="一、原子习惯的力量"></a><strong>一、原子习惯的力量</strong></h1><h2 id="小习惯大作用"><a href="#小习惯大作用" class="headerlink" title="小习惯大作用"></a><strong>小习惯大作用</strong></h2><p>日常习惯产生的微小改变很重要。</p>
<p>成功是日常习惯产生的结果，而不是千载难逢的转变。</p>
<p>同时，你目前的成功与否无关紧要，重要的是你目前的习惯是否正在把你推向成功。需要更注重于当前的过程，而不是已经拥有的结果。</p>
<h2 id="习惯的正面积累和负面积累"><a href="#习惯的正面积累和负面积累" class="headerlink" title="习惯的正面积累和负面积累"></a><strong>习惯的正面积累和负面积累</strong></h2><p>正面积累：</p>
<ul>
<li>生产力 -每天多完成一点额外工作会给你更多的余裕</li>
<li>知识 </li>
<li>人际关系 -对别人更好一点会更容易得到帮助</li>
</ul>
<p>负面积累：</p>
<ul>
<li>压力</li>
<li>负面想法</li>
<li>愤怒</li>
</ul>
<span id="more"></span>

<h2 id="进步的真正过程"><a href="#进步的真正过程" class="headerlink" title="进步的真正过程"></a><strong>进步的真正过程</strong></h2><p>努力的结果在一开始可能不会显现出来，只有超过了阈值时才会发生巨大变化。造成巨大变化是持久的努力而不是最后一击。所以别看不到什么起色就放弃了。</p>
<h2 id="忘记目标，专注过程"><a href="#忘记目标，专注过程" class="headerlink" title="忘记目标，专注过程"></a><strong>忘记目标，专注过程</strong></h2><p>设立一个目标虽然可以指明方向，但是目标最终能不能完成可能和设立目标关系不大。</p>
<p>因为设立完目标后，需要规划怎么努力。如果不注重目标，但依旧努力，依旧可能会达成目标。</p>
<p>当花太多时间研究目标的话，会产生下面的问题：</p>
<ul>
<li><strong>赢家和输家拥有相同的目标</strong> -设立远大目标就能成功只是幸存者偏差</li>
<li><strong>达成目标只是一个短暂的改变</strong> -专注过程，结果会自然变得更好，而不是只关注结果</li>
<li><strong>目标限制了你的快乐</strong> -不要把快乐推迟到成功之后，也不要觉得失败了就该难受，学会享受过程</li>
<li><strong>目标限制了你的长期进步</strong> -唯目标心态会导致完成目标后就开始摆烂，没有动力再推动自己前进，甚至坏习惯复发</li>
</ul>
<h2 id="原子习惯的系统"><a href="#原子习惯的系统" class="headerlink" title="原子习惯的系统"></a><strong>原子习惯的系统</strong></h2><p>原子习惯指的是一个微小的改变、一份边际效应和每天进步一点点。他们的特点是微小并且容易，属于系统的一部分，但是最终会积累成巨大能量</p>
<h2 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a><strong>章节总结</strong></h2><ul>
<li>习惯是自我提升的复利，每天进步一点点，日积月累一大步</li>
<li>习惯是双刃剑，因为分为好习惯和坏习惯</li>
<li>小的改变一开始不会产生影响，最终才会得到巨大收获，需要保持耐心。</li>
<li>原子习惯是庞大系统的一部分</li>
<li>如果想要好的结果，专注系统，忘记设立目标</li>
<li>成功无关目标，失败源于系统</li>
</ul>
<h1 id="二、习惯如何塑造你的个性-反之亦然"><a href="#二、习惯如何塑造你的个性-反之亦然" class="headerlink" title="二、习惯如何塑造你的个性(反之亦然)"></a><strong>二、习惯如何塑造你的个性(反之亦然)</strong></h1><p>习惯的改变分为三个层面：</p>
<ul>
<li>Outcomes -What you get</li>
<li>Process -What you do</li>
<li>Identity -What you believe</li>
</ul>
<p>“我在戒烟” -这个是Outcome层的；”我不抽烟” -这个是Identity层的。</p>
<p>只有将习惯融入自己的个性，并且对自己的习惯感到自豪，才能培养长久的习惯。</p>
<ul>
<li>成为一个读者，而不是旨在读完一本书</li>
<li>成为一个跑者，而不是旨在跑完马拉松</li>
<li>成为一个音乐家，而不是旨在学一门乐器</li>
</ul>
<p>当你的行为和个性高度一致时，你就不是在强迫自己保持习惯，而是acting like the type of person you already believe yourself to be.</p>
<p>反之亦然，你觉得自己不聪明，那你就会变得不聪明；你觉得自己就是懒，那你就无法早起。</p>
<p>不要觉得自己的个性是天生的不可改变的，如果你想提升自己，你需要不断地调整自己的Identity。</p>
<h2 id="改变个性-x2F-内在的两个步骤"><a href="#改变个性-x2F-内在的两个步骤" class="headerlink" title="改变个性&#x2F;内在的两个步骤"></a><strong>改变个性&#x2F;内在的两个步骤</strong></h2><p>改变自己的行为就是改变自己的个性。</p>
<p>改变内在分为两个步骤</p>
<ol>
<li>弄清楚你想成为什么样的人</li>
<li>通过一点点的提升证明自己</li>
</ol>
<p>举个例子，如果你想薪水翻倍，就去想想高薪水的人都是什么样的。比如高薪的人乐于学习并且自律，然后就研究自己如何成为一个乐于学习且自律的人，而不是总想着我要赚钱。</p>
<p>当你弄清楚了自己想成为什么样的人，就可以养成各种习惯去强化这个Identity。</p>
<p>比如早上起床的时候就可以想“公司总裁会不会睡懒觉？”；想暴饮暴食的时候就想“健康自律的人会不会暴饮暴食？”。</p>
<p>如果你总是表现得像一个自律的人，那么你最后就会成为一个自律的人。</p>
<p>行为和内在之间存在双向影响，我们最好用自己的意念去驱使这个循环，而不是让结果来驱使。</p>
<p>着重关注自己想成为什么样的人，而不是一个特定的结果</p>
<h2 id="习惯重要的真正原因"><a href="#习惯重要的真正原因" class="headerlink" title="习惯重要的真正原因"></a><strong>习惯重要的真正原因</strong></h2><p>习惯帮助你成为你想要成为的人，他们是改变你最深层内在的途径。</p>
<h2 id="章节总结-1"><a href="#章节总结-1" class="headerlink" title="章节总结"></a><strong>章节总结</strong></h2><ul>
<li>改变分为三个层面：Outcome, Process, Identity</li>
<li>最有效的改变习惯的方法是关注自己想成为什么样的人，而不是想获得什么</li>
<li>成为最好版本的自己需要不断地调整自己的信仰和内在</li>
<li>习惯之所以重要，不是因为他们给你带来了好的结果，而是改变了你的内在</li>
</ul>
<h2 id="我想成为什么样的人"><a href="#我想成为什么样的人" class="headerlink" title="我想成为什么样的人"></a><em><strong>我想成为什么样的人</strong></em></h2><p><strong>自律的人</strong> 早睡早起，抵制诱惑，多花时间干正事</p>
<p><strong>健康的人</strong> 每天坚持锻炼</p>
<p><strong>外向的人</strong> 有合适机会时就主动参加别人的活动，对别人更好一点</p>
<p><strong>赚大钱的人</strong> 专注于提升能力，提升修养</p>
]]></content>
      <tags>
        <tag>学习习惯</tag>
      </tags>
  </entry>
</search>
